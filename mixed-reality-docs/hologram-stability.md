---
title: ホログラムの安定性
description: HoloLens はホログラムを自動的に安定させますが、開発者はさらにホログラムの安定性を向上させるために実行できる手順があります。
author: thetuvix
ms.author: alexturn
ms.date: 03/21/2018
ms.topic: article
keywords: ホログラム、安定性、hololens
ms.openlocfilehash: b35b904e3c662c5ebd0670a98044706fe208e348
ms.sourcegitcommit: c20563b8195c0c374a927b96708d958b127ffc8f
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 05/21/2019
ms.locfileid: "65974939"
---
# <a name="hologram-stability"></a>ホログラムの安定性

安定したホログラムを実現するために、HoloLens にはイメージ安定化パイプラインが組み込まれています。 安定化パイプラインはバックグラウンドで自動的に動作するため、有効にするために余分な手順は必要ありません。 ただし、開発者は、ホログラムの安定性を向上させる手法を実行し、安定性を低下させるシナリオを回避する必要があります。

## <a name="hologram-quality-terminology"></a>ホログラムの品質に関する用語

ホログラムの品質は、優れた環境と優れたアプリ開発の結果となります。 HoloLens が周囲を追跡できる環境で、1秒あたりに定数60のフレームをヒットしたアプリは、ホログラムと一致する座標系が同期されていることを確認します。ユーザーの観点からは、静止しているホログラムは、環境に対して相対的には移動しません。

環境で問題が発生した場合、レンダリング速度が一貫していない場合、またはその他のアプリの問題が発生した場合は、次の用語が問題を特定するのに役立ちます。
* **精度.** ホログラムが世界中にロックされ、現実世界に配置されると、ユーザーの動きや小規模な環境の変化に関係なく、周囲の環境を基準とした場所に配置されます。 後でホログラムが予期しない場所にある場合は、*精度*の問題になります。 このようなシナリオは、2つの異なるルームが同一である場合に発生する可能性があります。
* **ずれ.** ユーザーはこれをホログラムの高周波数のぶれとして観察します。 これは、環境の追跡が低下した場合に発生する可能性があります。 ユーザーの場合、ソリューションは[センサーチューニング](sensor-tuning.md)を実行しています。
* **Judder.** レンダリング周波数が低いと、ホログラムの動きとダブルイメージが不均一になります。 これは、モーションを持つホログラムで特に顕著です。 開発者は、 [60 FPS の定数](hologram-stability.md#frame-rate)を維持する必要があります。
* **誤差.** これは、最初に配置された場所から移動するために、ホログラムとして表示されます。 これは、特に、完全にマップされていない環境の一部で、ホログラムが[空間アンカー](spatial-anchors.md)から遠く離れた場合に発生します。 空間アンカーの近くにホログラムを作成すると、誤差の可能性が低くなります。
* **Jumpiness.** ホログラムが "ポップ" または "ジャンプ" をときどき場所から離れている場合。 これは、追跡によって、環境の最新の理解に一致するようにホログラムが調整されると発生する可能性があります。
* **スイム.** ユーザーの頭の動きに対応する、ホログラムが sway に表示されるとき。 このエラーは、ホログラムが[安定化平面](hologram-stability.md#stabilization-plane)上にない場合、および HoloLens が現在のユーザーに対して[調整](calibration.md)されていない場合に発生します。 ユーザーは[調整](calibration.md)アプリケーションを再実行して、この問題を修正できます。 開発者は、安定化平面を更新して安定性をさらに向上させることができます。
* **色の分離。** HoloLens のディスプレイはカラーの連続した表示であり、フラッシュカラーチャンネルは 60Hz (個々の色フィールドは 240Hz) で点滅します。 ユーザーが目を通して移動するホログラムを追跡するたびに、そのホログラムの先頭および末尾のエッジは、構成色が異なるため、レインボー効果が生成されます。 分離の度合いは、ホログラムの速度に依存します。 場合によっては、固定されたホログラムを見ながら1頭を移動すると、レインボー効果が生じることもあります。 これは呼び出されます *[色の分離](hologram-stability.md#color-separation)* します。

## <a name="frame-rate"></a>フレーム レート

フレームレートは、ホログラムの安定性の最初の柱です。 ホログラムが世界中で安定して表示されるようにするには、ユーザーに表示される各イメージに、正しい位置にホログラムが描画されている必要があります。 では、HoloLens の更新時に240に1秒間隔で表示され、新たにレンダリングされたイメージごとに4つの色フィールドが表示されます。これにより、60 FPS (1 秒あたりのフレーム数) のユーザーエクスペリエンスが得られます。 アプリケーション開発者は、可能な限り最良の方法を提供するために、60 FPS を維持する必要があります。これにより、オペレーティングシステムに対して16ミリ秒ごとに新しいイメージが一貫して提供されます。

**60 FPS**ホログラムを実際の世界に座っているように描画するには、ユーザーの位置からイメージをレンダリングする必要があります。 イメージのレンダリングには時間がかかるため、ディスプレイに画像が表示されたときのユーザーの頭の位置が HoloLens によって予測されます。 この予測アルゴリズムは、近似値です。 HoloLens には、レンダリングされたイメージを調整して、予測されるヘッド位置と実際のヘッド位置との違いを考慮するハードウェアがあります。 これにより、ユーザーに表示されるイメージは、正しい位置から表示されているかのように見え、ホログラムが安定しているように見えます。 イメージの更新は、小さな変更によって最適に機能します。また、視差のようにレンダリングされたイメージ内の特定の項目を完全に修正することはできません。

60 FPS でレンダリングすることにより、安定したホログラムの作成に役立つ3つの作業を行います。
1. イメージのレンダリングと、そのイメージがユーザーに表示されるまでの全体的な待機時間を最小限に抑えます。 ゲームスレッドと、lockstep で実行されているレンダースレッドがあるエンジンでは、30FPS で実行すると、33.3 ミリ秒の余分な待機時間を追加できます。 待機時間を短縮することで、予測エラーが減少し、ホログラムの安定性が向上します。
2. これにより、すべてのイメージがユーザーの目に到達するまでの待機時間が一貫しています。 30 fps でレンダリングした場合でも、画像は 60 FPS で表示されます。 これは、同じイメージが1行に2回表示されることを意味します。 2番目のフレームは、最初のフレームよりも 16.6 ms の待機時間が長くなり、より顕著なエラーを修正する必要があります。 このようなエラーの大きさが不整合になると、60hz judder が発生する可能性があります。
3. Judder の外観を下げる (動きとダブルイメージが不均一である)。 ホログラムの動きが速くなり、レンダリング速度が低下し、より発音の judder に関連付けられます。 そのため、常に 60 FPS を維持することによって、特定の可動ホログラムの judder を回避することができます。

**フレームレートの一貫性**フレームレートの一貫性は、1秒あたりの高フレーム数と同様に重要です。 場合によっては、コンテンツが豊富なアプリケーションでフレームが破棄されることはありません。また、HoloLens は、不定期に発生した障害から復旧するための高度なアルゴリズムを実装します。 ただし、絶えず変動するフレームレートは、ユーザーにとって、より低いフレームレートで一貫して実行するよりもはるかに顕著です。 たとえば、5つのフレーム (これらの5つのフレームの実行中は 60 FPS) に対してスムーズにレンダリングし、次の10フレーム (10 フレームの間は 30 FPS) に対して他のフレームをすべてドロップするアプリケーションは、一貫していないアプリケーションよりも不安定であると思われます。30 FPS でレンダリングします。

関連する注意事項として、オペレーティングシステムは、混合の現実の[キャプチャ](mixed-reality-capture.md)が実行されている場合に、アプリケーションを 30 FPS に調整します。

**パフォーマンス分析**アプリケーションのフレームレートのベンチマークに使用できるツールには、次のようなものがあります。
* GPUView
* Visual Studio グラフィックスデバッガー
* Unity などの3D エンジンに組み込まれたプロファイラー

## <a name="hologram-render-distances"></a>ホログラムのレンダリング距離

>[!VIDEO https://www.youtube.com/embed/-606oZKLa_s]

人間のビジュアルシステムでは、オブジェクトを固定し、オブジェクトに焦点を当てたときに、複数の距離に依存する信号を統合します。
* [宿泊施設](https://en.wikipedia.org/wiki/Accommodation_%28eye%29)-個々の視点の焦点。
* [収束](https://en.wikipedia.org/wiki/Convergence_(eye))-オブジェクトの中心に向かって、または外側に移動する2つの目。
* [付い双眼鏡](https://en.wikipedia.org/wiki/Stereopsis)格差は、オブジェクトの距離に依存している、左側と右目の画像との間の距離を示します。
* 網掛け、相対角度のサイズ、およびその他の monocular (単一目) のキュー。

収束と設備は、異なる距離でオブジェクトを認識するように目が変化する方法に関連する特別な網膜の手掛かりであるため、一意です。 自然な表示では、収束と設備がリンクされています。 目の端が近くに表示されている場合 (例: 鼻)、目が交差し、近い位置に収まります。 目が無限に表示されると、目は並列になり、目は無限大になります。 Hololens のディスプレイは、ユーザーから約2.0 分離れている光学式の距離で固定されているため、HoloLens を装着したユーザーは常に 2.0 m に対応して明確なイメージを維持します。 アプリ開発者は、さまざまな深度でコンテンツとホログラムを配置することで、ユーザーの目がどのようになるかを制御します。 ユーザーがさまざまな距離に対応して収束すると、2つのキュー間の自然なリンクが失われ、特に競合の大きさが大きい場合に、visual 不快感や疲労が発生する可能性があります。 Vergence の競合からの不快感は、ユーザーが可能な限り 2.0 m に近いコンテンツを保持することによって回避または最小化できます (つまり、可能な限り 2.0 m 付近に関心のある領域が多くなるシーンでは、 Vergence から不快感の近くにコンテンツを配置できない場合は、ユーザーの距離が異なると、その差が大きくなります。 言い換えると、時間の経過と共に移動するホログラム50cm を見た場合よりも、50cm が離れたままの状態になるような静止したホログラムを見た方がはるかに快適です。

2つのディスプレイがこの距離で完全に重複するように設計されているため、2.0 m にコンテンツを配置することも便利です。 この平面から離れた画像の場合、holographic フレームの横から移動すると、他の画面に表示されている間、1つのディスプレイから見えなくなります。 この付い双眼鏡 rivalry、ホログラムの深さの知覚に悪影響を及ぼす可能性があります。

**ユーザーにホログラムを配置するための最適な距離**

![ユーザーにホログラムを配置するための最適な距離](images/distanceguiderendering-750px.png)

**クリッププレーン**最大の快適さを提供するには、1m でコンテンツを高速に出力することをお勧めします。 ホログラムとユーザーが両方とも固定されたホログラムであるアプリケーションでは、50cm の近くでも快適に表示できます。 このような場合、アプリケーションでは、クリップ平面を30cm 以下にし、フェードアウトをクリッププレーンから少なくとも10cm 離れた位置に配置する必要があります。 コンテンツが85cm よりも近い場合は常に、ユーザーがホログラムから近い場所に移動することはないようにすることが重要です。また、このような状況では、不快感の原因となる可能性が高いため、vergence の競合。 コンテンツは、ユーザーからの85cm より近くのやり取りの必要性を最小限に抑えるように設計する必要がありますが、85 cm より近い方法でコンテンツをレンダリングする必要がある場合は、開発者にとっては、ユーザーやホログラムの深さが 25% を超えることがないシナリオを設計することをお勧めします。彼の時間。

**ベストプラクティス**ホログラムを2m に配置できず、収束と設備の間の競合を回避できない場合、ホログラムの配置に最適なゾーンは 1.25 m と5分の間になります。 どのような場合でも、デザイナーは、ユーザーが 1 + m を操作できるようにコンテンツを構成する必要があります (たとえば、コンテンツサイズと既定の配置パラメーターを調整します)。

## <a name="stabilization-plane"></a>安定化平面
> [!NOTE]
> デスクトップのイマーシブヘッドセットの場合、通常は安定化平面を設定します。これは、アプリの深度バッファーをシステムに提供してピクセル単位の深さベースの再プロジェクションを有効にするよりも、ビジュアルの品質が低下するためです。 HoloLens で実行しない限り、通常は安定化平面の設定を避ける必要があります。

HoloLens は、高度なハードウェア支援型の holographic 安定化手法を実行します。 これは主に自動化されており、シーンがアニメーション化され、ユーザーが頭を動かしたときに、視点 (CameraPose) の動きと変化によって実行する必要があります。 この安定化を最大化するために、安定化平面と呼ばれる1つの平面を選択します。 シーン内のすべてのホログラムは安定化を受けますが、安定化平面のホログラムは、最大ハードウェア安定化を受けます。

![3D オブジェクトの安定化平面](images/stab-plane-500px.jpg)

デバイスは自動的にこの平面を選択しようとしますが、アプリケーションはシーンのフォーカスポイントを選択することでこのプロセスを支援できます。 HoloLens で実行されている Unity アプリでは、シーンに基づいて最適なポイントを選択し、それを[SetFocusPoint ()](focus-point-in-unity.md)に渡す必要があります。 DirectX でフォーカスポイントを設定する例は、既定のスピンキューブテンプレートに含まれています。

デスクトップ PC に接続されているイマーシブヘッドセット上で Unity アプリを実行すると、Unity は深度バッファーを Windows に送信して、ピクセルごとの再プロジェクションを有効にします。通常、アプリによる明示的な作業を行わなくても、画質が向上します。 フォーカスポイントを指定すると、それによってピクセル単位の再プロジェクションがオーバーライドされるため、アプリが HoloLens で実行されている場合にのみ、この操作を行う必要があります。




```cs
// SetFocusPoint informs the system about a specific point in your scene to
// prioritize for image stabilization. The focus point is set independently
// for each holographic camera.
// You should set the focus point near the content that the user is looking at.
// In this example, we put the focus point at the center of the sample hologram,
// since that is the only hologram available for the user to focus on.
// You can also set the relative velocity and facing of that content; the sample
// hologram is at a fixed point so we only need to indicate its position.
renderingParameters.SetFocusPoint(
    currentCoordinateSystem,
    spinningCubeRenderer.Position
    );
```

フォーカスポイントの配置は、ホログラムが見ていることに大きく依存します。 アプリには、参照用の宝石ベクトルがあり、アプリデザイナーはユーザーに対して確認するコンテンツを認識します。

ホログラムを安定させるために開発者が実行できる最も重要な1つの点は、60 FPS でレンダリングすることです。 60 FPS を下回ると、安定化平面の最適化に関係なく、ホログラムの安定性が劇的に減少します。

**ベストプラクティス**安定化面を設定するための汎用的な方法はなく、アプリに固有のものであるため、主な推奨事項は、実際のシナリオに最適な動作を確認することです。 ただし、この平面上のすべてのコンテンツが完全に安定しているため、できるだけ多くのコンテンツを安定化平面に揃えるようにしてください。

以下に例を示します。
* 平面コンテンツ (アプリの読み取り、ビデオ再生アプリ) のみがある場合は、安定化平面をコンテンツを持つ平面に揃えます。
* ワールドロックされた3つの小さな球体がある場合は、ユーザーのビューに現在存在するすべての球体の中心を "切り取り" にします。
* シーンの深さが大きく異なる場合は、さらにオブジェクトを優先します。
* ユーザーが見ているホログラムと一致するように、すべてのフレームの安定化ポイントを調整してください。

**回避すべき**こと安定化平面は安定したホログラムを実現するための優れたツールですが、誤用されると、イメージが不安定になる可能性があります。
* ユーザーの背後にある安定化面を使用したり、ユーザーのビューに存在しなくなったオブジェクトにアタッチしたりすることができるため、"火災して忘れる" ことは避けてください。 安定化平面の法線が反対のカメラに設定されていることを確認します (例:-camera. forward)
* 安定した平面を極端に逆方向に変更しない
* 安定化平面を固定距離/向きに設定したままにしない
* 安定化平面をユーザーに対して切り取ることを許可しない
* HoloLens ではなくデスクトップ PC で実行する場合は、フォーカスポイントを設定しないでください。代わりに、ピクセルごとの深度ベースの再プロジェクションに依存します。

## <a name="color-separation"></a>色の分離 

HoloLens ディスプレイの性質により、"カラー分離" と呼ばれるアーティファクトが認識されることがあります。 これは、個々の基本色 (赤、緑、および青) に分割するイメージとしてマニフェストを持ちます。 このアイテムは、赤、緑、青が非常に多いため、白いオブジェクトを表示するときに特に表示できます。 これは、ユーザーが holographic フレーム間を移動しているホログラムを高速で視覚的に追跡するときに、最も顕著になります。 アーティファクトでマニフェストを実行するもう1つの方法は、オブジェクトのワープ/変形です。 オブジェクトにハイコントラストやピュア色 (赤、緑、青) がある場合、色の分離は、オブジェクトのさまざまな部分のワープとして認識されます。

**ヘッドロックされた白いラウンドカーソルの色の分離の例は、ユーザーが頭を左右に回転させると、次のようになります。**

![ヘッドロックされた白いラウンドカーソルの色の分離の例は、ユーザーが頭を左右に回転させた場合のようになります。](images/colorseparationofroundwhitecursor-300px.png)

色の分離を完全に回避することは困難ですが、それを軽減するために使用できる手法がいくつかあります。

**色の分離は次のようになります。**
* [カーソル](cursors.md)などのヘッドロックオブジェクトを含む、すばやく移動するオブジェクト。
* [安定化平面](hologram-stability.md#stabilization-plane)からかなり遠く離れたオブジェクト。

**色の分離の効果を弱めるには、次のようにします。**
* オブジェクトをユーザーの宝石にラグさせる。 これは、慣性があるかのように表示され、宝石の "スプリング" にアタッチされます。 これによりカーソルの速度が低下し (分離距離が短縮されます)、ユーザーの可能性のあるポイントの背後に配置されます。 ユーザーが宝石の移動を止めたときにすぐに追いつくことができれば、自然な感じになります。
* ホログラムを移動する場合は、ユーザーが目を見ていくことが予想される場合、移動速度を5°/秒未満にしてください。
* カーソルには、 *geometry*ではなく*light*を使用します。 宝石に接続された仮想照明のソースは、対話型ポインターとして認識されますが、色の分離は行われません。
* ユーザーが行っているホログラムと一致するように安定化平面を調整します。
* オブジェクトを赤、緑、または青にします。
* ぼやけたバージョンのコンテンツに切り替えます。 たとえば、丸い白のカーソルは、モーションの方向を少しぼやけた線に変更できます。

前と同様に、60 FPS でのレンダリングと安定化平面の設定は、ホログラムの安定性を確保するための最も重要な手法です。 色の区別が目立つ場合は、まず、フレームレートが期待どおりであることを確認します。

## <a name="see-also"></a>関連項目
* [Mixed Reality のパフォーマンスについて](understanding-performance-for-mixed-reality.md)
* [色、ライト、マテリアル](color,-light-and-materials.md)
* [本能的な操作](interaction-fundamentals.md)