---
title: 複合現実のパフォーマンスを理解
description: 高度なトピックと詳細情報 Windows Mixed Reality アプリのパフォーマンスの最適化に
author: Troy-Ferrell
ms.author: trferrel
ms.date: 3/26/2019
ms.topic: article
keywords: Windows が実際には、Mixed Reality、仮想現実、VR、MR、パフォーマンス、最適化、CPU、GPU の混在
ms.openlocfilehash: ce59f9023c21dc7c981a2bb97d9fbd0c57622dbf
ms.sourcegitcommit: 384b0087899cd835a3a965f75c6f6c607c9edd1b
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/12/2019
ms.locfileid: "59603290"
---
# <a name="understanding-performance-for-mixed-reality"></a>複合現実のパフォーマンスを理解

この記事では、Mixed Reality アプリのパフォーマンスの有意性を合理化するにです。  最適なフレーム レートでは、アプリケーションが実行されない場合、ユーザー エクスペリエンスを大幅に低下することができます。 ホログラムが不安定に表示され、環境のヘッドの追跡が、ユーザーのエクスペリエンスの低下につながるが不正確になります。 実際には、パフォーマンスは Mixed Reality 開発しないを安定化、サイクルのタスクの最後のファースト クラスの機能として見なす必要があります。

審査のため、各ターゲット プラットフォームのパフォーマンスの高いフレーム レートの値は、以下に示します。

| プラットフォーム | ターゲットのフレーム レート |
|----------|-------------------|
| [HoloLens](hololens-hardware-details.md) | 60 FPS |
| [Pc を Windows Mixed Reality Ultra](immersive-headset-hardware-details.md) | 90 FPS |
| [Windows Pc の現実の混在](immersive-headset-hardware-details.md) | 60 FPS |

以下のフレームワークでは、ベスト プラクティスの一般的な概要とヒットに向かってによるターゲット フレーム レート。 説明をさらに詳しくは、読み取りを検討してください、 [Unity アーティクルのパフォーマンスに関する推奨事項](performance-recommendations-for-unity.md)します。 具体的には、この関連の記事では、Unity Windows Mixed Reality アプリだけでなく、Unity 環境でパフォーマンスを向上させるための手順でフレーム レートを測定する方法について説明します。

## <a name="understanding-performance-bottlenecks"></a>パフォーマンスのボトルネックを理解します。

アプリにつながらないのフレーム レートがある場合、最初の手順を分析し、アプリケーションがコンピューターに負荷が理解です。 2 つの主なプロセッサがある、シーンを表示するために作業を担当します。 CPU と GPU します。 これら 2 つのコンポーネントのそれぞれは、さまざまな操作と、Mixed Reality アプリのステージを処理します。 ボトルネックが生じる 3 つのキーの場所があります。 

1. **アプリ スレッドで CPU** -このスレッドは、アプリのロジックを担当します。 これは、入力、アニメーション、物理学、およびその他のアプリのロジックと状態の処理が含まれています。
2. **レンダリング スレッドの GPU に CPU** -このスレッドは、GPU の描画呼び出しの送信を担当します。 アプリは、キューブまたはモデルなどのオブジェクトをレンダリングする場合、このスレッドは、GPU レンダリング用に最適化されたアーキテクチャには、これらの操作を実行するには要求を送信します。
3. **GPU** - 
   このプロセッサは、3 D のデータ (モデル、テクスチャなど) をピクセルに変換し、最終的には、デバイスの画面に送信する 2D イメージを生成するアプリケーションのグラフィックス パイプラインを最もよく処理できます。

![フレームの有効期間](images/lifetime-of-a-frame.png)

一般に、HoloLens のアプリケーションは、境界付けられた GPU になります。 ただし、すべてのアプリケーションでこれは当てはまりませんされ、そのためのツールと以下の手法を使用して、特定のアプリのグラウンド トルス - を取得お勧めします。

## <a name="how-to-analyze-your-application"></a>アプリケーションを分析する方法

開発者は、複合現実アプリケーションのパフォーマンス プロファイルを理解できるようにする多くのツールがあります。 あるボトルネックとどのようにデバッグすること自体が明白は両方のターゲットにできます。

これは、アプリケーションの深いのプロファイル情報を取得する人気があり、強力なツールの一覧です。
- [Intel グラフィックス パフォーマンス アナライザー](https://software.intel.com/gpa)
- [Visual Studio のグラフィックス デバッガー](https://docs.microsoft.com/visualstudio/debugger/graphics/visual-studio-graphics-diagnostics?view=vs-2017)
- [Unity Profiler](https://docs.unity3d.com/Manual/Profiler.html)
- [Unity デバッガーのフレーム](https://docs.unity3d.com/Manual/FrameDebugger.html)

### <a name="how-to-profile-in-any-environment"></a>任意の環境でプロファイルする方法

GPU 境界付けられた可能性が高い場合をすばやく確認する簡単なテストまたは CPU、アプリケーションで制約があります。 レンダー ターゲットの出力の解像度を小さくした場合は、小さいピクセルを計算するがあり、したがって、処理量が少ない、GPU が実行するイメージをレンダリングします。 ビューポート (動的解決のスケーリング) スケーリングがより小さい、イメージのレンダリングが実際に、レンダー ターゲットし、出力デバイスを表示できます。 デバイスがアップ、サンプリング、最終イメージを表示するピクセルの小さいセットからします。

表示解像度を減らす場合: の後
1) アプリケーションのフレーム レート**増加**、可能性がありますし、 **GPU の制限**
1) アプリケーションのフレーム レート**unchanged**、可能性がありますし、 **CPU の制限**

>[!NOTE]
>Unity は、アプリケーションを介して実行時のレンダー ターゲット解像度を簡単に変更する機能、 *[XRSettings.renderViewportScale](https://docs.unity3d.com/ScriptReference/XR.XRSettings-renderViewportScale.html)* プロパティ。 デバイスに表示される最終的なイメージでは、固定の解像度を持ちます。 プラットフォームには、低解像度ディスプレイでのレンダリングのより高い解像度のイメージを構築する出力がサンプルします。 
>
>```CS
>UnityEngine.XR.XRSettings.renderScale = 0.7f;
>```

## <a name="how-to-improve-your-application"></a>アプリケーションを向上する方法

### <a name="cpu-performance-recommendations"></a>CPU のパフォーマンスに関する推奨事項

一般に、CPU 上の複合現実のアプリケーションでのほとんどの作業は、シーンの「シミュレーション」を実行して、広範な一意のアプリケーション ロジックを処理する必要があります。 したがって、次の領域では、最適化の対象は通常です。

- アニメーション
- 物理学を簡略化します。
- メモリの割り当て
- 複雑なアルゴリズム (つまり、 インバース キネマティクス、パス検索)

### <a name="gpu-performance-recommendations"></a>GPU のパフォーマンスに関する推奨事項

#### <a name="understanding-bandwidth-vs-fill-rate"></a>Understanding 帯域幅の vs のフィル レート
GPU 上のフレームをレンダリングするときに、アプリケーションは一般にメモリ帯域幅や塗りつぶしのレートで範囲指定されたいずれかです。

- **メモリ帯域幅**読み取りの割合は、GPU がメモリから実行できる書き込み
    - 帯域幅の制限を特定するには、テクスチャの品質が低下し、フレーム レートの向上を確認します。
    - Unity では、これを行う変更**テクスチャ品質**で**編集** > **プロジェクト設定** >   **[品質設定](https://docs.unity3d.com/Manual/class-QualitySettings.html)** します。
- **フィル レート**GPU によって 1 秒あたりに描画できるレンダリングされるピクセルのスループットを参照します。
    - 塗りつぶしのレート制限を識別するためには、ディスプレイの解像度を低くし、フレーム レートの向上を確認します。 
    - この、Unity を使用して行うことができます、 *[XRSettings.renderViewportScale](https://docs.unity3d.com/ScriptReference/XR.XRSettings-renderViewportScale.html)* プロパティ

一般には、最適化するか、メモリ帯域幅
1) テクスチャの解像度を減らす
2) (つまり、小さいテクスチャを利用します。 法線、反射など)

フィル レートは、レンダリングされたピクセルの最終的なを計算する必要のある操作の数を減らすことで主にフォーカスしています。 この例はよく削減に分類されます。
1) レンダー/処理するオブジェクトの数
2) シェーダーあたりの操作の数
3) 最終的な結果 (ジオメトリ シェーダー、処理後の効果など) に GPU ステージの数
4) (つまり、表示するためにピクセルの数 画面の解像度)

#### <a name="reduce-poly-count"></a>ポリゴンの数を削減します。
以上の多角形は、GPU のより多くの操作の結果をカウントし、シーン内の多角形の数を減らすことによりそのジオメトリを表示するために時間の量が減少します。 ジオメトリが高価なできますを網掛けにも関連するその他の要素がありますが、多角形は、基本メトリックを決定する方法に高価なシーンをレンダリングします。

#### <a name="limit-overdraw"></a>制限を範囲します。

高オーバー ドローの複数のオブジェクトがレンダリングされますが、別、一般に近い、他のオブジェクトによって隠されていると画面に出力されていないときに発生します。 複数のルームとその背後にあるジオメトリの壁を見ることを想像してください。 処理されるすべてのジオメトリのレンダリングが、不透明な壁のみが本当にその他のすべてのコンテンツの表示を邪魔になりますが描画される必要があります。 これにより、現在のビューの不要な無駄な操作。

#### <a name="shaders"></a>シェーダー

シェーダーは、GPU 上で実行され、通常、レンダリングの 2 つの重要な手順を決定する小さなプログラムです。
1) 画面と画面領域 (つまりにいるどのオブジェクトの頂点を描画します。 頂点シェーダー)
    - すべて GameObject の頂点ごと、頂点シェーダーが一般に実行されます。
2) 何に (つまり、ピクセルの色 ピクセル シェーダー)
    - ピクセル シェーダーが存在するデバイスに表示されるテクスチャ、ピクセルあたりに実行されます。

通常シェーダーは、多くの変換や照明の計算を実行します。 複雑な照明モデル、シャドウ、およびその他の操作は、すばらしい結果を生成できますが、それらも付属して価格。 計算シェーダーの操作の数を減らすと、フレームごとの GPU で実行するために必要な全体的な作業を大幅に削減できます。

##### <a name="shader-coding-recommendations"></a>シェーダーのコーディングの推奨事項

- 可能であれば、bilinear フィルタ リングを使用します。
- MAD の組み込みを同時に、multiply メソッドと追加を実行するために使用する式を再配置します。
- CPU の可能な限りを事前計算し、材料に定数として渡す
- **ピクセル シェーダーから頂点シェーダーへの移動操作を優先します。**
    - 一般に、頂点数 << (つまり、ピクセルの数 720 p 921,600 ピクセル、1080 p = = 2,073,600 ピクセルなどを = =)

#### <a name="remove-gpu-stages"></a>GPU のステージを削除します。
処理後の効果、非常に高くなるし、一般に、アプリケーションのフィル レートを妨げることができます。 これには、MSAA などのアンチエイリアシング手法も含まれています。 HoloLens で、これらの手法を完全に回避することをお勧めします。 さらに、geometry、ハル、計算シェーダーなどの追加のシェーダー ステージは、可能であれば避ける必要があります。

## <a name="memory-recommendations"></a>メモリの推奨事項
過剰なメモリの割り当てと割り当て解除の操作、holographic アプリケーションを一貫性のないパフォーマンス、固定されたフレーム、およびその他の好ましくない動作に影響を受けることができます。 これは、方法は、メモリ管理は、ガベージ コレクターによって制御されるため、Unity で開発するときは、メモリに関する考慮事項を理解するのには特に重要です。

#### <a name="object-pooling"></a>オブジェクト プール

オブジェクト プールは、オブジェクトの割り当て解除 (&)、継続的な割り当てのコストを削減する、一般的な手法です。 これは、同一のオブジェクトの大きなプールを割り当てると、常に生成し、時間の経過と共にオブジェクトを破棄するのではなく、このプールから再アクティブでない、利用可能なインスタンスを使用して実行します。 オブジェクト プールは、アプリの中に変数の有効期間を持つ再利用可能なコンポーネントに適しています。

## <a name="see-also"></a>関連項目
- [Unity のパフォーマンスに関する推奨事項](performance-recommendations-for-unity.md)
- [Unity の推奨設定](recommended-settings-for-unity.md)
