---
title: Mixed Reality のパフォーマンスについて
description: Windows Mixed Reality アプリのパフォーマンスの最適化に関する高度なトピックと詳細
author: Troy-Ferrell
ms.author: trferrel
ms.date: 3/26/2019
ms.topic: article
keywords: Windows Mixed Reality、Mixed Reality、Virtual Reality、VR、MR、パフォーマンス、最適化、CPU、GPU
ms.openlocfilehash: ce59f9023c21dc7c981a2bb97d9fbd0c57622dbf
ms.sourcegitcommit: 915d3cc63a5571ba22ac4608589f3eca8da1bc81
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/24/2019
ms.locfileid: "63548839"
---
# <a name="understanding-performance-for-mixed-reality"></a><span data-ttu-id="6fc17-104">Mixed reality のパフォーマンスについて</span><span class="sxs-lookup"><span data-stu-id="6fc17-104">Understanding performance for mixed reality</span></span>

<span data-ttu-id="6fc17-105">この記事では、Mixed Reality アプリのパフォーマンスの合理化の概要について説明します。</span><span class="sxs-lookup"><span data-stu-id="6fc17-105">This article is an introduction into rationalizing the significance of performance for your Mixed Reality app.</span></span>  <span data-ttu-id="6fc17-106">アプリケーションが最適なフレームレートで実行されない場合、ユーザーエクスペリエンスが大幅に低下する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="6fc17-106">User experience can be greatly degraded if your application does not run at optimal frame rate.</span></span> <span data-ttu-id="6fc17-107">ホログラムが不安定になり、環境のヘッドトラッキングが不適切になり、ユーザーのエクスペリエンスが悪くなります。</span><span class="sxs-lookup"><span data-stu-id="6fc17-107">Holograms will appear unstable and head tracking of the environment will be inaccurate leading to an poor experience for the user.</span></span> <span data-ttu-id="6fc17-108">実際には、パフォーマンスは、安定したサイクル終了タスクではなく、混合現実の開発のためのファーストクラスの機能と見なす必要があります。</span><span class="sxs-lookup"><span data-stu-id="6fc17-108">Indeed, performance must be considered as a first class feature for Mixed Reality development and not a stabilization, end of cycle task.</span></span>

<span data-ttu-id="6fc17-109">確認のために、各ターゲットプラットフォームのパフォーマンスの高いフレームレート値を以下に示します。</span><span class="sxs-lookup"><span data-stu-id="6fc17-109">For review, the performant framerate values for each target platform are listed below.</span></span>

| <span data-ttu-id="6fc17-110">プラットフォーム</span><span class="sxs-lookup"><span data-stu-id="6fc17-110">Platform</span></span> | <span data-ttu-id="6fc17-111">ターゲットフレームレート</span><span class="sxs-lookup"><span data-stu-id="6fc17-111">Target Frame Rate</span></span> |
|----------|-------------------|
| [<span data-ttu-id="6fc17-112">HoloLens</span><span class="sxs-lookup"><span data-stu-id="6fc17-112">HoloLens</span></span>](hololens-hardware-details.md) | <span data-ttu-id="6fc17-113">60 FPS</span><span class="sxs-lookup"><span data-stu-id="6fc17-113">60 FPS</span></span> |
| [<span data-ttu-id="6fc17-114">Windows Mixed Reality ウルトラ Pc</span><span class="sxs-lookup"><span data-stu-id="6fc17-114">Windows Mixed Reality Ultra PCs</span></span>](immersive-headset-hardware-details.md) | <span data-ttu-id="6fc17-115">90 FPS</span><span class="sxs-lookup"><span data-stu-id="6fc17-115">90 FPS</span></span> |
| [<span data-ttu-id="6fc17-116">Windows Mixed Reality Pc</span><span class="sxs-lookup"><span data-stu-id="6fc17-116">Windows Mixed Reality PCs</span></span>](immersive-headset-hardware-details.md) | <span data-ttu-id="6fc17-117">60 FPS</span><span class="sxs-lookup"><span data-stu-id="6fc17-117">60 FPS</span></span> |

<span data-ttu-id="6fc17-118">以下のフレームワークは、ベストプラクティスとターゲットフレームレートの異なればに対する一般的な概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="6fc17-118">The framework below gives a general outline for best practices and understandings towards hitting target frame rates.</span></span> <span data-ttu-id="6fc17-119">詳細について詳しくは、 [「Unity のパフォーマンスに関する推奨事項](performance-recommendations-for-unity.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="6fc17-119">To dive further into details, consider reading the [performance recommendations for Unity article](performance-recommendations-for-unity.md).</span></span> <span data-ttu-id="6fc17-120">特に、この関連記事では、Unity Windows Mixed Reality アプリでフレームレートを測定する方法と、Unity 環境でパフォーマンスを向上させるための手順について説明します。</span><span class="sxs-lookup"><span data-stu-id="6fc17-120">In particular, this related article will discuss how to measure framerate in your Unity Windows Mixed Reality app as well as steps to take in the Unity environment to improve performance.</span></span>

## <a name="understanding-performance-bottlenecks"></a><span data-ttu-id="6fc17-121">パフォーマンスのボトルネックについて</span><span class="sxs-lookup"><span data-stu-id="6fc17-121">Understanding performance bottlenecks</span></span>

<span data-ttu-id="6fc17-122">アプリの不採算事業フレームレートがある場合、最初の手順は、アプリケーションが計算を集中的に使用している場所を分析して理解することです。</span><span class="sxs-lookup"><span data-stu-id="6fc17-122">If your app has an underperforming framerate, the first step is to analyze and understand where your application is computationally intensive.</span></span> <span data-ttu-id="6fc17-123">シーンをレンダリングする作業には、CPU と GPU の2つの主要なプロセッサがあります。</span><span class="sxs-lookup"><span data-stu-id="6fc17-123">There are two primary processors responsible for the work to render your scene: the CPU and the GPU.</span></span> <span data-ttu-id="6fc17-124">これらの2つのコンポーネントは、混在する現実のアプリのさまざまな操作とステージを処理します。</span><span class="sxs-lookup"><span data-stu-id="6fc17-124">Each of these two components handle different operations and stages of your Mixed Reality app.</span></span> <span data-ttu-id="6fc17-125">ボトルネックが発生する可能性がある主な場所は3つあります。</span><span class="sxs-lookup"><span data-stu-id="6fc17-125">There are three key places where bottlenecks may occur.</span></span> 

1. <span data-ttu-id="6fc17-126">**アプリスレッド-CPU** -このスレッドは、アプリロジックを担います。</span><span class="sxs-lookup"><span data-stu-id="6fc17-126">**App Thread - CPU** - This thread is responsible for your app logic.</span></span> <span data-ttu-id="6fc17-127">これには、入力、アニメーション、物理、およびその他のアプリのロジック/状態の処理が含まれます。</span><span class="sxs-lookup"><span data-stu-id="6fc17-127">This includes processing input, animations, physics, and other app logic/state</span></span>
2. <span data-ttu-id="6fc17-128">**スレッドを gpu にレンダリングする**-このスレッドは、gpu への描画呼び出しを送信します。</span><span class="sxs-lookup"><span data-stu-id="6fc17-128">**Render Thread - CPU to GPU** - This thread is responsible for submitting your draw calls to the GPU.</span></span> <span data-ttu-id="6fc17-129">アプリでキューブやモデルなどのオブジェクトをレンダリングする場合、このスレッドは GPU に要求を送信します。 GPU には、レンダリングのために最適化されたアーキテクチャがあり、これらの操作を実行します。</span><span class="sxs-lookup"><span data-stu-id="6fc17-129">When your app wants to render an object such as a cube or model, this thread sends a request to the GPU, which has an architecture optimized for rendering, to perform these operations.</span></span>
3. <span data-ttu-id="6fc17-130">**GPU**- 
   このプロセッサは、一般に、3d データ (モデル、テクスチャなど) をピクセルに変換し、最終的にデバイスの画面に送信する2d イメージを生成するために、アプリケーションのグラフィックスパイプラインを処理します。</span><span class="sxs-lookup"><span data-stu-id="6fc17-130">**GPU** - 
 This processor most commonly handles the graphics pipeline of your application to transform 3D data (models, textures, etc) into pixels and ultimately produce a 2D image to submit to your device's screen.</span></span>

![フレームの有効期間](images/lifetime-of-a-frame.png)

<span data-ttu-id="6fc17-132">一般に、HoloLens アプリケーションは GPU で制限されます。</span><span class="sxs-lookup"><span data-stu-id="6fc17-132">Generally, HoloLens applications will be GPU bounded.</span></span> <span data-ttu-id="6fc17-133">ただし、この方法はすべてのアプリケーションに当てはまるわけではありません。そのため、以下のツール & の手法を使用して、特定のアプリの基本を理解することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="6fc17-133">However, this does not hold true in every application and thus it is recommended to use the tools & techniques below to get to ground-truth for your particular app.</span></span>

## <a name="how-to-analyze-your-application"></a><span data-ttu-id="6fc17-134">アプリケーションを分析する方法</span><span class="sxs-lookup"><span data-stu-id="6fc17-134">How to analyze your application</span></span>

<span data-ttu-id="6fc17-135">開発者が混合現実アプリケーションのパフォーマンスプロファイルを理解できるツールは多数あります。</span><span class="sxs-lookup"><span data-stu-id="6fc17-135">There are many tools that allow you as a developer to understand the performance profile of your Mixed Reality application.</span></span> <span data-ttu-id="6fc17-136">これらを使用すると、ボトルネックがある場所と、それらをデバッグするために自身を manifesting する方法の両方をターゲットにすることができます。</span><span class="sxs-lookup"><span data-stu-id="6fc17-136">These will enable you to both target where you have bottlenecks and how they are manifesting themselves to debug them.</span></span>

<span data-ttu-id="6fc17-137">これは、アプリケーションの詳細なプロファイル情報を取得するための一般的で強力なツールの一覧です。</span><span class="sxs-lookup"><span data-stu-id="6fc17-137">This is a list of popular and powerful tools to gain deep profiling information for your application.</span></span>
- [<span data-ttu-id="6fc17-138">Intel グラフィックスパフォーマンスアナライザー</span><span class="sxs-lookup"><span data-stu-id="6fc17-138">Intel Graphics Performance Analyzers</span></span>](https://software.intel.com/gpa)
- [<span data-ttu-id="6fc17-139">Visual Studio のグラフィックスデバッガー</span><span class="sxs-lookup"><span data-stu-id="6fc17-139">Visual Studio Graphics Debuggers</span></span>](https://docs.microsoft.com/visualstudio/debugger/graphics/visual-studio-graphics-diagnostics?view=vs-2017)
- [<span data-ttu-id="6fc17-140">Unity Profiler</span><span class="sxs-lookup"><span data-stu-id="6fc17-140">Unity Profiler</span></span>](https://docs.unity3d.com/Manual/Profiler.html)
- [<span data-ttu-id="6fc17-141">Unity フレームデバッガー</span><span class="sxs-lookup"><span data-stu-id="6fc17-141">Unity Frame Debugger</span></span>](https://docs.unity3d.com/Manual/FrameDebugger.html)

### <a name="how-to-profile-in-any-environment"></a><span data-ttu-id="6fc17-142">任意の環境でプロファイリングする方法</span><span class="sxs-lookup"><span data-stu-id="6fc17-142">How to profile in any environment</span></span>

<span data-ttu-id="6fc17-143">アプリケーションで GPU が制限されているか、CPU が制限されている可能性があるかどうかをすばやく判断するための簡単なテストがあります。</span><span class="sxs-lookup"><span data-stu-id="6fc17-143">There is a simple test to quickly determine if you are likely GPU bounded or CPU bounded in your application.</span></span> <span data-ttu-id="6fc17-144">レンダーターゲットの出力の解像度を下げると、計算するピクセル数が少なくなるため、イメージをレンダリングするために GPU で実行する必要がある作業が少なくなります。</span><span class="sxs-lookup"><span data-stu-id="6fc17-144">If you decrease the resolution of the render target output, there are less pixels to calculate and thus, less work the GPU needs to perform to render an image.</span></span> <span data-ttu-id="6fc17-145">ビューポートのスケーリング (動的な解決のスケーリング) は、イメージを小さいレンダーターゲットにレンダリングする場合に、出力デバイスで表示できるようにするための方法です。</span><span class="sxs-lookup"><span data-stu-id="6fc17-145">Viewport scaling (dynamic resolution scaling) is the practice of rendering your image to a smaller render target then your output device can display.</span></span> <span data-ttu-id="6fc17-146">デバイスは、小さいピクセルセットから、最終的なイメージを表示するためにアップサンプリングされます。</span><span class="sxs-lookup"><span data-stu-id="6fc17-146">The device will up-sample from the smaller set of pixels to display your final image.</span></span>

<span data-ttu-id="6fc17-147">レンダリングの解像度を下げると、次のようになります。</span><span class="sxs-lookup"><span data-stu-id="6fc17-147">After decreasing rendering resolution, if:</span></span>
1) <span data-ttu-id="6fc17-148">アプリケーションのフレームレートが**増加**し、 **GPU が制限**されている可能性があります。</span><span class="sxs-lookup"><span data-stu-id="6fc17-148">Application framerate **increases**, then you are likely **GPU Bounded**</span></span>
1) <span data-ttu-id="6fc17-149">アプリケーションのフレームレートが**変更**されていないため、 **CPU が制限**される可能性があります</span><span class="sxs-lookup"><span data-stu-id="6fc17-149">Application framerate **unchanged**, then you are likely **CPU Bounded**</span></span>

>[!NOTE]
><span data-ttu-id="6fc17-150">Unity では、 *[XRSettings](https://docs.unity3d.com/ScriptReference/XR.XRSettings-renderViewportScale.html)* プロパティを使用して、実行時にアプリケーションのレンダーターゲットの解像度を簡単に変更することができます。</span><span class="sxs-lookup"><span data-stu-id="6fc17-150">Unity provides the ability to easily modify the render target resolution of your application at runtime through the *[XRSettings.renderViewportScale](https://docs.unity3d.com/ScriptReference/XR.XRSettings-renderViewportScale.html)* property.</span></span> <span data-ttu-id="6fc17-151">デバイスに表示される最終的なイメージには、固定された解決策があります。</span><span class="sxs-lookup"><span data-stu-id="6fc17-151">The final image presented on device has a fixed resolution.</span></span> <span data-ttu-id="6fc17-152">このプラットフォームでは、解像度の低い出力をサンプリングして、ディスプレイに表示する解像度の高いイメージを構築します。</span><span class="sxs-lookup"><span data-stu-id="6fc17-152">The platform will sample the lower resolution output to build a higher resolution image for rendering on displays.</span></span> 
>
>```CS
>UnityEngine.XR.XRSettings.renderScale = 0.7f;
>```

## <a name="how-to-improve-your-application"></a><span data-ttu-id="6fc17-153">アプリケーションを改善する方法</span><span class="sxs-lookup"><span data-stu-id="6fc17-153">How to improve your application</span></span>

### <a name="cpu-performance-recommendations"></a><span data-ttu-id="6fc17-154">CPU パフォーマンスに関する推奨事項</span><span class="sxs-lookup"><span data-stu-id="6fc17-154">CPU performance recommendations</span></span>

<span data-ttu-id="6fc17-155">一般に、CPU 上の mixed reality アプリケーションでほとんどの作業を行うには、シーンの "シミュレーション" を実行し、広範な一意のアプリケーションロジックを処理する必要があります。</span><span class="sxs-lookup"><span data-stu-id="6fc17-155">Generally, most work in a mixed reality application on the CPU involves performing the "simulation" of the scene and processing extensive unique application logic.</span></span> <span data-ttu-id="6fc17-156">したがって、通常、次の領域は最適化の対象となります。</span><span class="sxs-lookup"><span data-stu-id="6fc17-156">Thus, the following areas are usually targeted for optimization.</span></span>

- <span data-ttu-id="6fc17-157">アニメーション</span><span class="sxs-lookup"><span data-stu-id="6fc17-157">Animations</span></span>
- <span data-ttu-id="6fc17-158">物理の単純化</span><span class="sxs-lookup"><span data-stu-id="6fc17-158">Simplify Physics</span></span>
- <span data-ttu-id="6fc17-159">メモリの割り当て</span><span class="sxs-lookup"><span data-stu-id="6fc17-159">Memory allocations</span></span>
- <span data-ttu-id="6fc17-160">複雑なアルゴリズム (</span><span class="sxs-lookup"><span data-stu-id="6fc17-160">Complex algorithms (i.e</span></span> <span data-ttu-id="6fc17-161">逆のキネマティック、パスの検索)</span><span class="sxs-lookup"><span data-stu-id="6fc17-161">inverse kinematics, path-finding)</span></span>

### <a name="gpu-performance-recommendations"></a><span data-ttu-id="6fc17-162">GPU のパフォーマンスに関する推奨事項</span><span class="sxs-lookup"><span data-stu-id="6fc17-162">GPU performance recommendations</span></span>

#### <a name="understanding-bandwidth-vs-fill-rate"></a><span data-ttu-id="6fc17-163">帯域幅と塗りつぶしレートを理解する</span><span class="sxs-lookup"><span data-stu-id="6fc17-163">Understanding bandwidth vs fill rate</span></span>
<span data-ttu-id="6fc17-164">GPU でフレームをレンダリングする場合、通常、アプリケーションはメモリ帯域幅またはフィルレートによって制限されます。</span><span class="sxs-lookup"><span data-stu-id="6fc17-164">When rendering a frame on the GPU, an application is generally either bounded by memory bandwidth or fill rate.</span></span>

- <span data-ttu-id="6fc17-165">**メモリ帯域幅**は、GPU がメモリから実行できる読み取りと書き込みの比率です。</span><span class="sxs-lookup"><span data-stu-id="6fc17-165">**Memory bandwidth** is the rate of reads and writes the GPU can perform from memory</span></span>
    - <span data-ttu-id="6fc17-166">帯域幅の制限を特定するには、テクスチャの品質を下げ、フレームレートが向上したかどうかを確認します。</span><span class="sxs-lookup"><span data-stu-id="6fc17-166">To identify bandwidth limitations, reduce texture quality and check if framerate improved.</span></span>
    - <span data-ttu-id="6fc17-167">Unity では、[**プロジェクト設定** > の **[品質設定](https://docs.unity3d.com/Manual/class-QualitySettings.html)** の**編集** > ] で **[テクスチャの品質]** を変更することによってこれを行うことができます。</span><span class="sxs-lookup"><span data-stu-id="6fc17-167">In Unity, this can be done by changing **Texture Quality** in **Edit** > **Project Settings** > **[Quality Settings](https://docs.unity3d.com/Manual/class-QualitySettings.html)**.</span></span>
- <span data-ttu-id="6fc17-168">**Fill rate**は、GPU によって1秒あたりに描画できる描画ピクセルのスループットを表します。</span><span class="sxs-lookup"><span data-stu-id="6fc17-168">**Fill rate** refers to the throughput of rendered pixels that can be drawn per second by the GPU.</span></span>
    - <span data-ttu-id="6fc17-169">フィルレートの制限を特定するには、ディスプレイの解像度を下げ、フレームレートが改善されたかどうかを確認します。</span><span class="sxs-lookup"><span data-stu-id="6fc17-169">To identify fill rate limitations, decrease the display resolution and check if framerate improved.</span></span> 
    - <span data-ttu-id="6fc17-170">Unity では、XRSettings プロパティを使用してこれを行うことができ *[ます。](https://docs.unity3d.com/ScriptReference/XR.XRSettings-renderViewportScale.html)*</span><span class="sxs-lookup"><span data-stu-id="6fc17-170">In Unity, this can be done via the  *[XRSettings.renderViewportScale](https://docs.unity3d.com/ScriptReference/XR.XRSettings-renderViewportScale.html)* property</span></span>

<span data-ttu-id="6fc17-171">通常、メモリ帯域幅には最適化が必要です。</span><span class="sxs-lookup"><span data-stu-id="6fc17-171">Memory bandwidth generally involves optimizations to either</span></span>
1) <span data-ttu-id="6fc17-172">テクスチャ解像度を下げる</span><span class="sxs-lookup"><span data-stu-id="6fc17-172">decrease texture resolutions</span></span>
2) <span data-ttu-id="6fc17-173">使用するテクスチャを減らす (つまり、</span><span class="sxs-lookup"><span data-stu-id="6fc17-173">utilize less textures (i.e</span></span> <span data-ttu-id="6fc17-174">法線、スペキュラなど)</span><span class="sxs-lookup"><span data-stu-id="6fc17-174">normals, specular, etc)</span></span>

<span data-ttu-id="6fc17-175">Fill rate は、描画された最終的なピクセルに対して計算する必要がある操作の数を減らすことに主に焦点を合わせています。</span><span class="sxs-lookup"><span data-stu-id="6fc17-175">Fill rate is primarily focused on reducing the number of operations that need to be computed for a final rendered pixel.</span></span> <span data-ttu-id="6fc17-176">一般的に、この例は減少します。</span><span class="sxs-lookup"><span data-stu-id="6fc17-176">Examples of this commonly fall into reducing</span></span>
1) <span data-ttu-id="6fc17-177">表示/処理するオブジェクトの数</span><span class="sxs-lookup"><span data-stu-id="6fc17-177">number of objects to render/process</span></span>
2) <span data-ttu-id="6fc17-178">シェーダーあたりの操作数</span><span class="sxs-lookup"><span data-stu-id="6fc17-178">number of operations per shader</span></span>
3) <span data-ttu-id="6fc17-179">最終的な結果に対する GPU ステージの数 (ジオメトリシェーダー、処理後の効果など)</span><span class="sxs-lookup"><span data-stu-id="6fc17-179">number of GPU stages to final result (geometry shaders, post-processing effects, etc)</span></span>
4) <span data-ttu-id="6fc17-180">レンダリングするピクセル数 (つまり、</span><span class="sxs-lookup"><span data-stu-id="6fc17-180">number of pixels to render (i.e</span></span> <span data-ttu-id="6fc17-181">表示解像度)</span><span class="sxs-lookup"><span data-stu-id="6fc17-181">display resolution)</span></span>

#### <a name="reduce-poly-count"></a><span data-ttu-id="6fc17-182">Poly 数を減らす</span><span class="sxs-lookup"><span data-stu-id="6fc17-182">Reduce poly count</span></span>
<span data-ttu-id="6fc17-183">多角形の数が多いほど、GPU に対する操作が増加し、シーン内のポリゴンの数が減少するため、そのジオメトリをレンダリングする時間が短縮されます。</span><span class="sxs-lookup"><span data-stu-id="6fc17-183">Higher polygon counts result in more operations for the GPU and reducing the number of polygons in your scene will reduce the amount of time to render that geometry.</span></span> <span data-ttu-id="6fc17-184">それ以外にも、負荷が高くなる可能性があるジオメトリの網掛けに関連する要因がありますが、ポリゴンの数は、シーンのレンダリングにかかるコストを決定する基本メトリックです。</span><span class="sxs-lookup"><span data-stu-id="6fc17-184">There are other factors involved as well in shading the geometry that can still be expensive but polygon count is the base metric to determine how expensive a scene will be to render.</span></span>

#### <a name="limit-overdraw"></a><span data-ttu-id="6fc17-185">オーバードローを制限する</span><span class="sxs-lookup"><span data-stu-id="6fc17-185">Limit overdraw</span></span>

<span data-ttu-id="6fc17-186">大きなオーバードローは、複数のオブジェクトがレンダリングされるときに発生しますが、画面には出力されません。これは、通常より近くにある別の occluding オブジェクトによって隠されているためです。</span><span class="sxs-lookup"><span data-stu-id="6fc17-186">High overdraw occurs when multiple objects are rendered but not outputted to the screen as they are hidden by another, generally closer, occluding object.</span></span> <span data-ttu-id="6fc17-187">複数の部屋とジオメトリの背後にある壁を見てみてください。</span><span class="sxs-lookup"><span data-stu-id="6fc17-187">Imagine looking at a wall that had multiple rooms and geometry behind it.</span></span> <span data-ttu-id="6fc17-188">すべてのジオメトリはレンダリング用に処理されますが、他のすべてのコンテンツのビューを occludes するときは、不透明なウォールだけをレンダリングする必要があります。</span><span class="sxs-lookup"><span data-stu-id="6fc17-188">All of the geometry would be processed for rendering but only the opaque wall really needs to be rendered as it occludes the view of all other content.</span></span> <span data-ttu-id="6fc17-189">その結果、現在のビューでは不要な無駄な操作が発生します。</span><span class="sxs-lookup"><span data-stu-id="6fc17-189">This results in wasteful operations that are not needed for the current view.</span></span>

#### <a name="shaders"></a><span data-ttu-id="6fc17-190">シェーダー</span><span class="sxs-lookup"><span data-stu-id="6fc17-190">Shaders</span></span>

<span data-ttu-id="6fc17-191">シェーダーは、GPU 上で実行される小さなプログラムであり、一般にレンダリングの2つの重要な手順を決定します。</span><span class="sxs-lookup"><span data-stu-id="6fc17-191">Shaders are small programs that run on the GPU and generally determine two important steps in rendering:</span></span>
1) <span data-ttu-id="6fc17-192">画面上に描画するオブジェクトの頂点と、その頂点が画面空間 (</span><span class="sxs-lookup"><span data-stu-id="6fc17-192">which object's vertices should be drawn on the screen and where they are in screen space (i.e</span></span> <span data-ttu-id="6fc17-193">頂点シェーダー)</span><span class="sxs-lookup"><span data-stu-id="6fc17-193">the Vertex shader)</span></span>
    - <span data-ttu-id="6fc17-194">頂点シェーダーは、一般に、各オブジェクトの頂点ごとに実行されます。</span><span class="sxs-lookup"><span data-stu-id="6fc17-194">The Vertex shader is generally executed per vertex for every GameObject</span></span>
2) <span data-ttu-id="6fc17-195">これらのピクセルに色を設定する (つまり、</span><span class="sxs-lookup"><span data-stu-id="6fc17-195">what to color those pixels (i.e</span></span> <span data-ttu-id="6fc17-196">ピクセルシェーダー)</span><span class="sxs-lookup"><span data-stu-id="6fc17-196">the Pixel shader)</span></span>
    - <span data-ttu-id="6fc17-197">ピクセルシェーダーは、デバイスに表示されているテクスチャのピクセルごとに実行されます。</span><span class="sxs-lookup"><span data-stu-id="6fc17-197">The Pixel shader is executed per pixel for the texture being rendered for device present</span></span>

<span data-ttu-id="6fc17-198">通常、シェーダーでは、多くの変換と照明計算が実行されます。</span><span class="sxs-lookup"><span data-stu-id="6fc17-198">Typically shaders perform many transformations and lighting calculations.</span></span> <span data-ttu-id="6fc17-199">複雑な照明モデル、影、およびその他の操作によって、優れた結果が得られる場合もありますが、価格もあります。</span><span class="sxs-lookup"><span data-stu-id="6fc17-199">Although complex lighting models, shadows, and other operations can generate fantastic results, they also come with a price.</span></span> <span data-ttu-id="6fc17-200">シェーダーで計算される操作の数を減らすと、フレームあたりの GPU によって実行される作業全体が大幅に減少します。</span><span class="sxs-lookup"><span data-stu-id="6fc17-200">Reducing the number of operations computed in shaders can greatly reduce the overall work needed to be done by a GPU per frame.</span></span>

##### <a name="shader-coding-recommendations"></a><span data-ttu-id="6fc17-201">シェーダーのコーディングに関する推奨事項</span><span class="sxs-lookup"><span data-stu-id="6fc17-201">Shader coding recommendations</span></span>

- <span data-ttu-id="6fc17-202">可能な限り、バイリニアフィルタリングを使用する</span><span class="sxs-lookup"><span data-stu-id="6fc17-202">Use bilinear filtering whenever possible</span></span>
- <span data-ttu-id="6fc17-203">同時に乗算と加算を行うために、MAD 組み込みを使用するように式を再配置します。</span><span class="sxs-lookup"><span data-stu-id="6fc17-203">Rearrange expressions to use MAD intrinsics in order to do a multiply and an add at the same time</span></span>
- <span data-ttu-id="6fc17-204">CPU で可能な限り Precalculate し、素材に定数として渡します。</span><span class="sxs-lookup"><span data-stu-id="6fc17-204">Precalculate as much as possible on the CPU and pass as constants to the material</span></span>
- <span data-ttu-id="6fc17-205">**ピクセルシェーダーから頂点シェーダーへの移動操作を優先する**</span><span class="sxs-lookup"><span data-stu-id="6fc17-205">**Favor moving operations from the pixel shader to the vertex shader**</span></span>
    - <span data-ttu-id="6fc17-206">一般に、頂点の数 < < ピクセル数 (つまり、</span><span class="sxs-lookup"><span data-stu-id="6fc17-206">Generally the # of vertices << # of pixels (i.e</span></span> <span data-ttu-id="6fc17-207">720p = = 921600 ピクセル、1080p = = 2073600 ピクセルなど)</span><span class="sxs-lookup"><span data-stu-id="6fc17-207">720p == 921,600 pixels, 1080p == 2,073,600 pixels, etc)</span></span>

#### <a name="remove-gpu-stages"></a><span data-ttu-id="6fc17-208">GPU ステージの削除</span><span class="sxs-lookup"><span data-stu-id="6fc17-208">Remove GPU stages</span></span>
<span data-ttu-id="6fc17-209">処理後の影響には非常にコストがかかり、一般にアプリケーションのフィルレートが妨げられる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="6fc17-209">Post-processing effects can be very expensive and generally inhibit the fill rate of your application.</span></span> <span data-ttu-id="6fc17-210">これには、MSAA などのアンチエイリアシング手法も含まれます。</span><span class="sxs-lookup"><span data-stu-id="6fc17-210">This also includes anti-aliasing techniques such as MSAA.</span></span> <span data-ttu-id="6fc17-211">HoloLens では、これらの手法を完全に回避することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="6fc17-211">On HoloLens, it is recommended to avoid these techniques entirely.</span></span> <span data-ttu-id="6fc17-212">さらに、可能な場合は、geometry、ハル、compute シェーダーなどの追加のシェーダーのステージを避ける必要があります。</span><span class="sxs-lookup"><span data-stu-id="6fc17-212">Furthermore, additional shader stages such as geometry, hull, and compute shaders should be avoided when possible.</span></span>

## <a name="memory-recommendations"></a><span data-ttu-id="6fc17-213">メモリに関する推奨事項</span><span class="sxs-lookup"><span data-stu-id="6fc17-213">Memory recommendations</span></span>
<span data-ttu-id="6fc17-214">過剰なメモリ割り当て & 解放操作によって holographic アプリケーションに悪影響を及ぼす可能性があるため、パフォーマンスが低下したり、フレームが固定されたり、その他の有害な動作が発生したりする可能性があります。</span><span class="sxs-lookup"><span data-stu-id="6fc17-214">Excessive memory allocation & deallocation operations can have adverse effects on your holographic application resulting in inconsistent performance, frozen frames, and other detrimental behavior.</span></span> <span data-ttu-id="6fc17-215">メモリ管理はガベージコレクターによって制御されるため、Unity で開発するときは、メモリに関する考慮事項を理解することが特に重要です。</span><span class="sxs-lookup"><span data-stu-id="6fc17-215">It is especially important to understand memory considerations when developing in Unity since memory management is controlled by the garbage collector.</span></span>

#### <a name="object-pooling"></a><span data-ttu-id="6fc17-216">オブジェクトプール</span><span class="sxs-lookup"><span data-stu-id="6fc17-216">Object pooling</span></span>

<span data-ttu-id="6fc17-217">オブジェクトプールは、オブジェクトの割り当て解除 & の継続的な割り当てのコストを削減するための一般的な手法です。</span><span class="sxs-lookup"><span data-stu-id="6fc17-217">Object pooling is a popular technique to reduce the cost of continuous allocations & deallocations of objects.</span></span> <span data-ttu-id="6fc17-218">これを行うには、同一のオブジェクトの大規模なプールを割り当て、時間の経過と共にオブジェクトを絶えず破棄するのではなく、このプールから使用可能な非アクティブなインスタンスを再利用します。</span><span class="sxs-lookup"><span data-stu-id="6fc17-218">This is done by allocating a large pool of identical objects and re-using inactive, available instances from this pool instead of constantly spawning and destroying objects over time.</span></span> <span data-ttu-id="6fc17-219">オブジェクトプールは、アプリの有効期間が可変の再使用可能なコンポーネントに最適です。</span><span class="sxs-lookup"><span data-stu-id="6fc17-219">Object pools are great for re-useable components that have variable lifetime during an app.</span></span>

## <a name="see-also"></a><span data-ttu-id="6fc17-220">関連項目</span><span class="sxs-lookup"><span data-stu-id="6fc17-220">See also</span></span>
- [<span data-ttu-id="6fc17-221">Unity のパフォーマンスに関する推奨事項</span><span class="sxs-lookup"><span data-stu-id="6fc17-221">Performance recommendations for Unity</span></span>](performance-recommendations-for-unity.md)
- [<span data-ttu-id="6fc17-222">Unity で推奨される設定</span><span class="sxs-lookup"><span data-stu-id="6fc17-222">Recommended settings for Unity</span></span>](recommended-settings-for-unity.md)
