---
title: 複合現実のパフォーマンスを理解
description: 高度なトピックと詳細情報 Windows Mixed Reality アプリのパフォーマンスの最適化に
author: Troy-Ferrell
ms.author: trferrel
ms.date: 3/26/2019
ms.topic: article
keywords: Windows が実際には、Mixed Reality、仮想現実、VR、MR、パフォーマンス、最適化、CPU、GPU の混在
ms.openlocfilehash: ce59f9023c21dc7c981a2bb97d9fbd0c57622dbf
ms.sourcegitcommit: 384b0087899cd835a3a965f75c6f6c607c9edd1b
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/12/2019
ms.locfileid: "59603290"
---
# <a name="understanding-performance-for-mixed-reality"></a><span data-ttu-id="41596-104">複合現実のパフォーマンスを理解</span><span class="sxs-lookup"><span data-stu-id="41596-104">Understanding performance for mixed reality</span></span>

<span data-ttu-id="41596-105">この記事では、Mixed Reality アプリのパフォーマンスの有意性を合理化するにです。</span><span class="sxs-lookup"><span data-stu-id="41596-105">This article is an introduction into rationalizing the significance of performance for your Mixed Reality app.</span></span>  <span data-ttu-id="41596-106">最適なフレーム レートでは、アプリケーションが実行されない場合、ユーザー エクスペリエンスを大幅に低下することができます。</span><span class="sxs-lookup"><span data-stu-id="41596-106">User experience can be greatly degraded if your application does not run at optimal frame rate.</span></span> <span data-ttu-id="41596-107">ホログラムが不安定に表示され、環境のヘッドの追跡が、ユーザーのエクスペリエンスの低下につながるが不正確になります。</span><span class="sxs-lookup"><span data-stu-id="41596-107">Holograms will appear unstable and head tracking of the environment will be inaccurate leading to an poor experience for the user.</span></span> <span data-ttu-id="41596-108">実際には、パフォーマンスは Mixed Reality 開発しないを安定化、サイクルのタスクの最後のファースト クラスの機能として見なす必要があります。</span><span class="sxs-lookup"><span data-stu-id="41596-108">Indeed, performance must be considered as a first class feature for Mixed Reality development and not a stabilization, end of cycle task.</span></span>

<span data-ttu-id="41596-109">審査のため、各ターゲット プラットフォームのパフォーマンスの高いフレーム レートの値は、以下に示します。</span><span class="sxs-lookup"><span data-stu-id="41596-109">For review, the performant framerate values for each target platform are listed below.</span></span>

| <span data-ttu-id="41596-110">プラットフォーム</span><span class="sxs-lookup"><span data-stu-id="41596-110">Platform</span></span> | <span data-ttu-id="41596-111">ターゲットのフレーム レート</span><span class="sxs-lookup"><span data-stu-id="41596-111">Target Frame Rate</span></span> |
|----------|-------------------|
| [<span data-ttu-id="41596-112">HoloLens</span><span class="sxs-lookup"><span data-stu-id="41596-112">HoloLens</span></span>](hololens-hardware-details.md) | <span data-ttu-id="41596-113">60 FPS</span><span class="sxs-lookup"><span data-stu-id="41596-113">60 FPS</span></span> |
| [<span data-ttu-id="41596-114">Pc を Windows Mixed Reality Ultra</span><span class="sxs-lookup"><span data-stu-id="41596-114">Windows Mixed Reality Ultra PCs</span></span>](immersive-headset-hardware-details.md) | <span data-ttu-id="41596-115">90 FPS</span><span class="sxs-lookup"><span data-stu-id="41596-115">90 FPS</span></span> |
| [<span data-ttu-id="41596-116">Windows Pc の現実の混在</span><span class="sxs-lookup"><span data-stu-id="41596-116">Windows Mixed Reality PCs</span></span>](immersive-headset-hardware-details.md) | <span data-ttu-id="41596-117">60 FPS</span><span class="sxs-lookup"><span data-stu-id="41596-117">60 FPS</span></span> |

<span data-ttu-id="41596-118">以下のフレームワークでは、ベスト プラクティスの一般的な概要とヒットに向かってによるターゲット フレーム レート。</span><span class="sxs-lookup"><span data-stu-id="41596-118">The framework below gives a general outline for best practices and understandings towards hitting target frame rates.</span></span> <span data-ttu-id="41596-119">説明をさらに詳しくは、読み取りを検討してください、 [Unity アーティクルのパフォーマンスに関する推奨事項](performance-recommendations-for-unity.md)します。</span><span class="sxs-lookup"><span data-stu-id="41596-119">To dive further into details, consider reading the [performance recommendations for Unity article](performance-recommendations-for-unity.md).</span></span> <span data-ttu-id="41596-120">具体的には、この関連の記事では、Unity Windows Mixed Reality アプリだけでなく、Unity 環境でパフォーマンスを向上させるための手順でフレーム レートを測定する方法について説明します。</span><span class="sxs-lookup"><span data-stu-id="41596-120">In particular, this related article will discuss how to measure framerate in your Unity Windows Mixed Reality app as well as steps to take in the Unity environment to improve performance.</span></span>

## <a name="understanding-performance-bottlenecks"></a><span data-ttu-id="41596-121">パフォーマンスのボトルネックを理解します。</span><span class="sxs-lookup"><span data-stu-id="41596-121">Understanding performance bottlenecks</span></span>

<span data-ttu-id="41596-122">アプリにつながらないのフレーム レートがある場合、最初の手順を分析し、アプリケーションがコンピューターに負荷が理解です。</span><span class="sxs-lookup"><span data-stu-id="41596-122">If your app has an underperforming framerate, the first step is to analyze and understand where your application is computationally intensive.</span></span> <span data-ttu-id="41596-123">2 つの主なプロセッサがある、シーンを表示するために作業を担当します。 CPU と GPU します。</span><span class="sxs-lookup"><span data-stu-id="41596-123">There are two primary processors responsible for the work to render your scene: the CPU and the GPU.</span></span> <span data-ttu-id="41596-124">これら 2 つのコンポーネントのそれぞれは、さまざまな操作と、Mixed Reality アプリのステージを処理します。</span><span class="sxs-lookup"><span data-stu-id="41596-124">Each of these two components handle different operations and stages of your Mixed Reality app.</span></span> <span data-ttu-id="41596-125">ボトルネックが生じる 3 つのキーの場所があります。</span><span class="sxs-lookup"><span data-stu-id="41596-125">There are three key places where bottlenecks may occur.</span></span> 

1. <span data-ttu-id="41596-126">**アプリ スレッドで CPU** -このスレッドは、アプリのロジックを担当します。</span><span class="sxs-lookup"><span data-stu-id="41596-126">**App Thread - CPU** - This thread is responsible for your app logic.</span></span> <span data-ttu-id="41596-127">これは、入力、アニメーション、物理学、およびその他のアプリのロジックと状態の処理が含まれています。</span><span class="sxs-lookup"><span data-stu-id="41596-127">This includes processing input, animations, physics, and other app logic/state</span></span>
2. <span data-ttu-id="41596-128">**レンダリング スレッドの GPU に CPU** -このスレッドは、GPU の描画呼び出しの送信を担当します。</span><span class="sxs-lookup"><span data-stu-id="41596-128">**Render Thread - CPU to GPU** - This thread is responsible for submitting your draw calls to the GPU.</span></span> <span data-ttu-id="41596-129">アプリは、キューブまたはモデルなどのオブジェクトをレンダリングする場合、このスレッドは、GPU レンダリング用に最適化されたアーキテクチャには、これらの操作を実行するには要求を送信します。</span><span class="sxs-lookup"><span data-stu-id="41596-129">When your app wants to render an object such as a cube or model, this thread sends a request to the GPU, which has an architecture optimized for rendering, to perform these operations.</span></span>
3. <span data-ttu-id="41596-130">**GPU** - 
   このプロセッサは、3 D のデータ (モデル、テクスチャなど) をピクセルに変換し、最終的には、デバイスの画面に送信する 2D イメージを生成するアプリケーションのグラフィックス パイプラインを最もよく処理できます。</span><span class="sxs-lookup"><span data-stu-id="41596-130">**GPU** - 
 This processor most commonly handles the graphics pipeline of your application to transform 3D data (models, textures, etc) into pixels and ultimately produce a 2D image to submit to your device's screen.</span></span>

![フレームの有効期間](images/lifetime-of-a-frame.png)

<span data-ttu-id="41596-132">一般に、HoloLens のアプリケーションは、境界付けられた GPU になります。</span><span class="sxs-lookup"><span data-stu-id="41596-132">Generally, HoloLens applications will be GPU bounded.</span></span> <span data-ttu-id="41596-133">ただし、すべてのアプリケーションでこれは当てはまりませんされ、そのためのツールと以下の手法を使用して、特定のアプリのグラウンド トルス - を取得お勧めします。</span><span class="sxs-lookup"><span data-stu-id="41596-133">However, this does not hold true in every application and thus it is recommended to use the tools & techniques below to get to ground-truth for your particular app.</span></span>

## <a name="how-to-analyze-your-application"></a><span data-ttu-id="41596-134">アプリケーションを分析する方法</span><span class="sxs-lookup"><span data-stu-id="41596-134">How to analyze your application</span></span>

<span data-ttu-id="41596-135">開発者は、複合現実アプリケーションのパフォーマンス プロファイルを理解できるようにする多くのツールがあります。</span><span class="sxs-lookup"><span data-stu-id="41596-135">There are many tools that allow you as a developer to understand the performance profile of your Mixed Reality application.</span></span> <span data-ttu-id="41596-136">あるボトルネックとどのようにデバッグすること自体が明白は両方のターゲットにできます。</span><span class="sxs-lookup"><span data-stu-id="41596-136">These will enable you to both target where you have bottlenecks and how they are manifesting themselves to debug them.</span></span>

<span data-ttu-id="41596-137">これは、アプリケーションの深いのプロファイル情報を取得する人気があり、強力なツールの一覧です。</span><span class="sxs-lookup"><span data-stu-id="41596-137">This is a list of popular and powerful tools to gain deep profiling information for your application.</span></span>
- [<span data-ttu-id="41596-138">Intel グラフィックス パフォーマンス アナライザー</span><span class="sxs-lookup"><span data-stu-id="41596-138">Intel Graphics Performance Analyzers</span></span>](https://software.intel.com/gpa)
- [<span data-ttu-id="41596-139">Visual Studio のグラフィックス デバッガー</span><span class="sxs-lookup"><span data-stu-id="41596-139">Visual Studio Graphics Debuggers</span></span>](https://docs.microsoft.com/visualstudio/debugger/graphics/visual-studio-graphics-diagnostics?view=vs-2017)
- [<span data-ttu-id="41596-140">Unity Profiler</span><span class="sxs-lookup"><span data-stu-id="41596-140">Unity Profiler</span></span>](https://docs.unity3d.com/Manual/Profiler.html)
- [<span data-ttu-id="41596-141">Unity デバッガーのフレーム</span><span class="sxs-lookup"><span data-stu-id="41596-141">Unity Frame Debugger</span></span>](https://docs.unity3d.com/Manual/FrameDebugger.html)

### <a name="how-to-profile-in-any-environment"></a><span data-ttu-id="41596-142">任意の環境でプロファイルする方法</span><span class="sxs-lookup"><span data-stu-id="41596-142">How to profile in any environment</span></span>

<span data-ttu-id="41596-143">GPU 境界付けられた可能性が高い場合をすばやく確認する簡単なテストまたは CPU、アプリケーションで制約があります。</span><span class="sxs-lookup"><span data-stu-id="41596-143">There is a simple test to quickly determine if you are likely GPU bounded or CPU bounded in your application.</span></span> <span data-ttu-id="41596-144">レンダー ターゲットの出力の解像度を小さくした場合は、小さいピクセルを計算するがあり、したがって、処理量が少ない、GPU が実行するイメージをレンダリングします。</span><span class="sxs-lookup"><span data-stu-id="41596-144">If you decrease the resolution of the render target output, there are less pixels to calculate and thus, less work the GPU needs to perform to render an image.</span></span> <span data-ttu-id="41596-145">ビューポート (動的解決のスケーリング) スケーリングがより小さい、イメージのレンダリングが実際に、レンダー ターゲットし、出力デバイスを表示できます。</span><span class="sxs-lookup"><span data-stu-id="41596-145">Viewport scaling (dynamic resolution scaling) is the practice of rendering your image to a smaller render target then your output device can display.</span></span> <span data-ttu-id="41596-146">デバイスがアップ、サンプリング、最終イメージを表示するピクセルの小さいセットからします。</span><span class="sxs-lookup"><span data-stu-id="41596-146">The device will up-sample from the smaller set of pixels to display your final image.</span></span>

<span data-ttu-id="41596-147">表示解像度を減らす場合: の後</span><span class="sxs-lookup"><span data-stu-id="41596-147">After decreasing rendering resolution, if:</span></span>
1) <span data-ttu-id="41596-148">アプリケーションのフレーム レート**増加**、可能性がありますし、 **GPU の制限**</span><span class="sxs-lookup"><span data-stu-id="41596-148">Application framerate **increases**, then you are likely **GPU Bounded**</span></span>
1) <span data-ttu-id="41596-149">アプリケーションのフレーム レート**unchanged**、可能性がありますし、 **CPU の制限**</span><span class="sxs-lookup"><span data-stu-id="41596-149">Application framerate **unchanged**, then you are likely **CPU Bounded**</span></span>

>[!NOTE]
><span data-ttu-id="41596-150">Unity は、アプリケーションを介して実行時のレンダー ターゲット解像度を簡単に変更する機能、 *[XRSettings.renderViewportScale](https://docs.unity3d.com/ScriptReference/XR.XRSettings-renderViewportScale.html)* プロパティ。</span><span class="sxs-lookup"><span data-stu-id="41596-150">Unity provides the ability to easily modify the render target resolution of your application at runtime through the *[XRSettings.renderViewportScale](https://docs.unity3d.com/ScriptReference/XR.XRSettings-renderViewportScale.html)* property.</span></span> <span data-ttu-id="41596-151">デバイスに表示される最終的なイメージでは、固定の解像度を持ちます。</span><span class="sxs-lookup"><span data-stu-id="41596-151">The final image presented on device has a fixed resolution.</span></span> <span data-ttu-id="41596-152">プラットフォームには、低解像度ディスプレイでのレンダリングのより高い解像度のイメージを構築する出力がサンプルします。</span><span class="sxs-lookup"><span data-stu-id="41596-152">The platform will sample the lower resolution output to build a higher resolution image for rendering on displays.</span></span> 
>
>```CS
>UnityEngine.XR.XRSettings.renderScale = 0.7f;
>```

## <a name="how-to-improve-your-application"></a><span data-ttu-id="41596-153">アプリケーションを向上する方法</span><span class="sxs-lookup"><span data-stu-id="41596-153">How to improve your application</span></span>

### <a name="cpu-performance-recommendations"></a><span data-ttu-id="41596-154">CPU のパフォーマンスに関する推奨事項</span><span class="sxs-lookup"><span data-stu-id="41596-154">CPU performance recommendations</span></span>

<span data-ttu-id="41596-155">一般に、CPU 上の複合現実のアプリケーションでのほとんどの作業は、シーンの「シミュレーション」を実行して、広範な一意のアプリケーション ロジックを処理する必要があります。</span><span class="sxs-lookup"><span data-stu-id="41596-155">Generally, most work in a mixed reality application on the CPU involves performing the "simulation" of the scene and processing extensive unique application logic.</span></span> <span data-ttu-id="41596-156">したがって、次の領域では、最適化の対象は通常です。</span><span class="sxs-lookup"><span data-stu-id="41596-156">Thus, the following areas are usually targeted for optimization.</span></span>

- <span data-ttu-id="41596-157">アニメーション</span><span class="sxs-lookup"><span data-stu-id="41596-157">Animations</span></span>
- <span data-ttu-id="41596-158">物理学を簡略化します。</span><span class="sxs-lookup"><span data-stu-id="41596-158">Simplify Physics</span></span>
- <span data-ttu-id="41596-159">メモリの割り当て</span><span class="sxs-lookup"><span data-stu-id="41596-159">Memory allocations</span></span>
- <span data-ttu-id="41596-160">複雑なアルゴリズム (つまり、</span><span class="sxs-lookup"><span data-stu-id="41596-160">Complex algorithms (i.e</span></span> <span data-ttu-id="41596-161">インバース キネマティクス、パス検索)</span><span class="sxs-lookup"><span data-stu-id="41596-161">inverse kinematics, path-finding)</span></span>

### <a name="gpu-performance-recommendations"></a><span data-ttu-id="41596-162">GPU のパフォーマンスに関する推奨事項</span><span class="sxs-lookup"><span data-stu-id="41596-162">GPU performance recommendations</span></span>

#### <a name="understanding-bandwidth-vs-fill-rate"></a><span data-ttu-id="41596-163">Understanding 帯域幅の vs のフィル レート</span><span class="sxs-lookup"><span data-stu-id="41596-163">Understanding bandwidth vs fill rate</span></span>
<span data-ttu-id="41596-164">GPU 上のフレームをレンダリングするときに、アプリケーションは一般にメモリ帯域幅や塗りつぶしのレートで範囲指定されたいずれかです。</span><span class="sxs-lookup"><span data-stu-id="41596-164">When rendering a frame on the GPU, an application is generally either bounded by memory bandwidth or fill rate.</span></span>

- <span data-ttu-id="41596-165">**メモリ帯域幅**読み取りの割合は、GPU がメモリから実行できる書き込み</span><span class="sxs-lookup"><span data-stu-id="41596-165">**Memory bandwidth** is the rate of reads and writes the GPU can perform from memory</span></span>
    - <span data-ttu-id="41596-166">帯域幅の制限を特定するには、テクスチャの品質が低下し、フレーム レートの向上を確認します。</span><span class="sxs-lookup"><span data-stu-id="41596-166">To identify bandwidth limitations, reduce texture quality and check if framerate improved.</span></span>
    - <span data-ttu-id="41596-167">Unity では、これを行う変更**テクスチャ品質**で**編集** > **プロジェクト設定** >   **[品質設定](https://docs.unity3d.com/Manual/class-QualitySettings.html)** します。</span><span class="sxs-lookup"><span data-stu-id="41596-167">In Unity, this can be done by changing **Texture Quality** in **Edit** > **Project Settings** > **[Quality Settings](https://docs.unity3d.com/Manual/class-QualitySettings.html)**.</span></span>
- <span data-ttu-id="41596-168">**フィル レート**GPU によって 1 秒あたりに描画できるレンダリングされるピクセルのスループットを参照します。</span><span class="sxs-lookup"><span data-stu-id="41596-168">**Fill rate** refers to the throughput of rendered pixels that can be drawn per second by the GPU.</span></span>
    - <span data-ttu-id="41596-169">塗りつぶしのレート制限を識別するためには、ディスプレイの解像度を低くし、フレーム レートの向上を確認します。</span><span class="sxs-lookup"><span data-stu-id="41596-169">To identify fill rate limitations, decrease the display resolution and check if framerate improved.</span></span> 
    - <span data-ttu-id="41596-170">この、Unity を使用して行うことができます、 *[XRSettings.renderViewportScale](https://docs.unity3d.com/ScriptReference/XR.XRSettings-renderViewportScale.html)* プロパティ</span><span class="sxs-lookup"><span data-stu-id="41596-170">In Unity, this can be done via the  *[XRSettings.renderViewportScale](https://docs.unity3d.com/ScriptReference/XR.XRSettings-renderViewportScale.html)* property</span></span>

<span data-ttu-id="41596-171">一般には、最適化するか、メモリ帯域幅</span><span class="sxs-lookup"><span data-stu-id="41596-171">Memory bandwidth generally involves optimizations to either</span></span>
1) <span data-ttu-id="41596-172">テクスチャの解像度を減らす</span><span class="sxs-lookup"><span data-stu-id="41596-172">decrease texture resolutions</span></span>
2) <span data-ttu-id="41596-173">(つまり、小さいテクスチャを利用します。</span><span class="sxs-lookup"><span data-stu-id="41596-173">utilize less textures (i.e</span></span> <span data-ttu-id="41596-174">法線、反射など)</span><span class="sxs-lookup"><span data-stu-id="41596-174">normals, specular, etc)</span></span>

<span data-ttu-id="41596-175">フィル レートは、レンダリングされたピクセルの最終的なを計算する必要のある操作の数を減らすことで主にフォーカスしています。</span><span class="sxs-lookup"><span data-stu-id="41596-175">Fill rate is primarily focused on reducing the number of operations that need to be computed for a final rendered pixel.</span></span> <span data-ttu-id="41596-176">この例はよく削減に分類されます。</span><span class="sxs-lookup"><span data-stu-id="41596-176">Examples of this commonly fall into reducing</span></span>
1) <span data-ttu-id="41596-177">レンダー/処理するオブジェクトの数</span><span class="sxs-lookup"><span data-stu-id="41596-177">number of objects to render/process</span></span>
2) <span data-ttu-id="41596-178">シェーダーあたりの操作の数</span><span class="sxs-lookup"><span data-stu-id="41596-178">number of operations per shader</span></span>
3) <span data-ttu-id="41596-179">最終的な結果 (ジオメトリ シェーダー、処理後の効果など) に GPU ステージの数</span><span class="sxs-lookup"><span data-stu-id="41596-179">number of GPU stages to final result (geometry shaders, post-processing effects, etc)</span></span>
4) <span data-ttu-id="41596-180">(つまり、表示するためにピクセルの数</span><span class="sxs-lookup"><span data-stu-id="41596-180">number of pixels to render (i.e</span></span> <span data-ttu-id="41596-181">画面の解像度)</span><span class="sxs-lookup"><span data-stu-id="41596-181">display resolution)</span></span>

#### <a name="reduce-poly-count"></a><span data-ttu-id="41596-182">ポリゴンの数を削減します。</span><span class="sxs-lookup"><span data-stu-id="41596-182">Reduce poly count</span></span>
<span data-ttu-id="41596-183">以上の多角形は、GPU のより多くの操作の結果をカウントし、シーン内の多角形の数を減らすことによりそのジオメトリを表示するために時間の量が減少します。</span><span class="sxs-lookup"><span data-stu-id="41596-183">Higher polygon counts result in more operations for the GPU and reducing the number of polygons in your scene will reduce the amount of time to render that geometry.</span></span> <span data-ttu-id="41596-184">ジオメトリが高価なできますを網掛けにも関連するその他の要素がありますが、多角形は、基本メトリックを決定する方法に高価なシーンをレンダリングします。</span><span class="sxs-lookup"><span data-stu-id="41596-184">There are other factors involved as well in shading the geometry that can still be expensive but polygon count is the base metric to determine how expensive a scene will be to render.</span></span>

#### <a name="limit-overdraw"></a><span data-ttu-id="41596-185">制限を範囲します。</span><span class="sxs-lookup"><span data-stu-id="41596-185">Limit overdraw</span></span>

<span data-ttu-id="41596-186">高オーバー ドローの複数のオブジェクトがレンダリングされますが、別、一般に近い、他のオブジェクトによって隠されていると画面に出力されていないときに発生します。</span><span class="sxs-lookup"><span data-stu-id="41596-186">High overdraw occurs when multiple objects are rendered but not outputted to the screen as they are hidden by another, generally closer, occluding object.</span></span> <span data-ttu-id="41596-187">複数のルームとその背後にあるジオメトリの壁を見ることを想像してください。</span><span class="sxs-lookup"><span data-stu-id="41596-187">Imagine looking at a wall that had multiple rooms and geometry behind it.</span></span> <span data-ttu-id="41596-188">処理されるすべてのジオメトリのレンダリングが、不透明な壁のみが本当にその他のすべてのコンテンツの表示を邪魔になりますが描画される必要があります。</span><span class="sxs-lookup"><span data-stu-id="41596-188">All of the geometry would be processed for rendering but only the opaque wall really needs to be rendered as it occludes the view of all other content.</span></span> <span data-ttu-id="41596-189">これにより、現在のビューの不要な無駄な操作。</span><span class="sxs-lookup"><span data-stu-id="41596-189">This results in wasteful operations that are not needed for the current view.</span></span>

#### <a name="shaders"></a><span data-ttu-id="41596-190">シェーダー</span><span class="sxs-lookup"><span data-stu-id="41596-190">Shaders</span></span>

<span data-ttu-id="41596-191">シェーダーは、GPU 上で実行され、通常、レンダリングの 2 つの重要な手順を決定する小さなプログラムです。</span><span class="sxs-lookup"><span data-stu-id="41596-191">Shaders are small programs that run on the GPU and generally determine two important steps in rendering:</span></span>
1) <span data-ttu-id="41596-192">画面と画面領域 (つまりにいるどのオブジェクトの頂点を描画します。</span><span class="sxs-lookup"><span data-stu-id="41596-192">which object's vertices should be drawn on the screen and where they are in screen space (i.e</span></span> <span data-ttu-id="41596-193">頂点シェーダー)</span><span class="sxs-lookup"><span data-stu-id="41596-193">the Vertex shader)</span></span>
    - <span data-ttu-id="41596-194">すべて GameObject の頂点ごと、頂点シェーダーが一般に実行されます。</span><span class="sxs-lookup"><span data-stu-id="41596-194">The Vertex shader is generally executed per vertex for every GameObject</span></span>
2) <span data-ttu-id="41596-195">何に (つまり、ピクセルの色</span><span class="sxs-lookup"><span data-stu-id="41596-195">what to color those pixels (i.e</span></span> <span data-ttu-id="41596-196">ピクセル シェーダー)</span><span class="sxs-lookup"><span data-stu-id="41596-196">the Pixel shader)</span></span>
    - <span data-ttu-id="41596-197">ピクセル シェーダーが存在するデバイスに表示されるテクスチャ、ピクセルあたりに実行されます。</span><span class="sxs-lookup"><span data-stu-id="41596-197">The Pixel shader is executed per pixel for the texture being rendered for device present</span></span>

<span data-ttu-id="41596-198">通常シェーダーは、多くの変換や照明の計算を実行します。</span><span class="sxs-lookup"><span data-stu-id="41596-198">Typically shaders perform many transformations and lighting calculations.</span></span> <span data-ttu-id="41596-199">複雑な照明モデル、シャドウ、およびその他の操作は、すばらしい結果を生成できますが、それらも付属して価格。</span><span class="sxs-lookup"><span data-stu-id="41596-199">Although complex lighting models, shadows, and other operations can generate fantastic results, they also come with a price.</span></span> <span data-ttu-id="41596-200">計算シェーダーの操作の数を減らすと、フレームごとの GPU で実行するために必要な全体的な作業を大幅に削減できます。</span><span class="sxs-lookup"><span data-stu-id="41596-200">Reducing the number of operations computed in shaders can greatly reduce the overall work needed to be done by a GPU per frame.</span></span>

##### <a name="shader-coding-recommendations"></a><span data-ttu-id="41596-201">シェーダーのコーディングの推奨事項</span><span class="sxs-lookup"><span data-stu-id="41596-201">Shader coding recommendations</span></span>

- <span data-ttu-id="41596-202">可能であれば、bilinear フィルタ リングを使用します。</span><span class="sxs-lookup"><span data-stu-id="41596-202">Use bilinear filtering whenever possible</span></span>
- <span data-ttu-id="41596-203">MAD の組み込みを同時に、multiply メソッドと追加を実行するために使用する式を再配置します。</span><span class="sxs-lookup"><span data-stu-id="41596-203">Rearrange expressions to use MAD intrinsics in order to do a multiply and an add at the same time</span></span>
- <span data-ttu-id="41596-204">CPU の可能な限りを事前計算し、材料に定数として渡す</span><span class="sxs-lookup"><span data-stu-id="41596-204">Precalculate as much as possible on the CPU and pass as constants to the material</span></span>
- <span data-ttu-id="41596-205">**ピクセル シェーダーから頂点シェーダーへの移動操作を優先します。**</span><span class="sxs-lookup"><span data-stu-id="41596-205">**Favor moving operations from the pixel shader to the vertex shader**</span></span>
    - <span data-ttu-id="41596-206">一般に、頂点数 << (つまり、ピクセルの数</span><span class="sxs-lookup"><span data-stu-id="41596-206">Generally the # of vertices << # of pixels (i.e</span></span> <span data-ttu-id="41596-207">720 p 921,600 ピクセル、1080 p = = 2,073,600 ピクセルなどを = =)</span><span class="sxs-lookup"><span data-stu-id="41596-207">720p == 921,600 pixels, 1080p == 2,073,600 pixels, etc)</span></span>

#### <a name="remove-gpu-stages"></a><span data-ttu-id="41596-208">GPU のステージを削除します。</span><span class="sxs-lookup"><span data-stu-id="41596-208">Remove GPU stages</span></span>
<span data-ttu-id="41596-209">処理後の効果、非常に高くなるし、一般に、アプリケーションのフィル レートを妨げることができます。</span><span class="sxs-lookup"><span data-stu-id="41596-209">Post-processing effects can be very expensive and generally inhibit the fill rate of your application.</span></span> <span data-ttu-id="41596-210">これには、MSAA などのアンチエイリアシング手法も含まれています。</span><span class="sxs-lookup"><span data-stu-id="41596-210">This also includes anti-aliasing techniques such as MSAA.</span></span> <span data-ttu-id="41596-211">HoloLens で、これらの手法を完全に回避することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="41596-211">On HoloLens, it is recommended to avoid these techniques entirely.</span></span> <span data-ttu-id="41596-212">さらに、geometry、ハル、計算シェーダーなどの追加のシェーダー ステージは、可能であれば避ける必要があります。</span><span class="sxs-lookup"><span data-stu-id="41596-212">Furthermore, additional shader stages such as geometry, hull, and compute shaders should be avoided when possible.</span></span>

## <a name="memory-recommendations"></a><span data-ttu-id="41596-213">メモリの推奨事項</span><span class="sxs-lookup"><span data-stu-id="41596-213">Memory recommendations</span></span>
<span data-ttu-id="41596-214">過剰なメモリの割り当てと割り当て解除の操作、holographic アプリケーションを一貫性のないパフォーマンス、固定されたフレーム、およびその他の好ましくない動作に影響を受けることができます。</span><span class="sxs-lookup"><span data-stu-id="41596-214">Excessive memory allocation & deallocation operations can have adverse effects on your holographic application resulting in inconsistent performance, frozen frames, and other detrimental behavior.</span></span> <span data-ttu-id="41596-215">これは、方法は、メモリ管理は、ガベージ コレクターによって制御されるため、Unity で開発するときは、メモリに関する考慮事項を理解するのには特に重要です。</span><span class="sxs-lookup"><span data-stu-id="41596-215">It is especially important to understand memory considerations when developing in Unity since memory management is controlled by the garbage collector.</span></span>

#### <a name="object-pooling"></a><span data-ttu-id="41596-216">オブジェクト プール</span><span class="sxs-lookup"><span data-stu-id="41596-216">Object pooling</span></span>

<span data-ttu-id="41596-217">オブジェクト プールは、オブジェクトの割り当て解除 (&)、継続的な割り当てのコストを削減する、一般的な手法です。</span><span class="sxs-lookup"><span data-stu-id="41596-217">Object pooling is a popular technique to reduce the cost of continuous allocations & deallocations of objects.</span></span> <span data-ttu-id="41596-218">これは、同一のオブジェクトの大きなプールを割り当てると、常に生成し、時間の経過と共にオブジェクトを破棄するのではなく、このプールから再アクティブでない、利用可能なインスタンスを使用して実行します。</span><span class="sxs-lookup"><span data-stu-id="41596-218">This is done by allocating a large pool of identical objects and re-using inactive, available instances from this pool instead of constantly spawning and destroying objects over time.</span></span> <span data-ttu-id="41596-219">オブジェクト プールは、アプリの中に変数の有効期間を持つ再利用可能なコンポーネントに適しています。</span><span class="sxs-lookup"><span data-stu-id="41596-219">Object pools are great for re-useable components that have variable lifetime during an app.</span></span>

## <a name="see-also"></a><span data-ttu-id="41596-220">関連項目</span><span class="sxs-lookup"><span data-stu-id="41596-220">See also</span></span>
- [<span data-ttu-id="41596-221">Unity のパフォーマンスに関する推奨事項</span><span class="sxs-lookup"><span data-stu-id="41596-221">Performance recommendations for Unity</span></span>](performance-recommendations-for-unity.md)
- [<span data-ttu-id="41596-222">Unity の推奨設定</span><span class="sxs-lookup"><span data-stu-id="41596-222">Recommended settings for Unity</span></span>](recommended-settings-for-unity.md)
