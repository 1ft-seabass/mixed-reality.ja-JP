---
title: Mixed Reality のパフォーマンスについて
description: Windows Mixed Reality アプリのパフォーマンスの最適化に関する高度なトピックと詳細
author: Troy-Ferrell
ms.author: trferrel
ms.date: 3/26/2019
ms.topic: article
keywords: Windows Mixed Reality、Mixed Reality、Virtual Reality、VR、MR、パフォーマンス、最適化、CPU、GPU
ms.openlocfilehash: ce59f9023c21dc7c981a2bb97d9fbd0c57622dbf
ms.sourcegitcommit: 915d3cc63a5571ba22ac4608589f3eca8da1bc81
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/24/2019
ms.locfileid: "63548839"
---
# <a name="understanding-performance-for-mixed-reality"></a>Mixed reality のパフォーマンスについて

この記事では、Mixed Reality アプリのパフォーマンスの合理化の概要について説明します。  アプリケーションが最適なフレームレートで実行されない場合、ユーザーエクスペリエンスが大幅に低下する可能性があります。 ホログラムが不安定になり、環境のヘッドトラッキングが不適切になり、ユーザーのエクスペリエンスが悪くなります。 実際には、パフォーマンスは、安定したサイクル終了タスクではなく、混合現実の開発のためのファーストクラスの機能と見なす必要があります。

確認のために、各ターゲットプラットフォームのパフォーマンスの高いフレームレート値を以下に示します。

| プラットフォーム | ターゲットフレームレート |
|----------|-------------------|
| [HoloLens](hololens-hardware-details.md) | 60 FPS |
| [Windows Mixed Reality ウルトラ Pc](immersive-headset-hardware-details.md) | 90 FPS |
| [Windows Mixed Reality Pc](immersive-headset-hardware-details.md) | 60 FPS |

以下のフレームワークは、ベストプラクティスとターゲットフレームレートの異なればに対する一般的な概要を示しています。 詳細について詳しくは、 [「Unity のパフォーマンスに関する推奨事項](performance-recommendations-for-unity.md)」を参照してください。 特に、この関連記事では、Unity Windows Mixed Reality アプリでフレームレートを測定する方法と、Unity 環境でパフォーマンスを向上させるための手順について説明します。

## <a name="understanding-performance-bottlenecks"></a>パフォーマンスのボトルネックについて

アプリの不採算事業フレームレートがある場合、最初の手順は、アプリケーションが計算を集中的に使用している場所を分析して理解することです。 シーンをレンダリングする作業には、CPU と GPU の2つの主要なプロセッサがあります。 これらの2つのコンポーネントは、混在する現実のアプリのさまざまな操作とステージを処理します。 ボトルネックが発生する可能性がある主な場所は3つあります。 

1. **アプリスレッド-CPU** -このスレッドは、アプリロジックを担います。 これには、入力、アニメーション、物理、およびその他のアプリのロジック/状態の処理が含まれます。
2. **スレッドを gpu にレンダリングする**-このスレッドは、gpu への描画呼び出しを送信します。 アプリでキューブやモデルなどのオブジェクトをレンダリングする場合、このスレッドは GPU に要求を送信します。 GPU には、レンダリングのために最適化されたアーキテクチャがあり、これらの操作を実行します。
3. **GPU**- 
   このプロセッサは、一般に、3d データ (モデル、テクスチャなど) をピクセルに変換し、最終的にデバイスの画面に送信する2d イメージを生成するために、アプリケーションのグラフィックスパイプラインを処理します。

![フレームの有効期間](images/lifetime-of-a-frame.png)

一般に、HoloLens アプリケーションは GPU で制限されます。 ただし、この方法はすべてのアプリケーションに当てはまるわけではありません。そのため、以下のツール & の手法を使用して、特定のアプリの基本を理解することをお勧めします。

## <a name="how-to-analyze-your-application"></a>アプリケーションを分析する方法

開発者が混合現実アプリケーションのパフォーマンスプロファイルを理解できるツールは多数あります。 これらを使用すると、ボトルネックがある場所と、それらをデバッグするために自身を manifesting する方法の両方をターゲットにすることができます。

これは、アプリケーションの詳細なプロファイル情報を取得するための一般的で強力なツールの一覧です。
- [Intel グラフィックスパフォーマンスアナライザー](https://software.intel.com/gpa)
- [Visual Studio のグラフィックスデバッガー](https://docs.microsoft.com/visualstudio/debugger/graphics/visual-studio-graphics-diagnostics?view=vs-2017)
- [Unity Profiler](https://docs.unity3d.com/Manual/Profiler.html)
- [Unity フレームデバッガー](https://docs.unity3d.com/Manual/FrameDebugger.html)

### <a name="how-to-profile-in-any-environment"></a>任意の環境でプロファイリングする方法

アプリケーションで GPU が制限されているか、CPU が制限されている可能性があるかどうかをすばやく判断するための簡単なテストがあります。 レンダーターゲットの出力の解像度を下げると、計算するピクセル数が少なくなるため、イメージをレンダリングするために GPU で実行する必要がある作業が少なくなります。 ビューポートのスケーリング (動的な解決のスケーリング) は、イメージを小さいレンダーターゲットにレンダリングする場合に、出力デバイスで表示できるようにするための方法です。 デバイスは、小さいピクセルセットから、最終的なイメージを表示するためにアップサンプリングされます。

レンダリングの解像度を下げると、次のようになります。
1) アプリケーションのフレームレートが**増加**し、 **GPU が制限**されている可能性があります。
1) アプリケーションのフレームレートが**変更**されていないため、 **CPU が制限**される可能性があります

>[!NOTE]
>Unity では、 *[XRSettings](https://docs.unity3d.com/ScriptReference/XR.XRSettings-renderViewportScale.html)* プロパティを使用して、実行時にアプリケーションのレンダーターゲットの解像度を簡単に変更することができます。 デバイスに表示される最終的なイメージには、固定された解決策があります。 このプラットフォームでは、解像度の低い出力をサンプリングして、ディスプレイに表示する解像度の高いイメージを構築します。 
>
>```CS
>UnityEngine.XR.XRSettings.renderScale = 0.7f;
>```

## <a name="how-to-improve-your-application"></a>アプリケーションを改善する方法

### <a name="cpu-performance-recommendations"></a>CPU パフォーマンスに関する推奨事項

一般に、CPU 上の mixed reality アプリケーションでほとんどの作業を行うには、シーンの "シミュレーション" を実行し、広範な一意のアプリケーションロジックを処理する必要があります。 したがって、通常、次の領域は最適化の対象となります。

- アニメーション
- 物理の単純化
- メモリの割り当て
- 複雑なアルゴリズム ( 逆のキネマティック、パスの検索)

### <a name="gpu-performance-recommendations"></a>GPU のパフォーマンスに関する推奨事項

#### <a name="understanding-bandwidth-vs-fill-rate"></a>帯域幅と塗りつぶしレートを理解する
GPU でフレームをレンダリングする場合、通常、アプリケーションはメモリ帯域幅またはフィルレートによって制限されます。

- **メモリ帯域幅**は、GPU がメモリから実行できる読み取りと書き込みの比率です。
    - 帯域幅の制限を特定するには、テクスチャの品質を下げ、フレームレートが向上したかどうかを確認します。
    - Unity では、[**プロジェクト設定** > の **[品質設定](https://docs.unity3d.com/Manual/class-QualitySettings.html)** の**編集** > ] で **[テクスチャの品質]** を変更することによってこれを行うことができます。
- **Fill rate**は、GPU によって1秒あたりに描画できる描画ピクセルのスループットを表します。
    - フィルレートの制限を特定するには、ディスプレイの解像度を下げ、フレームレートが改善されたかどうかを確認します。 
    - Unity では、XRSettings プロパティを使用してこれを行うことができ *[ます。](https://docs.unity3d.com/ScriptReference/XR.XRSettings-renderViewportScale.html)*

通常、メモリ帯域幅には最適化が必要です。
1) テクスチャ解像度を下げる
2) 使用するテクスチャを減らす (つまり、 法線、スペキュラなど)

Fill rate は、描画された最終的なピクセルに対して計算する必要がある操作の数を減らすことに主に焦点を合わせています。 一般的に、この例は減少します。
1) 表示/処理するオブジェクトの数
2) シェーダーあたりの操作数
3) 最終的な結果に対する GPU ステージの数 (ジオメトリシェーダー、処理後の効果など)
4) レンダリングするピクセル数 (つまり、 表示解像度)

#### <a name="reduce-poly-count"></a>Poly 数を減らす
多角形の数が多いほど、GPU に対する操作が増加し、シーン内のポリゴンの数が減少するため、そのジオメトリをレンダリングする時間が短縮されます。 それ以外にも、負荷が高くなる可能性があるジオメトリの網掛けに関連する要因がありますが、ポリゴンの数は、シーンのレンダリングにかかるコストを決定する基本メトリックです。

#### <a name="limit-overdraw"></a>オーバードローを制限する

大きなオーバードローは、複数のオブジェクトがレンダリングされるときに発生しますが、画面には出力されません。これは、通常より近くにある別の occluding オブジェクトによって隠されているためです。 複数の部屋とジオメトリの背後にある壁を見てみてください。 すべてのジオメトリはレンダリング用に処理されますが、他のすべてのコンテンツのビューを occludes するときは、不透明なウォールだけをレンダリングする必要があります。 その結果、現在のビューでは不要な無駄な操作が発生します。

#### <a name="shaders"></a>シェーダー

シェーダーは、GPU 上で実行される小さなプログラムであり、一般にレンダリングの2つの重要な手順を決定します。
1) 画面上に描画するオブジェクトの頂点と、その頂点が画面空間 ( 頂点シェーダー)
    - 頂点シェーダーは、一般に、各オブジェクトの頂点ごとに実行されます。
2) これらのピクセルに色を設定する (つまり、 ピクセルシェーダー)
    - ピクセルシェーダーは、デバイスに表示されているテクスチャのピクセルごとに実行されます。

通常、シェーダーでは、多くの変換と照明計算が実行されます。 複雑な照明モデル、影、およびその他の操作によって、優れた結果が得られる場合もありますが、価格もあります。 シェーダーで計算される操作の数を減らすと、フレームあたりの GPU によって実行される作業全体が大幅に減少します。

##### <a name="shader-coding-recommendations"></a>シェーダーのコーディングに関する推奨事項

- 可能な限り、バイリニアフィルタリングを使用する
- 同時に乗算と加算を行うために、MAD 組み込みを使用するように式を再配置します。
- CPU で可能な限り Precalculate し、素材に定数として渡します。
- **ピクセルシェーダーから頂点シェーダーへの移動操作を優先する**
    - 一般に、頂点の数 < < ピクセル数 (つまり、 720p = = 921600 ピクセル、1080p = = 2073600 ピクセルなど)

#### <a name="remove-gpu-stages"></a>GPU ステージの削除
処理後の影響には非常にコストがかかり、一般にアプリケーションのフィルレートが妨げられる可能性があります。 これには、MSAA などのアンチエイリアシング手法も含まれます。 HoloLens では、これらの手法を完全に回避することをお勧めします。 さらに、可能な場合は、geometry、ハル、compute シェーダーなどの追加のシェーダーのステージを避ける必要があります。

## <a name="memory-recommendations"></a>メモリに関する推奨事項
過剰なメモリ割り当て & 解放操作によって holographic アプリケーションに悪影響を及ぼす可能性があるため、パフォーマンスが低下したり、フレームが固定されたり、その他の有害な動作が発生したりする可能性があります。 メモリ管理はガベージコレクターによって制御されるため、Unity で開発するときは、メモリに関する考慮事項を理解することが特に重要です。

#### <a name="object-pooling"></a>オブジェクトプール

オブジェクトプールは、オブジェクトの割り当て解除 & の継続的な割り当てのコストを削減するための一般的な手法です。 これを行うには、同一のオブジェクトの大規模なプールを割り当て、時間の経過と共にオブジェクトを絶えず破棄するのではなく、このプールから使用可能な非アクティブなインスタンスを再利用します。 オブジェクトプールは、アプリの有効期間が可変の再使用可能なコンポーネントに最適です。

## <a name="see-also"></a>関連項目
- [Unity のパフォーマンスに関する推奨事項](performance-recommendations-for-unity.md)
- [Unity で推奨される設定](recommended-settings-for-unity.md)
