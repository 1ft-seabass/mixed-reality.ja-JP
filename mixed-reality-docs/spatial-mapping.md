---
title: 空間マッピング
description: 空間マッピングは、HoloLens、周りの環境で現実世界のサーフェスの詳細な表現を提供します。
author: mattzmsft
ms.author: mazeller
ms.date: 03/21/2018
ms.topic: article
keywords: 空間マッピング、HoloLens、複合現実、画面の再構築、メッシュ、sr
ms.openlocfilehash: 31abeca624512f1d5e721dbe879ca2243cf41345
ms.sourcegitcommit: 384b0087899cd835a3a965f75c6f6c607c9edd1b
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/12/2019
ms.locfileid: "59605041"
---
# <a name="spatial-mapping"></a><span data-ttu-id="22311-104">空間マッピング</span><span class="sxs-lookup"><span data-stu-id="22311-104">Spatial mapping</span></span>

<span data-ttu-id="22311-105">空間マッピングは、真に迫った複合現実エクスペリエンスを作成でき、HoloLens、周りの環境で現実世界のサーフェスの詳しい表現を提供します。</span><span class="sxs-lookup"><span data-stu-id="22311-105">Spatial mapping provides a detailed representation of real-world surfaces in the environment around the HoloLens, allowing developers to create a convincing mixed reality experience.</span></span> <span data-ttu-id="22311-106">仮想世界で現実世界をマージすることで、アプリケーションは実際と思われるホログラムを行うことができます。</span><span class="sxs-lookup"><span data-stu-id="22311-106">By merging the real world with the virtual world, an application can make holograms seem real.</span></span> <span data-ttu-id="22311-107">アプリケーションも揃えることがより自然でユーザーの期待使い慣れた実際の動作と相互作用を提供することで。</span><span class="sxs-lookup"><span data-stu-id="22311-107">Applications can also more naturally align with user expectations by providing familiar real-world behaviors and interactions.</span></span>

<br>

>[!VIDEO https://www.youtube.com/embed/zff2aQ1RaVo]

## <a name="device-support"></a><span data-ttu-id="22311-108">デバイスのサポート</span><span class="sxs-lookup"><span data-stu-id="22311-108">Device support</span></span>

<table>
<tr>
<th><span data-ttu-id="22311-109">機能</span><span class="sxs-lookup"><span data-stu-id="22311-109">Feature</span></span></th><th style="width:150px"> <span data-ttu-id="22311-110"><a href="hololens-hardware-details.md">HoloLens (第 1 世代)</a></span><span class="sxs-lookup"><span data-stu-id="22311-110"><a href="hololens-hardware-details.md">HoloLens (1st gen)</a></span></span></th><th style="width:150px"><span data-ttu-id="22311-111">HoloLens 2</span><span class="sxs-lookup"><span data-stu-id="22311-111">HoloLens 2</span></span></th><th style="width:150px"> <span data-ttu-id="22311-112"><a href="immersive-headset-hardware-details.md">イマーシブ ヘッドセット</a></span><span class="sxs-lookup"><span data-stu-id="22311-112"><a href="immersive-headset-hardware-details.md">Immersive headsets</a></span></span></th>
</tr><tr>
<td> <span data-ttu-id="22311-113">空間マッピング</span><span class="sxs-lookup"><span data-stu-id="22311-113">Spatial mapping</span></span></td><td style="text-align: center;"> <span data-ttu-id="22311-114">✔️</span><span class="sxs-lookup"><span data-stu-id="22311-114">✔️</span></span></td><td style="text-align: center;"> <span data-ttu-id="22311-115">✔️</span><span class="sxs-lookup"><span data-stu-id="22311-115">✔️</span></span></td><td style="text-align: center;"></td>
</tr>
</table>



## <a name="conceptual-overview"></a><span data-ttu-id="22311-116">概念の概要</span><span class="sxs-lookup"><span data-stu-id="22311-116">Conceptual overview</span></span>

<span data-ttu-id="22311-117">![ルームをカバーするメッシュ サーフェス](images/SurfaceReconstruction.jpg)</span><span class="sxs-lookup"><span data-stu-id="22311-117">![Mesh surfaces covering a room](images/SurfaceReconstruction.jpg)</span></span><br>
<span data-ttu-id="22311-118">*ルームをカバーする空間マッピング メッシュの例*</span><span class="sxs-lookup"><span data-stu-id="22311-118">*An example of a spatial mapping mesh covering a room*</span></span>

<span data-ttu-id="22311-119">空間マッピングに使用される 2 つのプライマリ オブジェクトの種類には、' 空間画面のオブザーバー 'および' 空間画面 ' です。</span><span class="sxs-lookup"><span data-stu-id="22311-119">The two primary object types used for spatial mapping are the 'Spatial Surface Observer' and the 'Spatial Surface'.</span></span>

<span data-ttu-id="22311-120">空間マッピング データを受信するアプリケーションが望んでいる領域の領域を定義する 1 つまたは複数の外接するボリュームで空間画面オブザーバーは、アプリケーションに提供します。</span><span class="sxs-lookup"><span data-stu-id="22311-120">The application provides the Spatial Surface Observer with one or more bounding volumes, to define the regions of space in which the application wishes to receive spatial mapping data.</span></span> <span data-ttu-id="22311-121">これらのボリュームごとに、空間マッピングは一連の空間のサーフェスのアプリケーションを提供します。</span><span class="sxs-lookup"><span data-stu-id="22311-121">For each of these volumes, spatial mapping will provide the application with a set of Spatial Surfaces.</span></span>

<span data-ttu-id="22311-122">これらのボリュームが静止している (現実の世界に対して固定の場所) 内か、HoloLens (、移動しますが、回転しない、HoloLens のように、環境を移動するとき) に接続されている可能性があります。</span><span class="sxs-lookup"><span data-stu-id="22311-122">These volumes may be stationary (in a fixed location with respect to the real world) or they may be attached to the HoloLens (they move, but do not rotate, with the HoloLens as it moves through the environment).</span></span> <span data-ttu-id="22311-123">各空間のサーフェスは、世界ロックにアタッチされている三角形メッシュとして表される領域のサイズの小さいボリューム内の実際のサーフェスを説明します。[空間座標系](coordinate-systems.md)します。</span><span class="sxs-lookup"><span data-stu-id="22311-123">Each spatial surface describes real-world surfaces in a small volume of space, represented as a triangle mesh attached to a world-locked [spatial coordinate system](coordinate-systems.md).</span></span>

<span data-ttu-id="22311-124">HoloLens、環境に関する新しいデータを収集し、空間のサーフェスが表示されます、環境への変更が発生すると、非表示し、変更します。</span><span class="sxs-lookup"><span data-stu-id="22311-124">As the HoloLens gathers new data about the environment, and as changes to the environment occur, spatial surfaces will appear, disappear and change.</span></span>

## <a name="common-usage-scenarios"></a><span data-ttu-id="22311-125">一般的な使用シナリオ</span><span class="sxs-lookup"><span data-stu-id="22311-125">Common usage scenarios</span></span>

![空間マッピングの一般的な使用シナリオの図。配置、オクルー ジョン、物理運動およびナビゲーション](images/sm-concepts-1000px.png)

### <a name="placement"></a><span data-ttu-id="22311-127">配置</span><span class="sxs-lookup"><span data-stu-id="22311-127">Placement</span></span>

<span data-ttu-id="22311-128">空間マッピングは、ユーザーには相互作用のフォームを自然かつ使い慣れたをもたらすアプリケーションを提供します。ダウン、デスクに電話を配置するよりもより自然などのような可能性がありますか。</span><span class="sxs-lookup"><span data-stu-id="22311-128">Spatial mapping provides applications with the opportunity to present natural and familiar forms of interaction to the user; what could be more natural than placing your phone down on the desk?</span></span>

<span data-ttu-id="22311-129">ホログラムの配置の制約 (より一般的には、空間的な場所の選択) サーフェス上に存在するには、2 D (画面上のポイント) を 3D (空間内の点) から自然なマッピングを提供します。 します。</span><span class="sxs-lookup"><span data-stu-id="22311-129">Constraining the placement of holograms (or more generally, any selection of spatial locations) to lie on surfaces provides a natural mapping from 3D (point in space) to 2D (point on surface).</span></span> <span data-ttu-id="22311-130">これには、ユーザーがアプリケーションに提供する必要があるし、ことができ、ユーザーの操作より速くより簡単より正確な情報の量が削減されます。</span><span class="sxs-lookup"><span data-stu-id="22311-130">This reduces the amount of information the user needs to provide to the application and thus makes the user's interactions faster, easier and more precise.</span></span> <span data-ttu-id="22311-131">これは、機能は、'離れた距離' がないため物理的に他のユーザーまたはコンピューターの通信に提供されることに特に当てはまります。</span><span class="sxs-lookup"><span data-stu-id="22311-131">This is particularly true because 'distance away' is not something that we are used to physically communicating to other people or to computers.</span></span> <span data-ttu-id="22311-132">したのでポイントすると、指定するは、方向が距離ではありません。</span><span class="sxs-lookup"><span data-stu-id="22311-132">When we point with our finger, we are specifying a direction but not a distance.</span></span>

<span data-ttu-id="22311-133">アプリケーションの方向からの距離を推論するときに、重要な注意点は (に最も近いを検索するユーザーの視線入力方向の raycast を実行することなどによって空間画面)、このユーザーが確実に予測できる結果を生成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="22311-133">An important caveat here is that when an application infers distance from direction (for example by performing a raycast along the user's gaze direction to find the nearest spatial surface), this must yield results that the user is able to reliably predict.</span></span> <span data-ttu-id="22311-134">それ以外の場合、ユーザーがコントロールの意味が失われ、これがすぐにイライラします。</span><span class="sxs-lookup"><span data-stu-id="22311-134">Otherwise, the user will lose their sense of control and this can quickly become frustrating.</span></span> <span data-ttu-id="22311-135">1 つだけではなく複数 raycasts を実行することにより、この方法の 1 つです。</span><span class="sxs-lookup"><span data-stu-id="22311-135">One method that helps with this is to perform multiple raycasts instead of just one.</span></span> <span data-ttu-id="22311-136">集計の結果より滑らかなより予測可能な (小さな穴に渡されるまたは少量のユーザーは認識しないジオメトリのヒット光線によって発生すること) と '外れ値' で一時的な結果に影響を与えるに受けにくくなりますがあります。</span><span class="sxs-lookup"><span data-stu-id="22311-136">The aggregate results should be smoother and more predictable, less susceptible to influence from transient 'outlier' results (as can be caused by rays passing through tiny holes or hitting small bits of geometry that the user is not aware of).</span></span> <span data-ttu-id="22311-137">時間の経過とともに集計やスムージングを実行することもたとえば、ユーザーからの距離をホログラムはさまざま最大速度を制限できます。</span><span class="sxs-lookup"><span data-stu-id="22311-137">Aggregation or smoothing can also be performed over time; for example you can limit the maximum speed at which a hologram can vary in distance from the user.</span></span> <span data-ttu-id="22311-138">距離の最小値と最大値を単に制限することができます、ので、移動されるホログラムが飛行距離にまたはユーザーの顔に絞めるして突然されません。</span><span class="sxs-lookup"><span data-stu-id="22311-138">Simply limiting the minimum and maximum distance value can also help, so the hologram being moved does not suddenly fly away into the distance or come crashing back into the user's face.</span></span>

<span data-ttu-id="22311-139">アプリケーションは、ガイド ホログラム配置する、図形とサーフェスの方向を使用できますも。</span><span class="sxs-lookup"><span data-stu-id="22311-139">Applications can also use the shape and direction of surfaces to guide hologram placement.</span></span> <span data-ttu-id="22311-140">Holographic 椅子は壁を通過する必要がありますいないと、少しでもない場合でも、フロアでフラッシュ配置する必要があります。</span><span class="sxs-lookup"><span data-stu-id="22311-140">A holographic chair should not penetrate through walls and should sit flush with the floor even if it is slightly uneven.</span></span> <span data-ttu-id="22311-141">このような機能は、ただしのような懸念事項が適用されます、単なる raycasts ではなく、物理運動の衝突の使用時に依存する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="22311-141">This kind of functionality would likely rely upon the use of physics collisions rather than just raycasts, however similar concerns will apply.</span></span> <span data-ttu-id="22311-142">配置されているホログラムが突き出した、椅子、足のような多くの小規模な多角形が賢明せず空間サーフェス上のスライドことができるようにも縦と横より滑らかなものにこれらの多角形の物理運動の表現を拡張するにはキャプチャします。</span><span class="sxs-lookup"><span data-stu-id="22311-142">If the hologram being placed has many small polygons that stick out, like the legs on a chair, it may make sense to expand the physics representation of those polygons to something wider and smoother so that they are more able to slide over spatial surfaces without snagging.</span></span>

<span data-ttu-id="22311-143">極端な場合、ユーザー入力を簡略化できます離れた完全と完全に自動化ホログラム配置を実行する空間のサーフェスを使用できます。</span><span class="sxs-lookup"><span data-stu-id="22311-143">At its extreme, user input can be simplified away entirely and spatial surfaces can be used to perform entirely automatic hologram placement.</span></span> <span data-ttu-id="22311-144">たとえば、アプリケーションでしたを置いて holographic のライトの切り替えを押すユーザーのウォールにします。</span><span class="sxs-lookup"><span data-stu-id="22311-144">For example, the application could place a holographic light-switch somewhere on the wall for the user to press.</span></span> <span data-ttu-id="22311-145">二重ここでは予測可能性についてこの注意事項が適用されます。ユーザーが求めるホログラムの配置を制御、アプリケーションは常に設定されませんホログラム (ライトの切り替えでは、ユーザーに到達できない別の場所が表示されます) 場合が期待される場合は、フラストレーションにこのなります。</span><span class="sxs-lookup"><span data-stu-id="22311-145">The same caveat about predictability applies doubly here; if the user expects control over hologram placement, but the application does not always place holograms where they expect (if the light-switch appears somewhere that the user cannot reach), then this will be a frustrating experience.</span></span> <span data-ttu-id="22311-146">ユーザーの修正を必要とする自動配置を実行する悪い場合があります実際には、配置を自体は常に実行するユーザーに必要なだけよりも、時間の一部自動配置が成功したため*予想*負担のような気持ちに手動で修正。</span><span class="sxs-lookup"><span data-stu-id="22311-146">It can actually be worse to perform automatic placement that requires user correction some of the time, than to just require the user to always perform placement themselves; because successful automatic placement is *expected*, manual correction feels like a burden!</span></span>

<span data-ttu-id="22311-147">また、配置は、アプリケーションに大きく依存する場合は、空間のサーフェスを使用するアプリケーションの機能[エクスペリエンスをスキャン](spatial-mapping-design.md#the-environment-scanning-experience)します。</span><span class="sxs-lookup"><span data-stu-id="22311-147">Note also that the ability of an application to use spatial surfaces for placement depends heavily on the application's [scanning experience](spatial-mapping-design.md#the-environment-scanning-experience).</span></span> <span data-ttu-id="22311-148">サーフェスがスキャンされていない場合は、配置に使用できません。</span><span class="sxs-lookup"><span data-stu-id="22311-148">If a surface has not been scanned, then it cannot be used for placement.</span></span> <span data-ttu-id="22311-149">これをユーザーにクリアようにする新しい画面をスキャンまたは新しい場所の選択がわかるか、アプリケーションの責任です。</span><span class="sxs-lookup"><span data-stu-id="22311-149">It is up to the application to make this clear to the user, so that they can either help scan new surfaces or select a new location.</span></span>

<span data-ttu-id="22311-150">ユーザーに視覚的なフィードバックは、配置時に最も重要です。</span><span class="sxs-lookup"><span data-stu-id="22311-150">Visual feedback to the user is of paramount importance during placement.</span></span> <span data-ttu-id="22311-151">ユーザーに最も近い画面関連ホログラムが場所がわかっている必要のある[効果の接地](spatial-mapping.md#visualization)します。</span><span class="sxs-lookup"><span data-stu-id="22311-151">The user needs to know where the hologram is in relation to the nearest surface with [grounding effects](spatial-mapping.md#visualization).</span></span> <span data-ttu-id="22311-152">(たとえば、衝突と他の画面の近くにある) ため、ホログラムの動きが制約されている理由を理解する必要があります。</span><span class="sxs-lookup"><span data-stu-id="22311-152">They should understand why the movement of their hologram is being constrained (for example, due to collision with another nearby surface).</span></span> <span data-ttu-id="22311-153">場合は、現在の場所、ホログラムを配置することはできません、し、視覚的なフィードバックする必要があります明確になる理由されません。</span><span class="sxs-lookup"><span data-stu-id="22311-153">If they cannot place a hologram in the current location, then visual feedback should make it clear why not.</span></span> <span data-ttu-id="22311-154">たとえば、配置しようとして、ユーザー holographic ソファ停止途中、壁に怒っている色で、壁の背後にある、カウチの部分が規則正しく必要がありますし、します。</span><span class="sxs-lookup"><span data-stu-id="22311-154">For example, if the user is trying to place a holographic couch stuck half-way into the wall, then the portions of the couch that are behind the wall should pulsate in an angry color.</span></span> <span data-ttu-id="22311-155">または、反対に、アプリケーションは、実際の画面を表示できる場所で空間のサーフェスを見つけることができない場合、アプリケーションでは、このクリアします。</span><span class="sxs-lookup"><span data-stu-id="22311-155">Or conversely, if the application cannot find a spatial surface in a location where the user can see a real-world surface, then the application should make this clear.</span></span> <span data-ttu-id="22311-156">この領域の接地効果の明確ながない場合は、この目的を達成可能性があります。</span><span class="sxs-lookup"><span data-stu-id="22311-156">The obvious absence of a grounding effect in this area may achieve this purpose.</span></span>

### <a name="occlusion"></a><span data-ttu-id="22311-157">オクルージョン</span><span class="sxs-lookup"><span data-stu-id="22311-157">Occlusion</span></span>

<span data-ttu-id="22311-158">空間マッピング サーフェスの主な用途の 1 つは、ホログラムがすることです。</span><span class="sxs-lookup"><span data-stu-id="22311-158">One of the primary uses of spatial mapping surfaces is simply to occlude holograms.</span></span> <span data-ttu-id="22311-159">この単純な動作は、ホログラムを本当に、ユーザーと同じ物理領域に存在する本能的な意味を作り出すためのユーザーの体感よりリアルに大きな影響を及ぼします。</span><span class="sxs-lookup"><span data-stu-id="22311-159">This simple behavior has a huge impact on the perceived realism of holograms, helping to create a visceral sense that really inhabit the same physical space as the user.</span></span>

<span data-ttu-id="22311-160">オクルー ジョン、ユーザーには情報も提供しますホログラムは、実際の画面によってオクルー ジョンするが表示されたら、この世界では、そのホログラムの所在地に関して追加の視覚的フィードバックを提供します。</span><span class="sxs-lookup"><span data-stu-id="22311-160">Occlusion also provides information to the user; when a hologram appears to be occluded by a real-world surface, this provides additional visual feedback as to the spatial location of that hologram in the world.</span></span> <span data-ttu-id="22311-161">逆に、遮蔽ができますも有効*を非表示に*ユーザーからの情報は、直感的な方法でビジュアルをすっきり壁が背後にある他ホログラムします。</span><span class="sxs-lookup"><span data-stu-id="22311-161">Conversely, occlusion can also usefully *hide* information from the user; occluding holograms behind walls can reduce visual clutter in an intuitive way.</span></span> <span data-ttu-id="22311-162">ホログラムを表示または非表示に、ユーザーは自分の頭を移動するだけですが。</span><span class="sxs-lookup"><span data-stu-id="22311-162">To hide or reveal a hologram, the user merely has to move their head.</span></span>

<span data-ttu-id="22311-163">重なりを使用して使い慣れた物理的な相互作用; に基づいて自然なユーザー インターフェイスに対する期待を準備することもできます。ホログラムがその画面が堅牢ですサーフェスによってオクルー ジョンされた場合、そのため、期待されるホログラムは*衝突*を画面し、だけでなく通過します。</span><span class="sxs-lookup"><span data-stu-id="22311-163">Occlusion can also be used to prime expectations for a natural user interface based upon familiar physical interactions; if a hologram is occluded by a surface it is because that surface is solid, so the user should expect that the hologram will *collide* with that surface and not simply pass through it.</span></span>

<span data-ttu-id="22311-164">場合によっては、オクルー ジョン ホログラムは望ましくありません。</span><span class="sxs-lookup"><span data-stu-id="22311-164">Sometimes, occlusion of holograms is undesirable.</span></span> <span data-ttu-id="22311-165">ホログラムと対話できるように、ユーザーに必要な場合は、実際の画面の内側にある場合でも - 表示できないようにする、必要があります。</span><span class="sxs-lookup"><span data-stu-id="22311-165">If a user needs to be able to interact with a hologram, then they need to be able to see it - even if it is behind a real-world surface.</span></span> <span data-ttu-id="22311-166">このような場合は、通常は理にかなって (たとえばは明るさを減らすこと) で、オクルー ジョンはときに、このようなホログラムを異なる方法でレンダリングします。</span><span class="sxs-lookup"><span data-stu-id="22311-166">In such cases, it usually makes sense to render such a hologram differently when it is occluded (for example, by reducing its brightness).</span></span> <span data-ttu-id="22311-167">これにより、ユーザーは、ホログラムを視覚的に見つけられませんされますが、何かの内側にあることに注意してくださいができます。</span><span class="sxs-lookup"><span data-stu-id="22311-167">This way, the user will be able to visually locate the hologram, but they will still be aware that it is behind something.</span></span>

### <a name="physics"></a><span data-ttu-id="22311-168">物理学</span><span class="sxs-lookup"><span data-stu-id="22311-168">Physics</span></span>

<span data-ttu-id="22311-169">物理運動のシミュレーションの使用は、別の方法を補強する空間マッピングを使用できます、*プレゼンス*ホログラムでユーザーの物理的なスペースの。</span><span class="sxs-lookup"><span data-stu-id="22311-169">The use of physics simulation is another way in which spatial mapping can be used to reinforce the *presence* of holograms in the user's physical space.</span></span> <span data-ttu-id="22311-170">Holographic ゴム ボールみたいだったよは私の机から現実的にはロールし、フロア間 bounces、ソファでは表示されなくなります、ハードすることが本当に存在しないと思われる場合があります。</span><span class="sxs-lookup"><span data-stu-id="22311-170">When my holographic rubber ball rolls realistically off my desk, bounces across the floor and disappears under the couch, it might be hard for me to believe that it's not really there.</span></span>

<span data-ttu-id="22311-171">物理運動のシミュレーションには、自然かつ使い慣れた物理ベースの相互作用を使用するアプリケーションにとっての機会も提供します。</span><span class="sxs-lookup"><span data-stu-id="22311-171">Physics simulation also provides the opportunity for an application to use natural and familiar physics-based interactions.</span></span> <span data-ttu-id="22311-172">床の上 holographic 家具の周囲の一部を移動する可能性がありますしやすくなります、ユーザーの家具が慣性による処理の適切な摩擦と床面の間で、スライディングされたかのように応答する場合。</span><span class="sxs-lookup"><span data-stu-id="22311-172">Moving a piece of holographic furniture around on the floor will likely be easier for the user if the furniture responds as if it were sliding across the floor with the appropriate inertia and friction.</span></span>

<span data-ttu-id="22311-173">実際の物理的な動作を生成するために必要がありますをいくつか実行[メッシュ処理](spatial-mapping.md#mesh-processing)などの穴を入力するには、削除 hallucinations のフローティング、およびスムージング概要サーフェス。</span><span class="sxs-lookup"><span data-stu-id="22311-173">In order to generate realistic physical behaviors, you will likely need to perform some [mesh processing](spatial-mapping.md#mesh-processing) such as filling holes, removing floating hallucinations and smoothing rough surfaces.</span></span>

<span data-ttu-id="22311-174">考慮する必要がありますも方法、アプリケーションの[エクスペリエンスをスキャン](spatial-mapping-design.md#the-environment-scanning-experience)物理運動のシミュレーションに影響を与えます。</span><span class="sxs-lookup"><span data-stu-id="22311-174">You will also need to consider how your application's [scanning experience](spatial-mapping-design.md#the-environment-scanning-experience) influences its physics simulation.</span></span> <span data-ttu-id="22311-175">まず、サーフェスが不足するいると競合しないものです。ラバー ボール長くて言い、回廊ダウンし、既知の世界の終わりと起こりますか。</span><span class="sxs-lookup"><span data-stu-id="22311-175">Firstly, missing surfaces won't collide with anything; what happens when the rubber ball rolls off down the corridor and off the end of the known world?</span></span> <span data-ttu-id="22311-176">次に、時間の経過と共に、環境内の変更に応答する続けますかどうかを決定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="22311-176">Secondly, you need to decide whether you will continue to respond to changes in the environment over time.</span></span> <span data-ttu-id="22311-177">場合によっては、; できるだけ早く対応しますユーザーを使用しているドアや家具として移動可能な barricades Roman 受信の矢印のテンペストに対する防策であるとします。</span><span class="sxs-lookup"><span data-stu-id="22311-177">In some cases, you will want to respond as quickly as possible; say if the user is using doors and furniture as movable barricades in defense against a tempest of incoming Roman arrows.</span></span> <span data-ttu-id="22311-178">それ以外の場合は、する可能性がある; の新しい更新プログラムを無視します。floor、holographic スポーツ カー レースの周りを促進できない可能性がありますが突然あなたの愛犬がトラックの途中で配置を決定した場合にとても楽しいからです。</span><span class="sxs-lookup"><span data-stu-id="22311-178">In other cases though, you may want to ignore new updates; driving your holographic sports car around the racetrack on your floor may suddenly not be so fun if your dog decides to sit in the middle of the track.</span></span>

### <a name="navigation"></a><span data-ttu-id="22311-179">ナビゲーション</span><span class="sxs-lookup"><span data-stu-id="22311-179">Navigation</span></span>

<span data-ttu-id="22311-180">アプリケーションでは、holographic の文字 (またはエージェント) は実在の人物と同じ方法で現実の世界を移動するのに機能を許可するのに空間のマッピング データを使用できます。</span><span class="sxs-lookup"><span data-stu-id="22311-180">Applications can use spatial mapping data to grant holographic characters (or agents) the ability to navigate the real world in the same way a real person would.</span></span> <span data-ttu-id="22311-181">こうと、同じユーザーとその友達の自然でなじみのある動作のセットに制限することによって holographic 文字の存在を強調します。</span><span class="sxs-lookup"><span data-stu-id="22311-181">This can help reinforce the presence of holographic characters by restricting them to the same set of natural, familiar behaviors as those of the user and their friends.</span></span>

<span data-ttu-id="22311-182">ナビゲーション機能は、ユーザーにも役立つことがあります。</span><span class="sxs-lookup"><span data-stu-id="22311-182">Navigation capabilities could be useful to users as well.</span></span> <span data-ttu-id="22311-183">ナビゲーションのマップが特定の領域にビルドされたら、その場所に新しいユーザーの未知の holographic の方向を提供する共有でした。</span><span class="sxs-lookup"><span data-stu-id="22311-183">Once a navigation map has been built in a given area, it could be shared to provide holographic directions for new users unfamiliar with that location.</span></span> <span data-ttu-id="22311-184">このマップは、フローを円滑に '歩行者 'トラフィックを保つために、またはサイトの構築のような危険な場所での事故を回避するために設計する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="22311-184">This map could be designed to help keep pedestrian 'traffic' flowing smoothly, or to avoid accidents in dangerous locations like construction sites.</span></span>

<span data-ttu-id="22311-185">ナビゲーション機能の実装に関連するキーの技術的課題をウォークのサーフェス (人間は、テーブルのウォークはありません)。! (人間しない順を追ってドアが閉じられた!) 環境での変更を正常な適応の信頼性の高い検出となります。</span><span class="sxs-lookup"><span data-stu-id="22311-185">The key technical challenges involved in implementing navigation functionality will be reliable detection of walkable surfaces (humans don't walk on tables!) and graceful adaptation to changes in the environment (humans don't walk through closed doors!).</span></span> <span data-ttu-id="22311-186">メッシュには、いくつか必要があります[処理](spatial-mapping.md#mesh-processing)パスの計画と仮想の文字でナビゲーション用に使用する前にします。</span><span class="sxs-lookup"><span data-stu-id="22311-186">The mesh may require some [processing](spatial-mapping.md#mesh-processing) before it is usable for path-planning and navigation by a virtual character.</span></span> <span data-ttu-id="22311-187">メッシュをスムージングおよび hallucinations の削除により、スタックになる文字を避けることができます。</span><span class="sxs-lookup"><span data-stu-id="22311-187">Smoothing the mesh and removing hallucinations may help avoid characters becoming stuck.</span></span> <span data-ttu-id="22311-188">文字のパスの計画およびナビゲーションの計算を高速化するには、メッシュを大幅に簡略化することもできます。</span><span class="sxs-lookup"><span data-stu-id="22311-188">You may also wish to drastically simplify the mesh in order to speed up your character's path-planning and navigation calculations.</span></span> <span data-ttu-id="22311-189">これらの課題がテレビ ゲームのテクノロジの開発に多くの注意を受信し、豊富なこれらのトピックの使用可能な研究文献があります。</span><span class="sxs-lookup"><span data-stu-id="22311-189">These challenges have received a great deal of attention in the development of videogame technology, and there is a wealth of available research literature on these topics.</span></span>

<span data-ttu-id="22311-190">空間マッピング サーフェスと Unity の組み込み NavMesh の機能を使用できないことに注意してください。</span><span class="sxs-lookup"><span data-stu-id="22311-190">Note that the built-in NavMesh functionality in Unity cannot be used with spatial mapping surfaces.</span></span> <span data-ttu-id="22311-191">空間マッピング サーフェスは、アプリケーションまで不明なので、これは事前に資産をソースから生成される NavMesh データ ファイルが必要ですが、起動します。</span><span class="sxs-lookup"><span data-stu-id="22311-191">This is because spatial mapping surfaces are not known until the application starts, whereas NavMesh data files need to be generated from source assets ahead of time.</span></span> <span data-ttu-id="22311-192">空間マッピング システムで提供しないことに注意してください[サーフェスを非常に離れたについて](spatial-mapping-design.md#the-environment-scanning-experience)ユーザーの現在の場所から。</span><span class="sxs-lookup"><span data-stu-id="22311-192">Also note that, the spatial mapping system will not provide [information about surfaces very far away](spatial-mapping-design.md#the-environment-scanning-experience) from the user's current location.</span></span> <span data-ttu-id="22311-193">アプリケーションする必要があります 'ことを思い出してください' サーフェス自体は非常に大きな領域のマップを作成する場合。</span><span class="sxs-lookup"><span data-stu-id="22311-193">So the application must 'remember' surfaces itself if it is to build a map of a very large area.</span></span>

### <a name="visualization"></a><span data-ttu-id="22311-194">視覚エフェクト</span><span class="sxs-lookup"><span data-stu-id="22311-194">Visualization</span></span>

<span data-ttu-id="22311-195">ほとんどの場合、表示する空間のサーフェスに適していますvisual 煩雑さを最小限にし、実際には、世界は、自身の読み上げます。</span><span class="sxs-lookup"><span data-stu-id="22311-195">Most of the time it is appropriate for spatial surfaces to be invisible; to minimize visual clutter and let the real world speak for itself.</span></span> <span data-ttu-id="22311-196">場合もありますが、実際の対応は既に表示されているにもかかわらず空間マッピングのサーフェスを直接、視覚化すると便利です。</span><span class="sxs-lookup"><span data-stu-id="22311-196">However, sometimes it is useful to visualize spatial mapping surfaces directly, despite the fact that their real-world counterparts are already visible.</span></span>

<span data-ttu-id="22311-197">ホログラム (配置 holographic キャビネット、壁になど) を表面に配置する、ユーザーが試みているときになど、画面上に影をキャストすることによって、ホログラムが 'アース' 立つことができます。</span><span class="sxs-lookup"><span data-stu-id="22311-197">For example, when the user is trying to place a hologram onto a surface (placing a holographic cabinet on the wall, say) it can be useful to 'ground' the hologram by casting a shadow onto the surface.</span></span> <span data-ttu-id="22311-198">これにより、ユーザーはわかりやすく納得ホログラムと、画面間の正確な物理的近接の。</span><span class="sxs-lookup"><span data-stu-id="22311-198">This gives the user a much clearer sense of the exact physical proximity between the hologram and the surface.</span></span> <span data-ttu-id="22311-199">これは、視覚的に 'プレビューの' を変更して、ユーザーがコミットする前より一般的なプラクティスの例でも。</span><span class="sxs-lookup"><span data-stu-id="22311-199">This is also an example of the more general practice of visually 'previewing' a change before the user commits to it.</span></span>

<span data-ttu-id="22311-200">サーフェスを視覚化することで、アプリケーションは、環境の内容を理解、ユーザーと共有できます。</span><span class="sxs-lookup"><span data-stu-id="22311-200">By visualizing surfaces, the application can share with the user its understanding of the environment.</span></span> <span data-ttu-id="22311-201">たとえばの holographic ボード ゲームは、ユーザーが対話する必要があります出るを認識できるようになどに、'テーブル' として特定された水平方向のサーフェスを視覚化します。</span><span class="sxs-lookup"><span data-stu-id="22311-201">For example, a holographic board game could visualize the horizontal surfaces that it has identified as 'tables', so the user knows where they should go to interact.</span></span>

<span data-ttu-id="22311-202">サーフェスを視覚化すると、近くの非表示にスペースをユーザーに表示する便利な方法を指定できます。</span><span class="sxs-lookup"><span data-stu-id="22311-202">Visualizing surfaces can be a useful way to show the user nearby spaces that are hidden from view.</span></span> <span data-ttu-id="22311-203">リビング ルーム、キッチン (とすべての包含ホログラムの) にユーザー アクセスを付与する簡単な方法を提供できます。</span><span class="sxs-lookup"><span data-stu-id="22311-203">This could provide a simple way to give the user access to their kitchen (and all of its contained holograms) from their living room.</span></span>

<span data-ttu-id="22311-204">空間マッピングによって提供される表面メッシュは、特に 'クリーン' できない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="22311-204">The surface meshes provided by spatial mapping may not be particularly 'clean'.</span></span> <span data-ttu-id="22311-205">そのためそれらを適切に視覚化する重要なは。</span><span class="sxs-lookup"><span data-stu-id="22311-205">Thus it is important to visualize them appropriately.</span></span> <span data-ttu-id="22311-206">従来のライティング計算が、視覚的に見ればよい方法での表面法線のエラーを選択するには、「クリーン」テクスチャが、画面に投影するのにして外観を若干見やすくしています中します。</span><span class="sxs-lookup"><span data-stu-id="22311-206">Traditional lighting calculations may highlight errors in surface normals in a visually distracting manner, whilst 'clean' textures projected onto the surface may help to give it a tidier appearance.</span></span> <span data-ttu-id="22311-207">実行することも[メッシュ処理](spatial-mapping.md#mesh-processing)サーフェスがレンダリングされる前に、メッシュのプロパティを向上させるためにします。</span><span class="sxs-lookup"><span data-stu-id="22311-207">It is also possible to perform [mesh processing](spatial-mapping.md#mesh-processing) to improve mesh properties, before the surfaces are rendered.</span></span>

## <a name="using-the-surface-observer"></a><span data-ttu-id="22311-208">画面のオブザーバーを使用します。</span><span class="sxs-lookup"><span data-stu-id="22311-208">Using The Surface Observer</span></span>

<span data-ttu-id="22311-209">空間マッピングの開始点は、画面のオブザーバーです。</span><span class="sxs-lookup"><span data-stu-id="22311-209">The starting point for spatial mapping is the surface observer.</span></span> <span data-ttu-id="22311-210">プログラム フローは次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="22311-210">Program flow is as follows:</span></span>
* <span data-ttu-id="22311-211">画面のオブザーバー オブジェクトを作成します。</span><span class="sxs-lookup"><span data-stu-id="22311-211">Create a surface observer object</span></span>
   * <span data-ttu-id="22311-212">空間マッピング データを受信するアプリケーションが望んでいる関心のある領域を定義する、1 つまたは複数の空間ボリュームを提供します。</span><span class="sxs-lookup"><span data-stu-id="22311-212">Provide one or more spatial volumes, to define the regions of interest in which the application wishes to receive spatial mapping data.</span></span> <span data-ttu-id="22311-213">空間ボリュームとは、球または直方体などの領域の領域を定義する図形だけです。</span><span class="sxs-lookup"><span data-stu-id="22311-213">A spatial volume is simply a shape defining a region of space, such as a sphere or a box.</span></span>
   * <span data-ttu-id="22311-214">世界がロックされている空間座標システムで空間ボリュームを使用すると、物理世界の固定領域を識別できます。</span><span class="sxs-lookup"><span data-stu-id="22311-214">Use a spatial volume with a world-locked spatial coordinate system to identify a fixed region of the physical world.</span></span>
   * <span data-ttu-id="22311-215">空間ボリュームは、更新された各フレームの本文がロックされている空間座標系、領域を移動します (ただし、回転しません) の領域を識別するユーザーとを使用します。</span><span class="sxs-lookup"><span data-stu-id="22311-215">Use a spatial volume, updated each frame with a body-locked spatial coordinate system, to identify a region of space that moves (but does not rotate) with the user.</span></span>
   * <span data-ttu-id="22311-216">これらの空間ボリュームは、後で、アプリケーションまたはユーザーの変更の状態として、いつでも変更できます。</span><span class="sxs-lookup"><span data-stu-id="22311-216">These spatial volumes may be changed later at any time, as the status of the application or the user changes.</span></span>
* <span data-ttu-id="22311-217">ポーリングまたは通知を使用して、情報空間のサーフェスを取得するには</span><span class="sxs-lookup"><span data-stu-id="22311-217">Use polling or notification to retrieve information about spatial surfaces</span></span>
   * <span data-ttu-id="22311-218">可能性があります 'ポーリングを続けた' 空間表面の状態のサーフェスのオブザーバー、いつでもできます。</span><span class="sxs-lookup"><span data-stu-id="22311-218">You may 'poll' the surface observer for spatial surface status at any time.</span></span> <span data-ttu-id="22311-219">代わりに、空間サーフェスが変更されたときに、アプリケーションを通知する表面オブザーバーの 'サーフェスが変更された' イベント、登録可能性があります。</span><span class="sxs-lookup"><span data-stu-id="22311-219">Alternatively, you may register for the surface observer's 'surfaces changed' event, which will notify the application when spatial surfaces have changed.</span></span>
   * <span data-ttu-id="22311-220">視錐台などの動的な空間ボリュームまたは本文ロックされたボリュームは、アプリケーションは、関心のある領域を設定し、空間のサーフェスの現在のセットを取得し、各フレームの変更をポーリングする必要があります。</span><span class="sxs-lookup"><span data-stu-id="22311-220">For a dynamic spatial volume, such as the view frustum, or a body-locked volume, applications will need to poll for changes each frame by setting the region of interest and then obtaining the current set of spatial surfaces.</span></span>
   * <span data-ttu-id="22311-221">1 つの部屋をカバーする世界ロックされているキューブなどの静的なボリュームのアプリケーションはそのボリューム内の空間のサーフェスを変更したときに通知する 'サーフェスが変更された' イベント登録可能性があります。</span><span class="sxs-lookup"><span data-stu-id="22311-221">For a static volume, such as a world-locked cube covering a single room, applications may register for the 'surfaces changed' event to be notified when spatial surfaces inside that volume may have changed.</span></span>
* <span data-ttu-id="22311-222">プロセスのサーフェスの変更</span><span class="sxs-lookup"><span data-stu-id="22311-222">Process surfaces changes</span></span>
   * <span data-ttu-id="22311-223">空間表面の指定されたセットを反復処理します。</span><span class="sxs-lookup"><span data-stu-id="22311-223">Iterate the provided set of spatial surfaces.</span></span>
   * <span data-ttu-id="22311-224">変更または削除として、追加の空間サーフェスを分類します。</span><span class="sxs-lookup"><span data-stu-id="22311-224">Classify spatial surfaces as added, changed or removed.</span></span>
   * <span data-ttu-id="22311-225">該当する場合は、サーフェイスでの各追加または変更された空間、詳細の必要なレベルで、画面の現在の状態を示す更新されたメッシュを受信する非同期要求を送信します。</span><span class="sxs-lookup"><span data-stu-id="22311-225">For each added or changed spatial surface, if appropriate submit an asynchronous request to receive updated mesh representing the surface's current state at the desired level of detail.</span></span>
* <span data-ttu-id="22311-226">非同期のメッシュ要求 (次のセクションで詳細) を処理します。</span><span class="sxs-lookup"><span data-stu-id="22311-226">Process the asynchronous mesh request (more details in following sections).</span></span>

## <a name="mesh-caching"></a><span data-ttu-id="22311-227">キャッシュをメッシュします。</span><span class="sxs-lookup"><span data-stu-id="22311-227">Mesh Caching</span></span>

<span data-ttu-id="22311-228">空間のサーフェスは、高密度の三角形メッシュで表されます。</span><span class="sxs-lookup"><span data-stu-id="22311-228">Spatial surfaces are represented by dense triangle meshes.</span></span> <span data-ttu-id="22311-229">大量のコンピューティングとストレージ リソースを使用できるは、格納、表示、およびこれらのメッシュを処理します。</span><span class="sxs-lookup"><span data-stu-id="22311-229">Storing, rendering and processing these meshes can consume significant computational and storage resources.</span></span> <span data-ttu-id="22311-230">そのため、各アプリケーションはキャッシュ スキームをメッシュの処理と保存に使用されるリソースを最小限に抑えるために、ニーズに適切なメッシュを採用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="22311-230">As such, each application should adopt a mesh caching scheme appropriate to its needs, in order to minimize the resources used for mesh processing and storage.</span></span> <span data-ttu-id="22311-231">このスキームでは、するメッシュを保持して、破棄するだけでなく各空間のサーフェスのメッシュを更新するタイミングを判断します。</span><span class="sxs-lookup"><span data-stu-id="22311-231">This scheme should determine which meshes to retain and which to discard, as well as when to update the mesh for each spatial surface.</span></span>

<span data-ttu-id="22311-232">どのように、アプリケーションがキャッシュのメッシュを対応する必要がありますが説明する考慮事項の多くは直接通知します。</span><span class="sxs-lookup"><span data-stu-id="22311-232">Many of the considerations discussed there will directly inform how your application should approach mesh caching.</span></span> <span data-ttu-id="22311-233">環境のユーザーの移動、ために必要なサーフェス、異なるサーフェスが発生する場合、環境の変更をキャプチャするかを検討してください。</span><span class="sxs-lookup"><span data-stu-id="22311-233">You should consider how the user moves through the environment, which surfaces are needed, when different surfaces will be observed and when changes in the environment should be captured.</span></span>

<span data-ttu-id="22311-234">画面のオブザーバーによって提供される 'サーフェス変更' のイベントを解釈するときにキャッシュ ロジックの基本的なメッシュのとおりです。</span><span class="sxs-lookup"><span data-stu-id="22311-234">When interpreting the 'surfaces changed' event provided by the surface observer, the basic mesh caching logic is as follows:</span></span>
* <span data-ttu-id="22311-235">アプリケーションからは、以前に参照しない空間表面 ID は、新しい空間画面として扱う、この必要があります。</span><span class="sxs-lookup"><span data-stu-id="22311-235">If the application sees a spatial surface ID that it has not seen before, it should treat this as a new spatial surface.</span></span>
* <span data-ttu-id="22311-236">アプリケーションから新しい更新時刻が既知の ID での空間画面は、更新の空間画面として扱う、この必要があります。</span><span class="sxs-lookup"><span data-stu-id="22311-236">If the application sees a spatial surface with a known ID but with a new update time, it should treat this as an updated spatial surface.</span></span>
* <span data-ttu-id="22311-237">アプリケーションでは、既知の ID を持つ空間画面が表示されないは、削除空間画面として扱う、この必要があります。</span><span class="sxs-lookup"><span data-stu-id="22311-237">If the application no longer sees a spatial surface with a known ID, it should treat this as a removed spatial surface.</span></span>

<span data-ttu-id="22311-238">各アプリケーションを次の選択肢を加えることは。</span><span class="sxs-lookup"><span data-stu-id="22311-238">It is up to each application to then make the following choices:</span></span>
* <span data-ttu-id="22311-239">新しい空間サーフェスでは、メッシュを要求することですか。</span><span class="sxs-lookup"><span data-stu-id="22311-239">For new spatial surfaces, should mesh be requested?</span></span>
   * <span data-ttu-id="22311-240">一般にメッシュは、新しい空間サーフェスは、ユーザーに役立つ新しい情報が示されていますすぐに要求する必要があります。</span><span class="sxs-lookup"><span data-stu-id="22311-240">Generally mesh should be requested immediately for new spatial surfaces, which may provide useful new information to the user.</span></span>
   * <span data-ttu-id="22311-241">ただし、新しい空間のサーフェスとも、ユーザーの近くに優先度を指定する必要があります、そのメッシュを最初に要求する必要があります。</span><span class="sxs-lookup"><span data-stu-id="22311-241">However, new spatial surfaces near and in front of the user should be given priority and their mesh should be requested first.</span></span>
   * <span data-ttu-id="22311-242">新しいメッシュが必要でない場合、固定されている場合など、アプリケーションが永続的または一時的に' ' 環境のモデル、しにする必要がありますいないに必要です。</span><span class="sxs-lookup"><span data-stu-id="22311-242">If the new mesh is not needed, if for example the application has permanently or temporarily 'frozen' its model of the environment, then it should not be requested.</span></span>
* <span data-ttu-id="22311-243">更新された空間サーフェスでは、メッシュを要求することですか。</span><span class="sxs-lookup"><span data-stu-id="22311-243">For updated spatial surfaces, should mesh be requested?</span></span>
   * <span data-ttu-id="22311-244">更新された空間のサーフェスとも、ユーザーの近くに優先度を指定する必要があり、そのメッシュを最初に要求する必要があります。</span><span class="sxs-lookup"><span data-stu-id="22311-244">Updated spatial surfaces near and in front of the user should be given priority and their mesh should be requested first.</span></span>
   * <span data-ttu-id="22311-245">特にスキャン操作中に、サーフェスを更新するよりも新しい画面を優先的に適切な場合があります。</span><span class="sxs-lookup"><span data-stu-id="22311-245">It may also be appropriate to give higher priority to new surfaces than to updated surfaces, especially during the scanning experience.</span></span>
   * <span data-ttu-id="22311-246">処理コストを制限するには、アプリケーションを空間のサーフェスを更新する処理率を調整する必要があります。</span><span class="sxs-lookup"><span data-stu-id="22311-246">To limit processing costs, applications may wish to throttle the rate at which they process updates to spatial surfaces.</span></span>
   * <span data-ttu-id="22311-247">空間画面への変更はマイナー番号、たとえば、画面の境界は小さく、その場合、更新できない可能性がありますプロセスに十分な重要なことを推測できる場合があります。</span><span class="sxs-lookup"><span data-stu-id="22311-247">It may be possible to infer that changes to a spatial surface are minor, for example if the bounds of the surface are small, in which case the update may not be important enough to process.</span></span>
   * <span data-ttu-id="22311-248">ここではありますが、画面のオブザーバーによって使用空間外接するボリュームを変更する方が効率的に現在のユーザーの関心領域の外側の空間のサーフェスの更新プログラムは完全に無視できます。</span><span class="sxs-lookup"><span data-stu-id="22311-248">Updates to spatial surfaces outside the current region of interest of the user may be ignored entirely, though in this case it may be more efficient to modify the spatial bounding volumes in use by the surface observer.</span></span>
* <span data-ttu-id="22311-249">削除された空間サーフェスでは、メッシュを破棄しますか。</span><span class="sxs-lookup"><span data-stu-id="22311-249">For removed spatial surfaces, should mesh be discarded?</span></span>
   * <span data-ttu-id="22311-250">一般にメッシュを破棄するすぐに削除された空間サーフェスでは、ホログラム遮蔽が正しいままように。</span><span class="sxs-lookup"><span data-stu-id="22311-250">Generally mesh should be discarded immediately for removed spatial surfaces, so that hologram occlusion remains correct.</span></span>
   * <span data-ttu-id="22311-251">ただし、アプリケーションにすると信じている理由がある場合空間画面は再表示すぐ (おそらくに基づいてユーザー エクスペリエンスの設計)、そのメッシュを破棄および後でもう一度再作成するよりも保持するより効率的な場合があります。</span><span class="sxs-lookup"><span data-stu-id="22311-251">However, if the application has reason to believe that a spatial surface will reappear shortly (perhaps based upon the design of the user experience), then it may be more efficient to retain it than to discard its mesh and recreate it again later.</span></span>
   * <span data-ttu-id="22311-252">場合は、アプリケーションをビルドして、ユーザーの環境の大規模なモデルは、まったく任意のメッシュを破棄する可能性がありますされません。</span><span class="sxs-lookup"><span data-stu-id="22311-252">If the application is building a large-scale model of the user's environment then it may not wish to discard any meshes at all.</span></span> <span data-ttu-id="22311-253">リソース使用率を制限、可能性がありますをディスクにスプール メッシュによって空間のサーフェスに表示されなくなると、必要があります。</span><span class="sxs-lookup"><span data-stu-id="22311-253">It will still need to limit resource usage though, possibly by spooling meshes to disk as spatial surfaces disappear.</span></span>
   * <span data-ttu-id="22311-254">空間表面の生成中に一部の比較的まれなイベントは、同様の場所が異なる Id の新しい空間サーフェスによって置き換えられる空間のサーフェスを引き起こす可能性のあるに注意してください。</span><span class="sxs-lookup"><span data-stu-id="22311-254">Note that some relatively rare events during spatial surface generation can cause spatial surfaces to be replaced by new spatial surfaces in a similar location but with different IDs.</span></span> <span data-ttu-id="22311-255">その結果、アプリケーションが削除されたサーフェイスを破棄しないように選択する必要があることに注意終了を複数高オーバー ラップした空間表面メッシュを同じ場所をカバーします。</span><span class="sxs-lookup"><span data-stu-id="22311-255">Consequently, applications that choose not to discard a removed surface should take care not to end up with multiple highly-overlapped spatial surface meshes covering the same location.</span></span>
* <span data-ttu-id="22311-256">その他の任意の空間のサーフェスのメッシュを破棄しますか。</span><span class="sxs-lookup"><span data-stu-id="22311-256">Should mesh be discarded for any other spatial surfaces?</span></span>
   * <span data-ttu-id="22311-257">破棄する必要がありますしはユーザーのエクスペリエンスを使用しない場合、空間のサーフェスが存在します中でも。</span><span class="sxs-lookup"><span data-stu-id="22311-257">Even while a spatial surface exists, if it is no longer useful to the user's experience then it should be discarded.</span></span> <span data-ttu-id="22311-258">たとえば場合アプリケーション '置き換えます' 戸口の相手側に空き領域別の仮想空間、ルーム内の空間のサーフェス不要になった関係します。</span><span class="sxs-lookup"><span data-stu-id="22311-258">For example, if the application 'replaces' the room on the other side of a doorway with an alternate virtual space then the spatial surfaces in that room no longer matter.</span></span>

<span data-ttu-id="22311-259">次に、例メッシュ キャッシュ戦略、空間、および時間的なヒステリシスを使用してを示します。</span><span class="sxs-lookup"><span data-stu-id="22311-259">Here is an example mesh caching strategy, using spatial and temporal hysteresis:</span></span>
* <span data-ttu-id="22311-260">ユーザーの視線の先に依存して、少し調べてみるし、歩き回り関心のある視錐台の形の空間ボリュームを使用するアプリケーションを検討してください。</span><span class="sxs-lookup"><span data-stu-id="22311-260">Consider an application that wishes to use a frustum-shaped spatial volume of interest that follows the user's gaze as they look around and walk around.</span></span>
* <span data-ttu-id="22311-261">空間画面に表示されなく一時的にこのボリュームだけです、画面からを表示またはから出るの手順をさらにしています.振り返るにのみまたは近いもう一度少し後でに移動します。</span><span class="sxs-lookup"><span data-stu-id="22311-261">A spatial surface may disappear temporarily from this volume simply because the user looks away from the surface or steps further away from it... only to look back or moves closer again a moment later.</span></span> <span data-ttu-id="22311-262">この場合を破棄し、この画面のメッシュを再作成は、多くの冗長な処理を表します。</span><span class="sxs-lookup"><span data-stu-id="22311-262">In this case, discarding and re-creating the mesh for this surface represents a lot of redundant processing.</span></span>
* <span data-ttu-id="22311-263">処理された変更の数を減らすためには、アプリケーションは、2 つ空間表面のオブザーバーを他の内に含まれるいずれかを使用します。</span><span class="sxs-lookup"><span data-stu-id="22311-263">To reduce the number of changes processed, the application uses two spatial surface observers, one contained within the other.</span></span> <span data-ttu-id="22311-264">大きなボリュームが球とユーザーを '遅延;' に従いますまた、2.0 メートル ユーザー内でそのセンターがあることを確認するために必要なときにだけ移動します。</span><span class="sxs-lookup"><span data-stu-id="22311-264">The larger volume is spherical and follows the user 'lazily'; it only moves when necessary to ensure that its centre is within 2.0 metres of the user.</span></span>
* <span data-ttu-id="22311-265">新規および更新された空間表面メッシュは常より小さな内部 surface、オブザーバーから処理が、メッシュがより大きな外部サーフェス オブザーバーこれらされなくなるまでにキャッシュされます。</span><span class="sxs-lookup"><span data-stu-id="22311-265">New and updated spatial surface meshes are always processed from the smaller inner surface observer, but meshes are cached until they disappear from the larger outer surface observer.</span></span> <span data-ttu-id="22311-266">これにより、ローカル ユーザーの移動のための多くの冗長な変更の処理を回避するためにアプリケーションができます。</span><span class="sxs-lookup"><span data-stu-id="22311-266">This allows the application to avoid processing many redundant changes due to local user movement.</span></span>
* <span data-ttu-id="22311-267">空間画面は、損失の追跡のため一時的に消えるもことがあります、ため、アプリケーションも損失の追跡中に破棄の削除された空間サーフェスを延期します。</span><span class="sxs-lookup"><span data-stu-id="22311-267">Since a spatial surface may also disappear temporarily due to tracking loss, the application also defers discarding removed spatial surfaces during tracking loss.</span></span>
* <span data-ttu-id="22311-268">一般に、アプリケーションでは、削減更新処理とその最適なキャッシュ戦略を決定する増加したメモリの使用状況のトレードオフを評価する必要があります。</span><span class="sxs-lookup"><span data-stu-id="22311-268">In general, an application should evaluate the tradeoff between reduced update processing and increased memory usage to determine its ideal caching strategy.</span></span>

## <a name="rendering"></a><span data-ttu-id="22311-269">表示</span><span class="sxs-lookup"><span data-stu-id="22311-269">Rendering</span></span>

<span data-ttu-id="22311-270">レンダリングに使用する空間マッピング メッシュ傾向がある 3 つの主な方法はあります。</span><span class="sxs-lookup"><span data-stu-id="22311-270">There are three primary ways in which spatial mapping meshes tend to be used for rendering:</span></span>
* <span data-ttu-id="22311-271">画面の視覚化</span><span class="sxs-lookup"><span data-stu-id="22311-271">For surface visualization</span></span>
   * <span data-ttu-id="22311-272">空間のサーフェスを直接視覚化すると便利です。</span><span class="sxs-lookup"><span data-stu-id="22311-272">It is often useful to visualize spatial surfaces directly.</span></span> <span data-ttu-id="22311-273">たとえば、サーフェイス ホログラムを配置するときに、キャスト 'shadows' を空間表面にオブジェクトからは便利な視覚的なフィードバックをユーザーに提供できます。</span><span class="sxs-lookup"><span data-stu-id="22311-273">For example, casting 'shadows' from objects onto spatial surfaces can provide helpful visual feedback to the user while they are placing holograms on surfaces.</span></span>
   * <span data-ttu-id="22311-274">留意すべき 1 つは、空間メッシュが 3D アーティストを作成するメッシュの種類に異なることです。</span><span class="sxs-lookup"><span data-stu-id="22311-274">One thing to bear in mind is that spatial meshes are different to the kind of meshes that a 3D artist might create.</span></span> <span data-ttu-id="22311-275">三角形のトポロジは、人間が作成したトポロジとして 'クリーン' とできないし、メッシュがから低下[さまざまなエラー](spatial-mapping-design.md#what-influences-spatial-mapping-quality)します。</span><span class="sxs-lookup"><span data-stu-id="22311-275">The triangle topology will not be as 'clean' as human-created topology, and the mesh will suffer from [various errors](spatial-mapping-design.md#what-influences-spatial-mapping-quality).</span></span>
   * <span data-ttu-id="22311-276">楽しませる visual 美学上を作成するために可能性がありますのでを実行するいくつか[メッシュ処理](spatial-mapping.md#mesh-processing)塗りつぶし穴、または滑らかな表面の法線などにします。</span><span class="sxs-lookup"><span data-stu-id="22311-276">In order to create a pleasing visual aesthetic, you may thus want to perform some [mesh processing](spatial-mapping.md#mesh-processing), for example to fill holes or smooth surface normals.</span></span> <span data-ttu-id="22311-277">直接メッシュ トポロジおよび normals の視覚化ではなく、メッシュにプロジェクトのアーティストが設計したテクスチャをシェーダーを使用することがあります。</span><span class="sxs-lookup"><span data-stu-id="22311-277">You may also wish to use a shader to project artist-designed textures onto your mesh instead of directly visualizing mesh topology and normals.</span></span>
* <span data-ttu-id="22311-278">ホログラム現実世界のサーフェスの背後にある他の</span><span class="sxs-lookup"><span data-stu-id="22311-278">For occluding holograms behind real-world surfaces</span></span>
   * <span data-ttu-id="22311-279">空間のサーフェス レンダリングできる深さ専用パスでのみに影響する、[深度バッファー](https://msdn.microsoft.com/library/windows/desktop/bb219616(v=vs.85).aspx)色のレンダー ターゲットには影響しません。</span><span class="sxs-lookup"><span data-stu-id="22311-279">Spatial surfaces can be rendered in a depth-only pass which only affects the [depth buffer](https://msdn.microsoft.com/library/windows/desktop/bb219616(v=vs.85).aspx) and does not affect color render targets.</span></span>
   * <span data-ttu-id="22311-280">これは、空間のサーフェスの背後にある、その後表示ホログラムが深度バッファーを初期化します。</span><span class="sxs-lookup"><span data-stu-id="22311-280">This primes the depth buffer to occlude subsequently-rendered holograms behind spatial surfaces.</span></span> <span data-ttu-id="22311-281">ホログラムの正確なオクルー ジョン ホログラムが実際には、ユーザーの物理的な空間内に存在するという点が強化されます。</span><span class="sxs-lookup"><span data-stu-id="22311-281">Accurate occlusion of holograms enhances the sense that holograms really exist within the user's physical space.</span></span>
   * <span data-ttu-id="22311-282">深さ専用のレンダリングを有効にする更新のブレンドの状態を設定する、 [RenderTargetWriteMask](https://msdn.microsoft.com/library/windows/desktop/hh404492(v=vs.85).aspx)レンダー ターゲットですべての色を 0 にします。</span><span class="sxs-lookup"><span data-stu-id="22311-282">To enable depth-only rendering, update your blend state to set the [RenderTargetWriteMask](https://msdn.microsoft.com/library/windows/desktop/hh404492(v=vs.85).aspx) to zero for all color render targets.</span></span>
* <span data-ttu-id="22311-283">実際のサーフェスによってオクルー ジョン ホログラムの外観を変更します。</span><span class="sxs-lookup"><span data-stu-id="22311-283">For modifying the appearance of holograms occluded by real-world surfaces</span></span>
   * <span data-ttu-id="22311-284">通常どおりにレンダリングされたジオメトリには、これは、オクルー ジョンされる場合は表示されません。</span><span class="sxs-lookup"><span data-stu-id="22311-284">Normally rendered geometry is hidden when it is occluded.</span></span> <span data-ttu-id="22311-285">これで、深度関数の設定で実現されます、[深度ステンシルの状態](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx)に「以下」、それが原因でジオメトリを表示するがある場合は**近い**よりも前に表示されるすべてのカメラにジオメトリ。</span><span class="sxs-lookup"><span data-stu-id="22311-285">This is achieved by setting the depth function in your [depth-stencil state](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx) to "less than or equal", which causes geometry to be visible only where it is **closer** to the camera than all previously rendered geometry.</span></span>
   * <span data-ttu-id="22311-286">ただし、オクルー ジョンすると場合でも特定のジオメトリを表示したままにし、ユーザーに視覚的なフィードバックを提供する手段としてオクルー ジョンとは、その外観を変更する便利な場合があります。</span><span class="sxs-lookup"><span data-stu-id="22311-286">However, it may be useful to keep certain geometry visible even when it is occluded, and to modify its appearance when occluded as a way of providing visual feedback to the user.</span></span> <span data-ttu-id="22311-287">たとえば、これにより、実際の画面の背後にあるユーザーが明確になりますを行って間オブジェクトの場所を表示するアプリケーションです。</span><span class="sxs-lookup"><span data-stu-id="22311-287">For example, this allows the application to show the user the location of an object whilst making it clear that is behind a real-world surface.</span></span>
   * <span data-ttu-id="22311-288">これを実現するには、2 回目に必要な '閉塞' 外観を作成するさまざまなシェーダー、ジオメトリをレンダリングします。</span><span class="sxs-lookup"><span data-stu-id="22311-288">To achieve this, render the geometry a second time with a different shader that creates the desired 'occluded' appearance.</span></span> <span data-ttu-id="22311-289">2 回目のジオメトリを表示する前に 2 つの変更を行う、[深度ステンシルの状態](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx)します。</span><span class="sxs-lookup"><span data-stu-id="22311-289">Before rendering the geometry for the second time, make two changes to your [depth-stencil state](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx).</span></span> <span data-ttu-id="22311-290">まず、深度関数を「より大きいまたは等しい」に設定できるように、ジオメトリ表示がある場合は**さらに**すべて以前にレンダリングされるジオメトリは、カメラから。</span><span class="sxs-lookup"><span data-stu-id="22311-290">First, set the depth function to "greater than or equal" so that the geometry will be visible only where it is **further** from the camera than all previously rendered geometry.</span></span> <span data-ttu-id="22311-291">0 に、深度バッファーは変更しないように、DepthWriteMask を次に、設定 (ジオメトリの深さを表す、深度バッファーを続行する必要があります**最も近い**カメラに)。</span><span class="sxs-lookup"><span data-stu-id="22311-291">Second, set the DepthWriteMask to zero, so that the depth buffer will not be modified (the depth buffer should continue to represent the depth of the geometry **closest** to the camera).</span></span>

<span data-ttu-id="22311-292">[パフォーマンス](understanding-performance-for-mixed-reality.md)空間マッピングのメッシュをレンダリングするときに、重要な懸念事項は、します。</span><span class="sxs-lookup"><span data-stu-id="22311-292">[Performance](understanding-performance-for-mixed-reality.md) is an important concern when rendering spatial mapping meshes.</span></span> <span data-ttu-id="22311-293">空間マッピングのメッシュをレンダリングする特定のレンダリング パフォーマンス テクニックを次に示します。</span><span class="sxs-lookup"><span data-stu-id="22311-293">Here are some rendering performance techniques specific to rendering spatial mapping meshes:</span></span>
* <span data-ttu-id="22311-294">三角形の密度を調整します。</span><span class="sxs-lookup"><span data-stu-id="22311-294">Adjust triangle density</span></span>
   * <span data-ttu-id="22311-295">要求元の空間画面は、surface、オブザーバーからメッシュ、お客様のニーズにとって有益な三角形メッシュの最も低い密度を要求します。</span><span class="sxs-lookup"><span data-stu-id="22311-295">When requesting spatial surface meshes from your surface observer, request the lowest density of triangle meshes that will suffice for your needs.</span></span>
   * <span data-ttu-id="22311-296">合理的です、ユーザーからのサーフェスの距離に応じての画面で画面ごとに密度を三角形を変更して、ユーザー エクスペリエンスに関連します。</span><span class="sxs-lookup"><span data-stu-id="22311-296">It may make sense to vary triangle density on a surface by surface basis, depending on the surface's distance from the user, and its relevance to the user experience.</span></span>
   * <span data-ttu-id="22311-297">削減三角形の数は、ピクセル処理コストは変わりませんがメモリ使用量と、GPU で頂点処理コストを削減するは。</span><span class="sxs-lookup"><span data-stu-id="22311-297">Reducing triangle counts will reduce memory usage and vertex processing costs on the GPU, though it will not affect pixel processing costs.</span></span>
* <span data-ttu-id="22311-298">カリングの視錐台を実行します。</span><span class="sxs-lookup"><span data-stu-id="22311-298">Perform frustum culling</span></span>
   * <span data-ttu-id="22311-299">視錐台カリング現在ディスプレイの視錐台の外側にあるために表示できません描画オブジェクトをスキップします。</span><span class="sxs-lookup"><span data-stu-id="22311-299">Frustum culling skips drawing objects that cannot be seen because they are outside the current display frustum.</span></span> <span data-ttu-id="22311-300">これには、CPU と GPU の両方の処理コストが削減されます。</span><span class="sxs-lookup"><span data-stu-id="22311-300">This reduces both CPU and GPU processing costs.</span></span>
   * <span data-ttu-id="22311-301">カリングは、メッシュの単位で実行空間のサーフェスが大きくなるので、各空間表面メッシュを小さなチャンクに分割が原因でより効率的なカリング (このな少なくオフスクリーン三角形がレンダリングされる)。</span><span class="sxs-lookup"><span data-stu-id="22311-301">Since culling is performed on a per-mesh basis and spatial surfaces can be large, breaking each spatial surface mesh into smaller chunks may result in more efficient culling (in that fewer offscreen triangles are rendered).</span></span> <span data-ttu-id="22311-302">ただし; は、トレードオフがあります。ある複数のメッシュは、複数描画呼び出しおく必要があります、CPU コストを向上させることができます。</span><span class="sxs-lookup"><span data-stu-id="22311-302">There is a tradeoff, however; the more meshes you have, the more draw calls you must make, which can increase CPU costs.</span></span> <span data-ttu-id="22311-303">極端な場合、自体の計算をカリングの視錐台はコスト測定可能な CPU のもができます。</span><span class="sxs-lookup"><span data-stu-id="22311-303">In an extreme case, the frustum culling calculations themselves could even have a measurable CPU cost.</span></span>
* <span data-ttu-id="22311-304">レンダリング順序を調整します。</span><span class="sxs-lookup"><span data-stu-id="22311-304">Adjust rendering order</span></span>
   * <span data-ttu-id="22311-305">空間のサーフェスは、ユーザーの周囲に環境全体を表すために大きくなる傾向があります。</span><span class="sxs-lookup"><span data-stu-id="22311-305">Spatial surfaces tend to be large, because they represent the user's entire environment surrounding them.</span></span> <span data-ttu-id="22311-306">ピクセル処理は GPU でコストが特に場合に、高できるため (空間サーフェスとその他のホログラムの両方を含む)、表示されている座標の 1 つ以上のレイヤーがあります。</span><span class="sxs-lookup"><span data-stu-id="22311-306">Pixel processing costs on the GPU can thus be high, especially in cases where there is more than one layer of visible geometry (including both spatial surfaces and other holograms).</span></span> <span data-ttu-id="22311-307">この場合、ユーザーに最も近いレイヤーがする occluding のレイヤーをさらに、ためより離れているレイヤーのレンダリング費やされる GPU 時間を浪費します。</span><span class="sxs-lookup"><span data-stu-id="22311-307">In this case, the layer nearest to the user will be occluding any layers further away, so any GPU time spent rendering those more distant layers is wasted.</span></span>
   * <span data-ttu-id="22311-308">GPU 上でこの冗長な作業を減らすためには、前から後ろの順序で不透明な画面を表示するために役立ちます (詳細の最後の 1 つより離れているもの)。</span><span class="sxs-lookup"><span data-stu-id="22311-308">To reduce this redundant work on the GPU, it helps to render opaque surfaces in front-to-back order (closer ones first, more distant ones last).</span></span> <span data-ttu-id="22311-309">'Opaque' 意味のいずれかに設定されて、DepthWriteMask サーフェス、[深度ステンシルの状態](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx)します。</span><span class="sxs-lookup"><span data-stu-id="22311-309">By 'opaque' we mean surfaces for which the DepthWriteMask is set to one in your [depth-stencil state](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx).</span></span> <span data-ttu-id="22311-310">最も近いサーフェスが表示されると、遠くの表面が GPU でピクセル プロセッサによって効率的にスキップされるように、深度バッファーを準備、されます。</span><span class="sxs-lookup"><span data-stu-id="22311-310">When the nearest surfaces are rendered, they will prime the depth buffer so that more distant surfaces are efficiently skipped by the pixel processor on the GPU.</span></span>

## <a name="mesh-processing"></a><span data-ttu-id="22311-311">メッシュの処理</span><span class="sxs-lookup"><span data-stu-id="22311-311">Mesh Processing</span></span>

<span data-ttu-id="22311-312">アプリケーションが実行する[さまざまな操作](spatial-mapping.md#mesh-processing)そのニーズに合わせて表面メッシュの空間にします。</span><span class="sxs-lookup"><span data-stu-id="22311-312">An application may want to perform [various operations](spatial-mapping.md#mesh-processing) on spatial surface meshes to suit its needs.</span></span> <span data-ttu-id="22311-313">各空間表面メッシュで提供されるインデックスと頂点のデータと同じ使い慣れたレイアウトを使用して、[頂点バッファーとインデックス バッファー](https://msdn.microsoft.com/library/windows/desktop/bb147325%28v=vs.85%29.aspx)すべて最新レンダリング Api で三角形メッシュをレンダリングするために使用されます。</span><span class="sxs-lookup"><span data-stu-id="22311-313">The index and vertex data provided with each spatial surface mesh uses the same familiar layout as the [vertex and index buffers](https://msdn.microsoft.com/library/windows/desktop/bb147325%28v=vs.85%29.aspx) that are used for rendering triangle meshes in all modern rendering APIs.</span></span> <span data-ttu-id="22311-314">ただし、1 つ注意すべき重要なことは、三角形の空間マッピングがあること、**前面に時計回りにワインディングの順序**します。</span><span class="sxs-lookup"><span data-stu-id="22311-314">However, one key fact to be aware of is that spatial mapping triangles have a **front-clockwise winding order**.</span></span> <span data-ttu-id="22311-315">各三角形はメッシュのインデックス バッファー内の 3 つの頂点インデックスによって表され、これらのインデックス内の三角形の頂点を識別、**時計回り**から三角形を表示するときの順序、**前面**側です。</span><span class="sxs-lookup"><span data-stu-id="22311-315">Each triangle is represented by three vertex indices in the mesh's index buffer and these indices will identify the triangle's vertices in a **clockwise** order, when the triangle is viewed from the **front** side.</span></span> <span data-ttu-id="22311-316">前面側 (または外部) 空間表面メッシュの現実の世界のサーフェスの (表示) の前面に期待どおりに対応します。</span><span class="sxs-lookup"><span data-stu-id="22311-316">The front side (or outside) of spatial surface meshes corresponds as you would expect to the front (visible) side of real world surfaces.</span></span>

<span data-ttu-id="22311-317">アプリケーションには、メッシュの単純化サーフェスのオブザーバーによって提供される最も粗い三角形の密度はまだが不十分な粗い - この作業は計算コストが高い場合と、さまざまなを生成するランタイムによって既に実行されているのみを実行する必要があります。詳細レベルを提供します。</span><span class="sxs-lookup"><span data-stu-id="22311-317">Applications should only perform mesh simplification if the coarsest triangle density provided by the surface observer is still insufficiently coarse - this work is computationally expensive and already being performed by the runtime to generate the various provided levels of detail.</span></span>

<span data-ttu-id="22311-318">一部のアプリケーションがクリップ空間これらにする場合がありますので、各画面のオブザーバーは、複数の接続されていない空間サーフェスを提供できます、表面メッシュ、他の各しジッパーに対してにまとめています。</span><span class="sxs-lookup"><span data-stu-id="22311-318">Because each surface observer can provide multiple unconnected spatial surfaces, some applications may wish to clip these spatial surface meshes against each other, then zipper them together.</span></span> <span data-ttu-id="22311-319">一般に、クリッピング ステップは、空間表面メッシュの近くにある多くの場合、少しずつオーバー ラップ処理として必要です。</span><span class="sxs-lookup"><span data-stu-id="22311-319">In general, the clipping step is required, as nearby spatial surface meshes often overlap slightly.</span></span>

## <a name="raycasting-and-collision"></a><span data-ttu-id="22311-320">レイキャストと衝突</span><span class="sxs-lookup"><span data-stu-id="22311-320">Raycasting and Collision</span></span>

<span data-ttu-id="22311-321">物理運動の API の順序で (など[Havok](http://www.havok.com/)) アプリケーション空間のサーフェスをレイキャストと衝突の機能を備えたアプリケーションを提供する空間画面は物理運動の API にメッシュを提供する必要があります。</span><span class="sxs-lookup"><span data-stu-id="22311-321">In order for a physics API (such as [Havok](http://www.havok.com/)) to provide an application with raycasting and collision functionality for spatial surfaces, the application must provide spatial surface meshes to the physics API.</span></span> <span data-ttu-id="22311-322">多くの場合、物理運動のために使用するメッシュの次のプロパティがあります。</span><span class="sxs-lookup"><span data-stu-id="22311-322">Meshes used for physics often have the following properties:</span></span>
* <span data-ttu-id="22311-323">少数三角形のみにはが含まれます。</span><span class="sxs-lookup"><span data-stu-id="22311-323">They contain only small numbers of triangles.</span></span> <span data-ttu-id="22311-324">物理操作は詳細の表示操作よりも負荷の高い。</span><span class="sxs-lookup"><span data-stu-id="22311-324">Physics operations are more computationally intensive than rendering operations.</span></span>
* <span data-ttu-id="22311-325">'Water 密' です。</span><span class="sxs-lookup"><span data-stu-id="22311-325">They are 'water-tight'.</span></span> <span data-ttu-id="22311-326">サーフェスをしっかり学ぶためのものには、; に小規模の穴はありません。偶数の穴を表示するには小さすぎる問題が発生することができます。</span><span class="sxs-lookup"><span data-stu-id="22311-326">Surfaces intended to be solid should not have small holes in them; even holes too small to be visible can cause problems.</span></span>
* <span data-ttu-id="22311-327">凸 hulls に変換されます。</span><span class="sxs-lookup"><span data-stu-id="22311-327">They are converted into convex hulls.</span></span> <span data-ttu-id="22311-328">凸 hulls 多角形のいくつかあり、穴の自由し、生の三角形メッシュよりも処理するよりずっと計算に効率的です。</span><span class="sxs-lookup"><span data-stu-id="22311-328">Convex hulls have few polygons and are free of holes, and they are much more computationally efficient to process than raw triangle meshes.</span></span>

<span data-ttu-id="22311-329">少しややこしい - だけの完全な乱雑図形など、デスクの空間のサーフェスに対して実行する raycasts は、これらのサーフェスの多くの場合、複雑さも留意してくださいと。</span><span class="sxs-lookup"><span data-stu-id="22311-329">When performing raycasts against spatial surfaces, bear in mind that these surfaces are often complex, cluttered shapes full of messy little details - just like your desk!</span></span> <span data-ttu-id="22311-330">つまり、単一 raycast が多くの場合、不十分である、画面の近くに空の領域の図形の形状に関する十分な情報を提供します。</span><span class="sxs-lookup"><span data-stu-id="22311-330">This means that a single raycast is often insufficient to give you enough information about the shape of the surface and the shape of the empty space near it.</span></span> <span data-ttu-id="22311-331">これは通常多く raycasts 小さな領域内で実行して、画面の信頼性の高い理解の派生に集計の結果を使用することをお勧めではため。</span><span class="sxs-lookup"><span data-stu-id="22311-331">It is thus usually a good idea to perform many raycasts within a small area and to use the aggregate results to derive a more reliable understanding of the surface.</span></span> <span data-ttu-id="22311-332">たとえば、10 raycasts の平均値を使用して、画面でガイド ホログラム配置するが生成されますまでよりスムーズかつちらつく小さい結果 raycast は 1 つだけを使用しています。</span><span class="sxs-lookup"><span data-stu-id="22311-332">For example, using the average of 10 raycasts to guide hologram placement on a surface will yield a far smoother and less 'jittery' result that using just a single raycast.</span></span>

<span data-ttu-id="22311-333">ただし、各 raycast 高い計算コストがあることができますも留意してください。</span><span class="sxs-lookup"><span data-stu-id="22311-333">However, bear in mind that each raycast can have a high computational cost.</span></span> <span data-ttu-id="22311-334">そのため、使用状況シナリオに応じてする必要がありますのバランスを取る追加 raycasts の計算コスト (すべてのフレームが実行されます) の計算コストに対して[メッシュ処理](spatial-mapping.md#mesh-processing)smooth および空間サーフェス (穴を削除するには実行空間メッシュが更新されたときに)。</span><span class="sxs-lookup"><span data-stu-id="22311-334">Thus depending on your usage scenario you should trade off the computational cost of additional raycasts (performed every frame) against the computational cost of [mesh processing](spatial-mapping.md#mesh-processing) to smooth and remove holes in spatial surfaces (performed when spatial meshes are updated).</span></span>

## <a name="troubleshooting"></a><span data-ttu-id="22311-335">トラブルシューティング</span><span class="sxs-lookup"><span data-stu-id="22311-335">Troubleshooting</span></span>
* <span data-ttu-id="22311-336">表面メッシュを正しく向きにするためには、各 GameObject をそのメッシュを構築して、SurfaceObeserver に送信される前にアクティブにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="22311-336">In order for the surface meshes to be orientated correctly, each GameObject needs to be active before it is sent to the SurfaceObeserver to have its mesh constructed.</span></span> <span data-ttu-id="22311-337">それ以外の場合、メッシュは奇妙な角度で回転がスペースに表示されます。</span><span class="sxs-lookup"><span data-stu-id="22311-337">Otherwise, the meshes will show up in your space but rotated at weird angles.</span></span>
* <span data-ttu-id="22311-338">GameObject、SurfaceObserver と通信するスクリプトを実行するには、配信元に設定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="22311-338">The GameObject that runs the script that communicates with the SurfaceObserver needs to be set to the origin.</span></span> <span data-ttu-id="22311-339">それ以外の場合、オフセット、親ゲーム オブジェクトのオフセットに等しいすべて Gameobject を作成し、SurfaceObserver 構築、メッシュに送信するのになります。</span><span class="sxs-lookup"><span data-stu-id="22311-339">Otherwise, all of GameObjects that you create and send to the SurfaceObserver to have their meshes constructed will have an offset equal to the offset of the Parent Game Object.</span></span> <span data-ttu-id="22311-340">何が起こってをデバッグする非常に困難になりますからいくつかのメーターを表示する、メッシュがあることがあります。</span><span class="sxs-lookup"><span data-stu-id="22311-340">This can make your meshes show up several meters away which makes it very hard to debug what is going on.</span></span>

## <a name="see-also"></a><span data-ttu-id="22311-341">関連項目</span><span class="sxs-lookup"><span data-stu-id="22311-341">See also</span></span>
* [<span data-ttu-id="22311-342">座標系</span><span class="sxs-lookup"><span data-stu-id="22311-342">Coordinate systems</span></span>](coordinate-systems.md)
* [<span data-ttu-id="22311-343">DirectX での空間のマッピング</span><span class="sxs-lookup"><span data-stu-id="22311-343">Spatial mapping in DirectX</span></span>](spatial-mapping-in-directx.md)
* [<span data-ttu-id="22311-344">Unity での空間のマッピング</span><span class="sxs-lookup"><span data-stu-id="22311-344">Spatial mapping in Unity</span></span>](spatial-mapping-in-unity.md)
* [<span data-ttu-id="22311-345">空間マッピングの設計</span><span class="sxs-lookup"><span data-stu-id="22311-345">Spatial mapping design</span></span>](spatial-mapping-design.md)
* [<span data-ttu-id="22311-346">導入事例 - 実際には、セキュリティ ホールを見る</span><span class="sxs-lookup"><span data-stu-id="22311-346">Case study - Looking through holes in your reality</span></span>](case-study-looking-through-holes-in-your-reality.md)
