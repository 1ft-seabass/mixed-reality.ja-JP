---
title: 空間マッピング
description: 空間マッピングは、HoloLens の周囲の環境における実際のサーフェイスの詳細な表現を提供します。
author: mattzmsft
ms.author: mazeller
ms.date: 03/21/2018
ms.topic: article
keywords: 空間マッピング, HoloLens, mixed reality, surface 再構築, メッシュ, sr
ms.openlocfilehash: 31abeca624512f1d5e721dbe879ca2243cf41345
ms.sourcegitcommit: 915d3cc63a5571ba22ac4608589f3eca8da1bc81
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/24/2019
ms.locfileid: "63550485"
---
# <a name="spatial-mapping"></a><span data-ttu-id="b0b0b-104">空間マッピング</span><span class="sxs-lookup"><span data-stu-id="b0b0b-104">Spatial mapping</span></span>

<span data-ttu-id="b0b0b-105">空間マッピングは、HoloLens の周囲の環境における実際のサーフェイスの詳細な表現を提供し、開発者が説得力のある mixed reality エクスペリエンスを作成できるようにします。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-105">Spatial mapping provides a detailed representation of real-world surfaces in the environment around the HoloLens, allowing developers to create a convincing mixed reality experience.</span></span> <span data-ttu-id="b0b0b-106">実際の世界を仮想環境にマージすることにより、アプリケーションは、ホログラムを現実に見せることができます。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-106">By merging the real world with the virtual world, an application can make holograms seem real.</span></span> <span data-ttu-id="b0b0b-107">また、アプリケーションは、実際の動作と相互作用を理解することで、ユーザーの期待に合わせて自然に配置できます。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-107">Applications can also more naturally align with user expectations by providing familiar real-world behaviors and interactions.</span></span>

<br>

>[!VIDEO https://www.youtube.com/embed/zff2aQ1RaVo]

## <a name="device-support"></a><span data-ttu-id="b0b0b-108">デバイスのサポート</span><span class="sxs-lookup"><span data-stu-id="b0b0b-108">Device support</span></span>

<table>
<tr>
<th><span data-ttu-id="b0b0b-109">機能</span><span class="sxs-lookup"><span data-stu-id="b0b0b-109">Feature</span></span></th><th style="width:150px"> <span data-ttu-id="b0b0b-110"><a href="hololens-hardware-details.md">HoloLens (第 1 世代)</a></span><span class="sxs-lookup"><span data-stu-id="b0b0b-110"><a href="hololens-hardware-details.md">HoloLens (1st gen)</a></span></span></th><th style="width:150px"><span data-ttu-id="b0b0b-111">HoloLens 2</span><span class="sxs-lookup"><span data-stu-id="b0b0b-111">HoloLens 2</span></span></th><th style="width:150px"> <span data-ttu-id="b0b0b-112"><a href="immersive-headset-hardware-details.md">イマーシブ ヘッドセット</a></span><span class="sxs-lookup"><span data-stu-id="b0b0b-112"><a href="immersive-headset-hardware-details.md">Immersive headsets</a></span></span></th>
</tr><tr>
<td> <span data-ttu-id="b0b0b-113">空間マッピング</span><span class="sxs-lookup"><span data-stu-id="b0b0b-113">Spatial mapping</span></span></td><td style="text-align: center;"> <span data-ttu-id="b0b0b-114">✔️</span><span class="sxs-lookup"><span data-stu-id="b0b0b-114">✔️</span></span></td><td style="text-align: center;"> <span data-ttu-id="b0b0b-115">✔️</span><span class="sxs-lookup"><span data-stu-id="b0b0b-115">✔️</span></span></td><td style="text-align: center;"></td>
</tr>
</table>



## <a name="conceptual-overview"></a><span data-ttu-id="b0b0b-116">概念の概要</span><span class="sxs-lookup"><span data-stu-id="b0b0b-116">Conceptual overview</span></span>

<span data-ttu-id="b0b0b-117">![部屋をカバーするメッシュサーフェス](images/SurfaceReconstruction.jpg)</span><span class="sxs-lookup"><span data-stu-id="b0b0b-117">![Mesh surfaces covering a room](images/SurfaceReconstruction.jpg)</span></span><br>
<span data-ttu-id="b0b0b-118">*部屋をカバーする空間マッピングメッシュの例*</span><span class="sxs-lookup"><span data-stu-id="b0b0b-118">*An example of a spatial mapping mesh covering a room*</span></span>

<span data-ttu-id="b0b0b-119">空間マッピングに使用される2つの主なオブジェクトの種類は、"空間サーフェスオブザーバー" と "空間サーフェス" です。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-119">The two primary object types used for spatial mapping are the 'Spatial Surface Observer' and the 'Spatial Surface'.</span></span>

<span data-ttu-id="b0b0b-120">アプリケーションは、1つまたは複数の境界ボリュームを持つ空間サーフェスオブザーバーを提供し、アプリケーションが空間マッピングデータを受け取る領域の領域を定義します。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-120">The application provides the Spatial Surface Observer with one or more bounding volumes, to define the regions of space in which the application wishes to receive spatial mapping data.</span></span> <span data-ttu-id="b0b0b-121">これらの各ボリュームについて、空間マッピングによって、空間サーフェスのセットがアプリケーションに提供されます。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-121">For each of these volumes, spatial mapping will provide the application with a set of Spatial Surfaces.</span></span>

<span data-ttu-id="b0b0b-122">これらのボリュームは、(実際の世界に対して固定された場所で) 静止している場合や、HoloLens にアタッチされている場合があります (これらのボリュームは、環境内を移動するときに HoloLens と一緒に移動されますが、回転しません)。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-122">These volumes may be stationary (in a fixed location with respect to the real world) or they may be attached to the HoloLens (they move, but do not rotate, with the HoloLens as it moves through the environment).</span></span> <span data-ttu-id="b0b0b-123">各空間サーフェスは、ワールドロックされた[空間座標系](coordinate-systems.md)に関連付けられた三角形メッシュとして表される、小さい領域の実際のサーフェイスを表します。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-123">Each spatial surface describes real-world surfaces in a small volume of space, represented as a triangle mesh attached to a world-locked [spatial coordinate system](coordinate-systems.md).</span></span>

<span data-ttu-id="b0b0b-124">HoloLens が環境に関する新しいデータを収集すると、環境に対する変更が発生すると、空間サーフェスが表示され、非表示になり、変更されます。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-124">As the HoloLens gathers new data about the environment, and as changes to the environment occur, spatial surfaces will appear, disappear and change.</span></span>

## <a name="common-usage-scenarios"></a><span data-ttu-id="b0b0b-125">一般的な使用シナリオ</span><span class="sxs-lookup"><span data-stu-id="b0b0b-125">Common usage scenarios</span></span>

![一般的な空間マッピングの使用シナリオの図:配置、遮蔽、物理、およびナビゲーション](images/sm-concepts-1000px.png)

### <a name="placement"></a><span data-ttu-id="b0b0b-127">配置</span><span class="sxs-lookup"><span data-stu-id="b0b0b-127">Placement</span></span>

<span data-ttu-id="b0b0b-128">空間マッピングを使用すると、アプリケーションは、自然で使い慣れた形でユーザーと対話することができます。電話をデスクに置いた方が、より自然なことがありますか。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-128">Spatial mapping provides applications with the opportunity to present natural and familiar forms of interaction to the user; what could be more natural than placing your phone down on the desk?</span></span>

<span data-ttu-id="b0b0b-129">サーフェイス上に配置されるホログラム (または、より一般的には、任意の空間位置の選択) の配置を制限すると、3D (空間のポイント) から 2D (サーフェス上の点) への自然なマッピングが実現します。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-129">Constraining the placement of holograms (or more generally, any selection of spatial locations) to lie on surfaces provides a natural mapping from 3D (point in space) to 2D (point on surface).</span></span> <span data-ttu-id="b0b0b-130">これにより、ユーザーがアプリケーションに提供する必要がある情報の量が削減されるため、ユーザーの操作をより迅速かつ簡単に、より正確に行うことができます。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-130">This reduces the amount of information the user needs to provide to the application and thus makes the user's interactions faster, easier and more precise.</span></span> <span data-ttu-id="b0b0b-131">これは特に、"距離が離れています" が、他の人間やコンピューターと物理的に通信するために使用されるものではないためです。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-131">This is particularly true because 'distance away' is not something that we are used to physically communicating to other people or to computers.</span></span> <span data-ttu-id="b0b0b-132">指をポイントすると、方向を指定しますが、距離は指定しません。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-132">When we point with our finger, we are specifying a direction but not a distance.</span></span>

<span data-ttu-id="b0b0b-133">ここで重要な注意事項として、アプリケーションで方向からの距離が推測される場合 (たとえば、ユーザーの見つめ方向に沿って raycast を実行して最も近い空間サーフェスを検索する場合など)、ユーザーが確実に予測できる結果が得られる必要があります。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-133">An important caveat here is that when an application infers distance from direction (for example by performing a raycast along the user's gaze direction to find the nearest spatial surface), this must yield results that the user is able to reliably predict.</span></span> <span data-ttu-id="b0b0b-134">そうしないと、ユーザーは制御の意味を失い、すぐにフラストレーションを受ける可能性があります。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-134">Otherwise, the user will lose their sense of control and this can quickly become frustrating.</span></span> <span data-ttu-id="b0b0b-135">これに役立つ1つの方法は、1つだけではなく、複数の raycasts を実行することです。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-135">One method that helps with this is to perform multiple raycasts instead of just one.</span></span> <span data-ttu-id="b0b0b-136">集計結果は、より滑らかで予測可能であり、一時的な ' 外れ値 ' 結果からの影響を受けにくくなります (光線が小さな穴を通過するか、ユーザーが認識していないジオメトリの小さなビットに達したことによって発生する可能性があります)。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-136">The aggregate results should be smoother and more predictable, less susceptible to influence from transient 'outlier' results (as can be caused by rays passing through tiny holes or hitting small bits of geometry that the user is not aware of).</span></span> <span data-ttu-id="b0b0b-137">集計またはスムージングは、時間の経過と共に実行することもできます。たとえば、ホログラムがユーザーからの距離で変化する最大速度を制限できます。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-137">Aggregation or smoothing can also be performed over time; for example you can limit the maximum speed at which a hologram can vary in distance from the user.</span></span> <span data-ttu-id="b0b0b-138">最小距離と最大距離の値を制限するだけでも役に立ちます。したがって、移動するホログラムは、突然距離が離れたり、ユーザーの顔に戻ったりすることはありません。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-138">Simply limiting the minimum and maximum distance value can also help, so the hologram being moved does not suddenly fly away into the distance or come crashing back into the user's face.</span></span>

<span data-ttu-id="b0b0b-139">アプリケーションでは、サーフェイスの形状と方向を使用して、ホログラムの配置をガイドすることもできます。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-139">Applications can also use the shape and direction of surfaces to guide hologram placement.</span></span> <span data-ttu-id="b0b0b-140">Holographic チェアは壁を通過しないようにする必要があります。また、やや不均一であっても、床との間にフラッシュする必要があります。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-140">A holographic chair should not penetrate through walls and should sit flush with the floor even if it is slightly uneven.</span></span> <span data-ttu-id="b0b0b-141">この種の機能は、単なる raycasts ではなく、物理的な衝突の使用に依存する可能性がありますが、同様の懸念が適用されます。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-141">This kind of functionality would likely rely upon the use of physics collisions rather than just raycasts, however similar concerns will apply.</span></span> <span data-ttu-id="b0b0b-142">配置されているホログラムに、椅子の脚のような小さな多角形が多数含まれている場合は、それらの多角形の物理的な表現をより広い範囲で滑らかに拡張して、空間サーフェスを移動することができます。キャプチャ.</span><span class="sxs-lookup"><span data-stu-id="b0b0b-142">If the hologram being placed has many small polygons that stick out, like the legs on a chair, it may make sense to expand the physics representation of those polygons to something wider and smoother so that they are more able to slide over spatial surfaces without snagging.</span></span>

<span data-ttu-id="b0b0b-143">極端には、ユーザー入力を完全に簡略化し、空間サーフェスを使用して完全なホログラム配置を実行できます。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-143">At its extreme, user input can be simplified away entirely and spatial surfaces can be used to perform entirely automatic hologram placement.</span></span> <span data-ttu-id="b0b0b-144">たとえば、アプリケーションでは、ユーザーが押すために壁のどこかに holographic ライトスイッチを配置できます。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-144">For example, the application could place a holographic light-switch somewhere on the wall for the user to press.</span></span> <span data-ttu-id="b0b0b-145">予測可能性に関する注意事項は、ここでは二重に適用されます。ユーザーがホログラムの配置を制御する必要があるものの、アプリケーションが必要な場所にホログラムを配置することがない場合 (ライトスイッチがユーザーに届かない場所に表示される場合)、これは面倒なエクスペリエンスになります。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-145">The same caveat about predictability applies doubly here; if the user expects control over hologram placement, but the application does not always place holograms where they expect (if the light-switch appears somewhere that the user cannot reach), then this will be a frustrating experience.</span></span> <span data-ttu-id="b0b0b-146">実際には、ユーザーが常に配置を実行する必要があるのではなく、ユーザーによる修正を必要とする自動配置を実行する方が悪くなることがあります。自動配置が正常に行われることが*予想*されるため、手動による修正は負担のように感じられます。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-146">It can actually be worse to perform automatic placement that requires user correction some of the time, than to just require the user to always perform placement themselves; because successful automatic placement is *expected*, manual correction feels like a burden!</span></span>

<span data-ttu-id="b0b0b-147">アプリケーションが空間サーフェスを配置に使用できるかどうかは、アプリケーションの[スキャンエクスペリエンス](spatial-mapping-design.md#the-environment-scanning-experience)に大きく左右されることにも注意してください。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-147">Note also that the ability of an application to use spatial surfaces for placement depends heavily on the application's [scanning experience](spatial-mapping-design.md#the-environment-scanning-experience).</span></span> <span data-ttu-id="b0b0b-148">サーフェイスがスキャンされていない場合は、配置に使用できません。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-148">If a surface has not been scanned, then it cannot be used for placement.</span></span> <span data-ttu-id="b0b0b-149">新しい画面をスキャンしたり、新しい場所を選択したりできるように、ユーザーに対してこのことを明確にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-149">It is up to the application to make this clear to the user, so that they can either help scan new surfaces or select a new location.</span></span>

<span data-ttu-id="b0b0b-150">ユーザーへの視覚的なフィードバックは、配置時に非常に重要です。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-150">Visual feedback to the user is of paramount importance during placement.</span></span> <span data-ttu-id="b0b0b-151">ユーザーは、最も近い表面と、[接地効果](spatial-mapping.md#visualization)がある場所を認識している必要があります。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-151">The user needs to know where the hologram is in relation to the nearest surface with [grounding effects](spatial-mapping.md#visualization).</span></span> <span data-ttu-id="b0b0b-152">これらのユーザーは、ホログラムの動きが制約されている理由を理解している必要があります (たとえば、近くにある別のサーフェイスとの衝突が原因で)。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-152">They should understand why the movement of their hologram is being constrained (for example, due to collision with another nearby surface).</span></span> <span data-ttu-id="b0b0b-153">現在の場所にホログラムを配置できない場合、視覚的なフィードバックによって、その理由を明確にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-153">If they cannot place a hologram in the current location, then visual feedback should make it clear why not.</span></span> <span data-ttu-id="b0b0b-154">たとえば、ユーザーが壁に holographic ソファを置いている場合、壁の背後にあるソファの部分は、怒った色で色を付ける必要があります。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-154">For example, if the user is trying to place a holographic couch stuck half-way into the wall, then the portions of the couch that are behind the wall should pulsate in an angry color.</span></span> <span data-ttu-id="b0b0b-155">反対に、ユーザーが実際の画面を見ることができる場所に空間サーフェイスが見つからない場合は、アプリケーションでこのことを明確にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-155">Or conversely, if the application cannot find a spatial surface in a location where the user can see a real-world surface, then the application should make this clear.</span></span> <span data-ttu-id="b0b0b-156">この領域での接地効果が明らかでない場合は、この目的を達成することができます。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-156">The obvious absence of a grounding effect in this area may achieve this purpose.</span></span>

### <a name="occlusion"></a><span data-ttu-id="b0b0b-157">オクルージョン</span><span class="sxs-lookup"><span data-stu-id="b0b0b-157">Occlusion</span></span>

<span data-ttu-id="b0b0b-158">空間マッピングサーフェイスの主な用途の1つは、単にホログラムを occlude することです。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-158">One of the primary uses of spatial mapping surfaces is simply to occlude holograms.</span></span> <span data-ttu-id="b0b0b-159">この単純な動作は、ホログラムのリアリティに大きな影響を与えるため、ユーザーと同じ物理空間をモックとする visceral sense を作成するのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-159">This simple behavior has a huge impact on the perceived realism of holograms, helping to create a visceral sense that really inhabit the same physical space as the user.</span></span>

<span data-ttu-id="b0b0b-160">また、オクルージョンは、ユーザーに情報を提供します。occluded が本物の表面であると思われる場合、この方法では、世界中のホログラムの空間位置に関する追加の視覚的フィードバックが提供されます。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-160">Occlusion also provides information to the user; when a hologram appears to be occluded by a real-world surface, this provides additional visual feedback as to the spatial location of that hologram in the world.</span></span> <span data-ttu-id="b0b0b-161">逆に、オクルージョンでは、ユーザーからの情報を*非表示*にすることもできます。壁の背後にある occluding ホログラムは、直感的な方法で視覚乱雑を軽減できます。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-161">Conversely, occlusion can also usefully *hide* information from the user; occluding holograms behind walls can reduce visual clutter in an intuitive way.</span></span> <span data-ttu-id="b0b0b-162">ホログラムを表示または非表示にするには、ユーザーは単にヘッドを移動する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-162">To hide or reveal a hologram, the user merely has to move their head.</span></span>

<span data-ttu-id="b0b0b-163">また、遮蔽を使用すると、使い慣れた物理的な対話に基づいて自然なユーザーインターフェイスの期待を達成することもできます。ホログラムがサーフェイスによって occluded されている場合、その表面はソリッドであるため、ユーザーは、ホログラムがその表面と*衝突*し、単に通過することを期待する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-163">Occlusion can also be used to prime expectations for a natural user interface based upon familiar physical interactions; if a hologram is occluded by a surface it is because that surface is solid, so the user should expect that the hologram will *collide* with that surface and not simply pass through it.</span></span>

<span data-ttu-id="b0b0b-164">場合によっては、ホログラムの遮蔽が望ましくないこともあります。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-164">Sometimes, occlusion of holograms is undesirable.</span></span> <span data-ttu-id="b0b0b-165">ユーザーがホログラムを操作できる必要がある場合は、実際の画面の背後にいる場合でも、ユーザーはそれを確認できる必要があります。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-165">If a user needs to be able to interact with a hologram, then they need to be able to see it - even if it is behind a real-world surface.</span></span> <span data-ttu-id="b0b0b-166">このような場合、通常は、occluded したときに (たとえば、明るさを下げることによって) このようなホログラムを別にレンダリングするのが理にかなっています。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-166">In such cases, it usually makes sense to render such a hologram differently when it is occluded (for example, by reducing its brightness).</span></span> <span data-ttu-id="b0b0b-167">こうすることで、ユーザーはホログラムを視覚的に見つけることができますが、それでもその背後にあることを認識できます。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-167">This way, the user will be able to visually locate the hologram, but they will still be aware that it is behind something.</span></span>

### <a name="physics"></a><span data-ttu-id="b0b0b-168">物理</span><span class="sxs-lookup"><span data-stu-id="b0b0b-168">Physics</span></span>

<span data-ttu-id="b0b0b-169">物理シミュレーションを使用するもう1つの方法として、空間マッピングを使用して、ユーザーの物理空間にホログラムの*存在*を補強することができます。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-169">The use of physics simulation is another way in which spatial mapping can be used to reinforce the *presence* of holograms in the user's physical space.</span></span> <span data-ttu-id="b0b0b-170">私の holographic ゴムボールは、机の上から離れたときに、床でバウンスされ、ソファの下に見えなくなったときに、それが本当にないと信じられないかもしれません。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-170">When my holographic rubber ball rolls realistically off my desk, bounces across the floor and disappears under the couch, it might be hard for me to believe that it's not really there.</span></span>

<span data-ttu-id="b0b0b-171">また、物理シミュレーションでは、アプリケーションで自然でわかりやすい物理操作を使用することもできます。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-171">Physics simulation also provides the opportunity for an application to use natural and familiar physics-based interactions.</span></span> <span data-ttu-id="b0b0b-172">フロア上の holographic 家具を移動すると、家具が適切な慣性と摩擦によってフロア上でスライドしているかのように反応する場合、ユーザーにとってはもっと簡単になります。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-172">Moving a piece of holographic furniture around on the floor will likely be easier for the user if the furniture responds as if it were sliding across the floor with the appropriate inertia and friction.</span></span>

<span data-ttu-id="b0b0b-173">現実的な物理的な動作を生成するために、穴の塗りつぶし、浮動 hallucinations の除去、ラフサーフェスのスムージングなど、[メッシュ処理](spatial-mapping.md#mesh-processing)の実行が必要になる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-173">In order to generate realistic physical behaviors, you will likely need to perform some [mesh processing](spatial-mapping.md#mesh-processing) such as filling holes, removing floating hallucinations and smoothing rough surfaces.</span></span>

<span data-ttu-id="b0b0b-174">また、アプリケーションの[スキャンエクスペリエンス](spatial-mapping-design.md#the-environment-scanning-experience)が物理シミュレーションに与える影響についても考慮する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-174">You will also need to consider how your application's [scanning experience](spatial-mapping-design.md#the-environment-scanning-experience) influences its physics simulation.</span></span> <span data-ttu-id="b0b0b-175">最初は、不足しているサーフェスは何も競合しません。ゴムボールが corridor と、既知の世界の端から離れたときにどうなるでしょうか。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-175">Firstly, missing surfaces won't collide with anything; what happens when the rubber ball rolls off down the corridor and off the end of the known world?</span></span> <span data-ttu-id="b0b0b-176">さらに、時間の経過と共に環境の変化に対応するかどうかを決定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-176">Secondly, you need to decide whether you will continue to respond to changes in the environment over time.</span></span> <span data-ttu-id="b0b0b-177">場合によっては、可能な限り迅速に対応する必要があります。たとえば、ユーザーがドアと家具を、barricades の tempest に対する防御の可動として使用しているとします。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-177">In some cases, you will want to respond as quickly as possible; say if the user is using doors and furniture as movable barricades in defense against a tempest of incoming Roman arrows.</span></span> <span data-ttu-id="b0b0b-178">ただし、場合によっては、新しい更新プログラムを無視することもできます。犬がトラックの途中に座っていると判断した場合、holographic のスポーツ車をフロア上のレースの周りに置いても、突然楽しいことはありません。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-178">In other cases though, you may want to ignore new updates; driving your holographic sports car around the racetrack on your floor may suddenly not be so fun if your dog decides to sit in the middle of the track.</span></span>

### <a name="navigation"></a><span data-ttu-id="b0b0b-179">ナビゲーション</span><span class="sxs-lookup"><span data-stu-id="b0b0b-179">Navigation</span></span>

<span data-ttu-id="b0b0b-180">アプリケーションでは、空間マッピングデータを使用して、実際の人と同じように、holographic 文字 (またはエージェント) が現実世界に移動できるようにすることができます。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-180">Applications can use spatial mapping data to grant holographic characters (or agents) the ability to navigate the real world in the same way a real person would.</span></span> <span data-ttu-id="b0b0b-181">これにより、ユーザーとその友人と同じ自然でなじみのある動作のセットに制限することで、holographic 文字が確実に存在するようになります。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-181">This can help reinforce the presence of holographic characters by restricting them to the same set of natural, familiar behaviors as those of the user and their friends.</span></span>

<span data-ttu-id="b0b0b-182">ナビゲーション機能は、ユーザーにも役立ちます。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-182">Navigation capabilities could be useful to users as well.</span></span> <span data-ttu-id="b0b0b-183">特定の領域にナビゲーションマップが構築されると、その場所を知らない新しいユーザーのために holographic の方向を提供するために共有することができます。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-183">Once a navigation map has been built in a given area, it could be shared to provide holographic directions for new users unfamiliar with that location.</span></span> <span data-ttu-id="b0b0b-184">このマップは、歩行中のトラフィックの流れを円滑に保つため、または構築サイトなどの危険な場所での事故を防ぐために設計されている可能性があります。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-184">This map could be designed to help keep pedestrian 'traffic' flowing smoothly, or to avoid accidents in dangerous locations like construction sites.</span></span>

<span data-ttu-id="b0b0b-185">ナビゲーション機能の実装に伴う技術的な課題の主な課題は、再生可能なサーフェイス (人間はテーブルをウォークしません) を確実に検出し、環境の変化に適切に適合させることです (人間は閉じたドアをたどることはできません)。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-185">The key technical challenges involved in implementing navigation functionality will be reliable detection of walkable surfaces (humans don't walk on tables!) and graceful adaptation to changes in the environment (humans don't walk through closed doors!).</span></span> <span data-ttu-id="b0b0b-186">メッシュでは、仮想文字によるパスの計画とナビゲーションに使用できるようになる前に、何らかの[処理](spatial-mapping.md#mesh-processing)が必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-186">The mesh may require some [processing](spatial-mapping.md#mesh-processing) before it is usable for path-planning and navigation by a virtual character.</span></span> <span data-ttu-id="b0b0b-187">メッシュをスムージングし、hallucinations を削除すると、文字が動かなくなるのを防ぐことができます。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-187">Smoothing the mesh and removing hallucinations may help avoid characters becoming stuck.</span></span> <span data-ttu-id="b0b0b-188">また、文字のパス計画とナビゲーションの計算を高速化するために、メッシュを大幅に簡略化することもできます。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-188">You may also wish to drastically simplify the mesh in order to speed up your character's path-planning and navigation calculations.</span></span> <span data-ttu-id="b0b0b-189">これらの課題は、videogame テクノロジの開発において非常に注意を払ってきました。これらのトピックには、豊富な研究資料があります。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-189">These challenges have received a great deal of attention in the development of videogame technology, and there is a wealth of available research literature on these topics.</span></span>

<span data-ttu-id="b0b0b-190">Unity の組み込みのナビゲーションメッシュ機能は、空間マッピングサーフェイスでは使用できないことに注意してください。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-190">Note that the built-in NavMesh functionality in Unity cannot be used with spatial mapping surfaces.</span></span> <span data-ttu-id="b0b0b-191">これは、アプリケーションが開始されるまで空間マッピングサーフェイスが知られていないのに対して、ナビゲーションデータファイルは事前にソースアセットから生成する必要があるためです。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-191">This is because spatial mapping surfaces are not known until the application starts, whereas NavMesh data files need to be generated from source assets ahead of time.</span></span> <span data-ttu-id="b0b0b-192">また、空間マッピングシステムは、ユーザーの現在の場所から離れた場所にある[サーフェイスに関する情報](spatial-mapping-design.md#the-environment-scanning-experience)を提供しないことにも注意してください。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-192">Also note that, the spatial mapping system will not provide [information about surfaces very far away](spatial-mapping-design.md#the-environment-scanning-experience) from the user's current location.</span></span> <span data-ttu-id="b0b0b-193">そのため、非常に大きな領域のマップを作成する場合は、アプリケーションがそのサーフェイス自体を記憶する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-193">So the application must 'remember' surfaces itself if it is to build a map of a very large area.</span></span>

### <a name="visualization"></a><span data-ttu-id="b0b0b-194">可視化</span><span class="sxs-lookup"><span data-stu-id="b0b0b-194">Visualization</span></span>

<span data-ttu-id="b0b0b-195">ほとんどの場合、空間サーフェスを非表示にするのが適切です。見た目が乱雑にならないようにして、現実世界の声を聞くことができます。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-195">Most of the time it is appropriate for spatial surfaces to be invisible; to minimize visual clutter and let the real world speak for itself.</span></span> <span data-ttu-id="b0b0b-196">ただし、実際の対応するものが既に表示されているとしても、空間マッピングサーフェイスを直接視覚化すると便利な場合があります。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-196">However, sometimes it is useful to visualize spatial mapping surfaces directly, despite the fact that their real-world counterparts are already visible.</span></span>

<span data-ttu-id="b0b0b-197">たとえば、ユーザーが表面にホログラムを配置しようとしたとき (壁に holographic キャビネットを配置する場合など)、表面に影をキャストすることによって、ホログラムを "接地" することが役に立つことがあります。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-197">For example, when the user is trying to place a hologram onto a surface (placing a holographic cabinet on the wall, say) it can be useful to 'ground' the hologram by casting a shadow onto the surface.</span></span> <span data-ttu-id="b0b0b-198">これにより、ホログラムと surface の物理的な距離を明確に理解できます。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-198">This gives the user a much clearer sense of the exact physical proximity between the hologram and the surface.</span></span> <span data-ttu-id="b0b0b-199">これは、ユーザーがコミットする前に、変更を視覚的に "プレビュー" するより一般的な方法の例でもあります。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-199">This is also an example of the more general practice of visually 'previewing' a change before the user commits to it.</span></span>

<span data-ttu-id="b0b0b-200">サーフェイスを視覚化することで、アプリケーションは環境についての理解をユーザーと共有できます。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-200">By visualizing surfaces, the application can share with the user its understanding of the environment.</span></span> <span data-ttu-id="b0b0b-201">たとえば、holographic board ゲームでは、"tables" として識別された水平サーフェスを視覚化することができます。これにより、ユーザーが対話する場所を知ることができます。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-201">For example, a holographic board game could visualize the horizontal surfaces that it has identified as 'tables', so the user knows where they should go to interact.</span></span>

<span data-ttu-id="b0b0b-202">画面に表示されないユーザーの近くにあるスペースを表示するには、サーフェイスを視覚化すると便利です。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-202">Visualizing surfaces can be a useful way to show the user nearby spaces that are hidden from view.</span></span> <span data-ttu-id="b0b0b-203">これにより、ユーザーがリビングルームからキッチン (およびそのすべてに含まれるホログラム) にアクセスできるようにするための簡単な方法が提供されます。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-203">This could provide a simple way to give the user access to their kitchen (and all of its contained holograms) from their living room.</span></span>

<span data-ttu-id="b0b0b-204">空間マッピングによって提供されるサーフェスメッシュは、特に "クリーン" ではない場合があります。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-204">The surface meshes provided by spatial mapping may not be particularly 'clean'.</span></span> <span data-ttu-id="b0b0b-205">したがって、それらを適切に視覚化することが重要です。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-205">Thus it is important to visualize them appropriately.</span></span> <span data-ttu-id="b0b0b-206">従来の照明計算では、視覚的には見えない形で表面法線のエラーが強調表示される場合がありますが、画面上に投影された "クリーン" テクスチャは、外観を整えるのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-206">Traditional lighting calculations may highlight errors in surface normals in a visually distracting manner, whilst 'clean' textures projected onto the surface may help to give it a tidier appearance.</span></span> <span data-ttu-id="b0b0b-207">また、[メッシュ処理](spatial-mapping.md#mesh-processing)を実行して、サーフェイスがレンダリングされる前にメッシュのプロパティを向上させることもできます。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-207">It is also possible to perform [mesh processing](spatial-mapping.md#mesh-processing) to improve mesh properties, before the surfaces are rendered.</span></span>

## <a name="using-the-surface-observer"></a><span data-ttu-id="b0b0b-208">Surface オブザーバーの使用</span><span class="sxs-lookup"><span data-stu-id="b0b0b-208">Using The Surface Observer</span></span>

<span data-ttu-id="b0b0b-209">空間マッピングの開始点は、surface オブザーバーです。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-209">The starting point for spatial mapping is the surface observer.</span></span> <span data-ttu-id="b0b0b-210">プログラムフローは次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-210">Program flow is as follows:</span></span>
* <span data-ttu-id="b0b0b-211">Surface オブザーバーオブジェクトを作成する</span><span class="sxs-lookup"><span data-stu-id="b0b0b-211">Create a surface observer object</span></span>
   * <span data-ttu-id="b0b0b-212">1つまたは複数の空間ボリュームを指定して、アプリケーションが空間マッピングデータを受け取る対象領域を定義します。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-212">Provide one or more spatial volumes, to define the regions of interest in which the application wishes to receive spatial mapping data.</span></span> <span data-ttu-id="b0b0b-213">空間ボリュームは、球体や箱などの領域の領域を定義する図形です。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-213">A spatial volume is simply a shape defining a region of space, such as a sphere or a box.</span></span>
   * <span data-ttu-id="b0b0b-214">ワールドロックの空間座標系で空間ボリュームを使用して、物理的な世界の固定領域を特定します。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-214">Use a spatial volume with a world-locked spatial coordinate system to identify a fixed region of the physical world.</span></span>
   * <span data-ttu-id="b0b0b-215">空間ボリュームを使用して、ボディロックされた空間座標系で各フレームを更新し、ユーザーとの間で移動する (ただし、回転しない) 領域を特定します。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-215">Use a spatial volume, updated each frame with a body-locked spatial coordinate system, to identify a region of space that moves (but does not rotate) with the user.</span></span>
   * <span data-ttu-id="b0b0b-216">これらの空間ボリュームは、アプリケーションまたはユーザーの状態が変化したときに、いつでも変更できます。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-216">These spatial volumes may be changed later at any time, as the status of the application or the user changes.</span></span>
* <span data-ttu-id="b0b0b-217">ポーリングまたは通知を使用して空間サーフェスに関する情報を取得する</span><span class="sxs-lookup"><span data-stu-id="b0b0b-217">Use polling or notification to retrieve information about spatial surfaces</span></span>
   * <span data-ttu-id="b0b0b-218">空間サーフェスの状態については、いつでも surface オブザーバーを "ポーリング" できます。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-218">You may 'poll' the surface observer for spatial surface status at any time.</span></span> <span data-ttu-id="b0b0b-219">また、surface オブザーバーの ' surface changed ' イベントに登録することもできます。これにより、空間サーフェスが変化したときにアプリケーションに通知されます。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-219">Alternatively, you may register for the surface observer's 'surfaces changed' event, which will notify the application when spatial surfaces have changed.</span></span>
   * <span data-ttu-id="b0b0b-220">ビューが錐である、または本文でロックされているボリュームのような動的な空間ボリュームの場合、アプリケーションは、必要な領域を設定し、現在の空間サーフェスのセットを取得することによって、各フレームの変更に対してポーリングを行う必要があります。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-220">For a dynamic spatial volume, such as the view frustum, or a body-locked volume, applications will need to poll for changes each frame by setting the region of interest and then obtaining the current set of spatial surfaces.</span></span>
   * <span data-ttu-id="b0b0b-221">1つのルームをカバーするワールドロックキューブなどの静的ボリュームの場合、アプリケーションは、そのボリューム内の空間サーフェスが変更された場合に通知されるように "サーフェイス changed" イベントに登録できます。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-221">For a static volume, such as a world-locked cube covering a single room, applications may register for the 'surfaces changed' event to be notified when spatial surfaces inside that volume may have changed.</span></span>
* <span data-ttu-id="b0b0b-222">サーフェイスの変化を処理する</span><span class="sxs-lookup"><span data-stu-id="b0b0b-222">Process surfaces changes</span></span>
   * <span data-ttu-id="b0b0b-223">指定された空間サーフェイスのセットを反復処理します。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-223">Iterate the provided set of spatial surfaces.</span></span>
   * <span data-ttu-id="b0b0b-224">空間サーフェスを追加、変更、または削除済みとして分類します。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-224">Classify spatial surfaces as added, changed or removed.</span></span>
   * <span data-ttu-id="b0b0b-225">追加または変更された空間サーフェイスごとに、必要に応じて、必要な詳細レベルでサーフェイスの現在の状態を表す更新されたメッシュを受け取る非同期要求を送信します。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-225">For each added or changed spatial surface, if appropriate submit an asynchronous request to receive updated mesh representing the surface's current state at the desired level of detail.</span></span>
* <span data-ttu-id="b0b0b-226">非同期メッシュ要求を処理します (以降のセクションで詳しく説明します)。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-226">Process the asynchronous mesh request (more details in following sections).</span></span>

## <a name="mesh-caching"></a><span data-ttu-id="b0b0b-227">メッシュキャッシュ</span><span class="sxs-lookup"><span data-stu-id="b0b0b-227">Mesh Caching</span></span>

<span data-ttu-id="b0b0b-228">空間サーフェスは、高密度三角形メッシュによって表されます。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-228">Spatial surfaces are represented by dense triangle meshes.</span></span> <span data-ttu-id="b0b0b-229">これらのメッシュを格納、表示、および処理すると、コンピューティングリソースとストレージリソースが大幅に消費される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-229">Storing, rendering and processing these meshes can consume significant computational and storage resources.</span></span> <span data-ttu-id="b0b0b-230">そのため、各アプリケーションは、メッシュの処理とストレージに使用されるリソースを最小限に抑えるために、ニーズに適したメッシュキャッシュ方式を採用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-230">As such, each application should adopt a mesh caching scheme appropriate to its needs, in order to minimize the resources used for mesh processing and storage.</span></span> <span data-ttu-id="b0b0b-231">このスキームでは、どのメッシュを保持するか、破棄するか、および各空間サーフェイスのメッシュをいつ更新するかを決定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-231">This scheme should determine which meshes to retain and which to discard, as well as when to update the mesh for each spatial surface.</span></span>

<span data-ttu-id="b0b0b-232">ここで説明する考慮事項の多くは、アプリケーションがメッシュキャッシュにどのように対処する必要があるかを直接通知します。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-232">Many of the considerations discussed there will directly inform how your application should approach mesh caching.</span></span> <span data-ttu-id="b0b0b-233">ユーザーが環境内をどのように移動するか、どのサーフェイスが必要であるか、および環境内の変更をいつキャプチャするかを考慮する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-233">You should consider how the user moves through the environment, which surfaces are needed, when different surfaces will be observed and when changes in the environment should be captured.</span></span>

<span data-ttu-id="b0b0b-234">Surface オブザーバーによって提供される "変化したサーフェイス" イベントを解釈する場合、基本的なメッシュキャッシュのロジックは次のようになります。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-234">When interpreting the 'surfaces changed' event provided by the surface observer, the basic mesh caching logic is as follows:</span></span>
* <span data-ttu-id="b0b0b-235">前に見られていない空間サーフェス ID がアプリケーションに表示される場合、これを新しい空間サーフェスとして扱います。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-235">If the application sees a spatial surface ID that it has not seen before, it should treat this as a new spatial surface.</span></span>
* <span data-ttu-id="b0b0b-236">アプリケーションが既知の ID を持つ空間サーフェスを認識し、新しい更新時間がある場合は、これを更新された空間サーフェスとして扱う必要があります。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-236">If the application sees a spatial surface with a known ID but with a new update time, it should treat this as an updated spatial surface.</span></span>
* <span data-ttu-id="b0b0b-237">既知の ID を持つ空間サーフェスがアプリケーションに表示されなくなった場合は、これを削除された空間サーフェスとして扱います。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-237">If the application no longer sees a spatial surface with a known ID, it should treat this as a removed spatial surface.</span></span>

<span data-ttu-id="b0b0b-238">次に、各アプリケーションに対して次の選択を行います。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-238">It is up to each application to then make the following choices:</span></span>
* <span data-ttu-id="b0b0b-239">新しい空間サーフェスの場合、メッシュを要求する必要がありますか。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-239">For new spatial surfaces, should mesh be requested?</span></span>
   * <span data-ttu-id="b0b0b-240">通常メッシュは、新しい空間サーフェスに対してすぐに要求する必要があります。これにより、ユーザーに有用な新しい情報が提供される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-240">Generally mesh should be requested immediately for new spatial surfaces, which may provide useful new information to the user.</span></span>
   * <span data-ttu-id="b0b0b-241">ただし、ユーザーの前と前にある新しい空間サーフェスに優先順位を付け、そのメッシュを最初に要求する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-241">However, new spatial surfaces near and in front of the user should be given priority and their mesh should be requested first.</span></span>
   * <span data-ttu-id="b0b0b-242">新しいメッシュが必要ない場合、たとえば、アプリケーションが環境のモデルを永続的または一時的に "フリーズ" している場合は、そのモデルを要求しないようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-242">If the new mesh is not needed, if for example the application has permanently or temporarily 'frozen' its model of the environment, then it should not be requested.</span></span>
* <span data-ttu-id="b0b0b-243">更新された空間サーフェスの場合、メッシュを要求する必要がありますか。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-243">For updated spatial surfaces, should mesh be requested?</span></span>
   * <span data-ttu-id="b0b0b-244">ユーザーの前と手前にある更新された空間サーフェスに優先順位を付け、そのメッシュを最初に要求する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-244">Updated spatial surfaces near and in front of the user should be given priority and their mesh should be requested first.</span></span>
   * <span data-ttu-id="b0b0b-245">また、特にスキャンエクスペリエンス中に、更新されたサーフェイスよりも新しいサーフェイスに優先順位を付けることが適切な場合もあります。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-245">It may also be appropriate to give higher priority to new surfaces than to updated surfaces, especially during the scanning experience.</span></span>
   * <span data-ttu-id="b0b0b-246">処理コストを制限するために、アプリケーションでは、空間サーフェスへの更新を処理する速度を調整することが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-246">To limit processing costs, applications may wish to throttle the rate at which they process updates to spatial surfaces.</span></span>
   * <span data-ttu-id="b0b0b-247">たとえば、サーフェイスの境界が小さい場合など、空間サーフェスに対する変更は軽微であると推測できます。この場合、更新は処理するのに十分ではない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-247">It may be possible to infer that changes to a spatial surface are minor, for example if the bounds of the surface are small, in which case the update may not be important enough to process.</span></span>
   * <span data-ttu-id="b0b0b-248">現在のユーザーの関心領域外の空間サーフェスに対する更新は完全に無視される場合がありますが、この場合は、surface オブザーバーによって使用されている空間境界ボリュームを変更する方が効率的な場合があります。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-248">Updates to spatial surfaces outside the current region of interest of the user may be ignored entirely, though in this case it may be more efficient to modify the spatial bounding volumes in use by the surface observer.</span></span>
* <span data-ttu-id="b0b0b-249">削除された空間サーフェスの場合、メッシュを破棄する必要がありますか。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-249">For removed spatial surfaces, should mesh be discarded?</span></span>
   * <span data-ttu-id="b0b0b-250">通常メッシュは、削除された空間サーフェスに対して直ちに破棄され、ホログラムの閉鎖が適切な状態のままになります。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-250">Generally mesh should be discarded immediately for removed spatial surfaces, so that hologram occlusion remains correct.</span></span>
   * <span data-ttu-id="b0b0b-251">ただし、アプリケーションが (ユーザーエクスペリエンスの設計に基づいて) 後すぐに空間サーフェスを再表示するという理由がある場合は、メッシュを破棄して後で再作成するよりも、それを保持する方が効率的な場合があります。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-251">However, if the application has reason to believe that a spatial surface will reappear shortly (perhaps based upon the design of the user experience), then it may be more efficient to retain it than to discard its mesh and recreate it again later.</span></span>
   * <span data-ttu-id="b0b0b-252">アプリケーションがユーザーの環境の大規模なモデルを構築している場合、メッシュを破棄したくない場合があります。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-252">If the application is building a large-scale model of the user's environment then it may not wish to discard any meshes at all.</span></span> <span data-ttu-id="b0b0b-253">ただし、空間サーフェスが表示されなくなったときにメッシュをディスクにスプールすることによって、リソースの使用量を制限する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-253">It will still need to limit resource usage though, possibly by spooling meshes to disk as spatial surfaces disappear.</span></span>
   * <span data-ttu-id="b0b0b-254">空間サーフェスの生成中に比較的まれなイベントが発生すると、空間サーフェスが、同じ場所の新しい空間サーフェスに置き換えられることがありますが、Id が異なることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-254">Note that some relatively rare events during spatial surface generation can cause spatial surfaces to be replaced by new spatial surfaces in a similar location but with different IDs.</span></span> <span data-ttu-id="b0b0b-255">そのため、削除されたサーフェイスを破棄しないことを選択したアプリケーションは、同じ場所をカバーする複数の高重複空間サーフェスメッシュによって終了しないように注意する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-255">Consequently, applications that choose not to discard a removed surface should take care not to end up with multiple highly-overlapped spatial surface meshes covering the same location.</span></span>
* <span data-ttu-id="b0b0b-256">他の空間サーフェイスではメッシュを破棄する必要がありますか。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-256">Should mesh be discarded for any other spatial surfaces?</span></span>
   * <span data-ttu-id="b0b0b-257">空間サーフェイスが存在していても、ユーザーのエクスペリエンスには不要になった場合は、破棄する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-257">Even while a spatial surface exists, if it is no longer useful to the user's experience then it should be discarded.</span></span> <span data-ttu-id="b0b0b-258">たとえば、アプリケーションが入室のもう一方の側の部屋を代替仮想空間と置き換える場合、そのルームの空間サーフェスは不要になります。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-258">For example, if the application 'replaces' the room on the other side of a doorway with an alternate virtual space then the spatial surfaces in that room no longer matter.</span></span>

<span data-ttu-id="b0b0b-259">次に、空間とテンポラルヒステリシスを使用したメッシュキャッシュ方法の例を示します。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-259">Here is an example mesh caching strategy, using spatial and temporal hysteresis:</span></span>
* <span data-ttu-id="b0b0b-260">アプリケーションでは、ユーザーの宝石に沿って視される、視錐のある空間ボリュームを使用することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-260">Consider an application that wishes to use a frustum-shaped spatial volume of interest that follows the user's gaze as they look around and walk around.</span></span>
* <span data-ttu-id="b0b0b-261">空間サーフェスがこのボリュームから一時的に消える可能性があるのは、ユーザーがその画面から離れた場所から離れているためです。後でもう一度参照するか、さらに近い位置に移動します。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-261">A spatial surface may disappear temporarily from this volume simply because the user looks away from the surface or steps further away from it... only to look back or moves closer again a moment later.</span></span> <span data-ttu-id="b0b0b-262">この場合、このサーフェイスのメッシュを破棄して再作成すると、大量の冗長処理が発生します。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-262">In this case, discarding and re-creating the mesh for this surface represents a lot of redundant processing.</span></span>
* <span data-ttu-id="b0b0b-263">処理される変更の数を減らすために、アプリケーションは2つの空間サーフェスオブザーバーを使用します。1つは他方に含まれています。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-263">To reduce the number of changes processed, the application uses two spatial surface observers, one contained within the other.</span></span> <span data-ttu-id="b0b0b-264">大きいボリュームは球面で、ユーザーの ' 遅延 ' に従います。必要な場合にのみ移動し、そのセンターがユーザーの 2.0 metres 内にあることを確認します。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-264">The larger volume is spherical and follows the user 'lazily'; it only moves when necessary to ensure that its centre is within 2.0 metres of the user.</span></span>
* <span data-ttu-id="b0b0b-265">新規および更新された空間サーフェスメッシュは、常に小さい内部サーフェスオブザーバーから処理されますが、メッシュは大きな外部サーフェスオブザーバーから見えなくなるまでキャッシュされます。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-265">New and updated spatial surface meshes are always processed from the smaller inner surface observer, but meshes are cached until they disappear from the larger outer surface observer.</span></span> <span data-ttu-id="b0b0b-266">これにより、アプリケーションは、ローカルユーザーの移動によって多くの冗長な変更を処理することを回避できます。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-266">This allows the application to avoid processing many redundant changes due to local user movement.</span></span>
* <span data-ttu-id="b0b0b-267">空間サーフェスは、追跡が失われることによって一時的に消去される場合もあるため、アプリケーションは、追跡の損失中に削除された空間サーフェスの破棄を延期します。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-267">Since a spatial surface may also disappear temporarily due to tracking loss, the application also defers discarding removed spatial surfaces during tracking loss.</span></span>
* <span data-ttu-id="b0b0b-268">一般に、アプリケーションでは、更新処理の減少とメモリ使用量の増加のトレードオフを評価して、最適なキャッシュ戦略を決定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-268">In general, an application should evaluate the tradeoff between reduced update processing and increased memory usage to determine its ideal caching strategy.</span></span>

## <a name="rendering"></a><span data-ttu-id="b0b0b-269">表示</span><span class="sxs-lookup"><span data-stu-id="b0b0b-269">Rendering</span></span>

<span data-ttu-id="b0b0b-270">空間マッピングメッシュがレンダリングに使用される傾向がある主な方法には、次の3つがあります。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-270">There are three primary ways in which spatial mapping meshes tend to be used for rendering:</span></span>
* <span data-ttu-id="b0b0b-271">Surface の視覚化の場合</span><span class="sxs-lookup"><span data-stu-id="b0b0b-271">For surface visualization</span></span>
   * <span data-ttu-id="b0b0b-272">多くの場合、空間サーフェスを直接視覚化すると便利です。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-272">It is often useful to visualize spatial surfaces directly.</span></span> <span data-ttu-id="b0b0b-273">たとえば、オブジェクトから空間サーフェスに ' shadows ' をキャストすると、サーフェイスにホログラムを配置するときに、視覚的なフィードバックをユーザーに提供できます。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-273">For example, casting 'shadows' from objects onto spatial surfaces can provide helpful visual feedback to the user while they are placing holograms on surfaces.</span></span>
   * <span data-ttu-id="b0b0b-274">空間メッシュは、3D アーティストによって作成されるメッシュの種類とは異なる点に注意してください。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-274">One thing to bear in mind is that spatial meshes are different to the kind of meshes that a 3D artist might create.</span></span> <span data-ttu-id="b0b0b-275">トライアングルトポロジは人間が作成したトポロジとして "クリーン" ではなく、メッシュが[さまざまなエラー](spatial-mapping-design.md#what-influences-spatial-mapping-quality)によって影響を受けます。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-275">The triangle topology will not be as 'clean' as human-created topology, and the mesh will suffer from [various errors](spatial-mapping-design.md#what-influences-spatial-mapping-quality).</span></span>
   * <span data-ttu-id="b0b0b-276">見栄えの良いビジュアルを作成するには、穴や smooth surface の法線を塗りつぶすなど、[メッシュ処理](spatial-mapping.md#mesh-processing)を実行することが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-276">In order to create a pleasing visual aesthetic, you may thus want to perform some [mesh processing](spatial-mapping.md#mesh-processing), for example to fill holes or smooth surface normals.</span></span> <span data-ttu-id="b0b0b-277">また、メッシュトポロジや法線を直接視覚化するのではなく、シェーダーを使用して、アーティストによって設計されたテクスチャをメッシュに射影することもできます。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-277">You may also wish to use a shader to project artist-designed textures onto your mesh instead of directly visualizing mesh topology and normals.</span></span>
* <span data-ttu-id="b0b0b-278">実際のサーフェイスの背後にある occluding ホログラムの場合</span><span class="sxs-lookup"><span data-stu-id="b0b0b-278">For occluding holograms behind real-world surfaces</span></span>
   * <span data-ttu-id="b0b0b-279">空間サーフェスは、[深度バッファー](https://msdn.microsoft.com/library/windows/desktop/bb219616(v=vs.85).aspx)にのみ影響を与え、カラーレンダーターゲットには影響しない、深度のみのパスでレンダリングできます。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-279">Spatial surfaces can be rendered in a depth-only pass which only affects the [depth buffer](https://msdn.microsoft.com/library/windows/desktop/bb219616(v=vs.85).aspx) and does not affect color render targets.</span></span>
   * <span data-ttu-id="b0b0b-280">これにより、空間サーフェスの背後でレンダリングされるホログラムを occlude するための深度バッファーが primes されます。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-280">This primes the depth buffer to occlude subsequently-rendered holograms behind spatial surfaces.</span></span> <span data-ttu-id="b0b0b-281">ホログラムを正確に遮蔽することで、ユーザーの物理的な領域内にホログラムが本当に存在するという意味が高まります。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-281">Accurate occlusion of holograms enhances the sense that holograms really exist within the user's physical space.</span></span>
   * <span data-ttu-id="b0b0b-282">深度のみのレンダリングを有効にするには、blend の状態を更新して、すべてのカラーレンダーターゲットで[RenderTargetWriteMask](https://msdn.microsoft.com/library/windows/desktop/hh404492(v=vs.85).aspx)を0に設定します。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-282">To enable depth-only rendering, update your blend state to set the [RenderTargetWriteMask](https://msdn.microsoft.com/library/windows/desktop/hh404492(v=vs.85).aspx) to zero for all color render targets.</span></span>
* <span data-ttu-id="b0b0b-283">実際のサーフェイスによるホログラム occluded の外観を変更するには</span><span class="sxs-lookup"><span data-stu-id="b0b0b-283">For modifying the appearance of holograms occluded by real-world surfaces</span></span>
   * <span data-ttu-id="b0b0b-284">通常表示されるジオメトリは、occluded すると非表示になります。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-284">Normally rendered geometry is hidden when it is occluded.</span></span> <span data-ttu-id="b0b0b-285">これを実現するには、深度ステンシルの[状態](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx)の depth 関数を "次の値以下" に設定します。これにより、以前にレンダリングされたすべてのジオメトリよりもカメラに**近い**場所にのみジオメトリが表示されるようになります。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-285">This is achieved by setting the depth function in your [depth-stencil state](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx) to "less than or equal", which causes geometry to be visible only where it is **closer** to the camera than all previously rendered geometry.</span></span>
   * <span data-ttu-id="b0b0b-286">ただし、特定のジオメトリが occluded されていても表示されないようにしたり、視覚的なフィードバックをユーザーに提供する手段として occluded したときの外観を変更したりすると便利な場合があります。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-286">However, it may be useful to keep certain geometry visible even when it is occluded, and to modify its appearance when occluded as a way of providing visual feedback to the user.</span></span> <span data-ttu-id="b0b0b-287">たとえば、これにより、アプリケーションは、実際の画面の背後にあることを明確にしながら、オブジェクトの場所をユーザーに表示できます。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-287">For example, this allows the application to show the user the location of an object whilst making it clear that is behind a real-world surface.</span></span>
   * <span data-ttu-id="b0b0b-288">これを実現するには、必要な ' occluded ' 外観を作成する別のシェーダーを使用して、ジオメトリをもう一度描画します。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-288">To achieve this, render the geometry a second time with a different shader that creates the desired 'occluded' appearance.</span></span> <span data-ttu-id="b0b0b-289">2回目のジオメトリをレンダリングする前に、[深度ステンシルの状態](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx)に2つの変更を加えます。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-289">Before rendering the geometry for the second time, make two changes to your [depth-stencil state](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx).</span></span> <span data-ttu-id="b0b0b-290">最初に、深度関数を "以上" に設定します。これにより、ジオメトリは、**以前にレンダリング**されたすべてのジオメトリよりもカメラから見た場合にのみ表示されるようになります。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-290">First, set the depth function to "greater than or equal" so that the geometry will be visible only where it is **further** from the camera than all previously rendered geometry.</span></span> <span data-ttu-id="b0b0b-291">次に、DepthWriteMask を0に設定して、深度バッファーが変更されないようにします (深度バッファーは、カメラに**最も近い**ジオメトリの深さを継続して表す必要があります)。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-291">Second, set the DepthWriteMask to zero, so that the depth buffer will not be modified (the depth buffer should continue to represent the depth of the geometry **closest** to the camera).</span></span>

<span data-ttu-id="b0b0b-292">空間マッピングメッシュをレンダリングする場合、[パフォーマンス](understanding-performance-for-mixed-reality.md)は重要な問題です。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-292">[Performance](understanding-performance-for-mixed-reality.md) is an important concern when rendering spatial mapping meshes.</span></span> <span data-ttu-id="b0b0b-293">空間マッピングメッシュのレンダリングに固有のレンダリングパフォーマンス手法を次に示します。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-293">Here are some rendering performance techniques specific to rendering spatial mapping meshes:</span></span>
* <span data-ttu-id="b0b0b-294">三角形の密度を調整する</span><span class="sxs-lookup"><span data-stu-id="b0b0b-294">Adjust triangle density</span></span>
   * <span data-ttu-id="b0b0b-295">Surface オブザーバーから空間サーフェスメッシュを要求するときは、必要に応じて十分な三角形メッシュの最低密度を要求します。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-295">When requesting spatial surface meshes from your surface observer, request the lowest density of triangle meshes that will suffice for your needs.</span></span>
   * <span data-ttu-id="b0b0b-296">画面上の三角形の密度は、ユーザーからの距離とユーザーエクスペリエンスに対する関係に応じて、サーフェス単位で変化させることができます。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-296">It may make sense to vary triangle density on a surface by surface basis, depending on the surface's distance from the user, and its relevance to the user experience.</span></span>
   * <span data-ttu-id="b0b0b-297">トライアングル数を減らすと、GPU のメモリ使用量と頂点処理コストが削減されますが、ピクセル処理のコストには影響しません。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-297">Reducing triangle counts will reduce memory usage and vertex processing costs on the GPU, though it will not affect pixel processing costs.</span></span>
* <span data-ttu-id="b0b0b-298">錐のあるカリングを実行する</span><span class="sxs-lookup"><span data-stu-id="b0b0b-298">Perform frustum culling</span></span>
   * <span data-ttu-id="b0b0b-299">視錐台のカリングは、表示できない描画オブジェクトをスキップします。これは、現在のディスプレイが視錐であるためです。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-299">Frustum culling skips drawing objects that cannot be seen because they are outside the current display frustum.</span></span> <span data-ttu-id="b0b0b-300">これにより、CPU と GPU の両方の処理コストが削減されます。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-300">This reduces both CPU and GPU processing costs.</span></span>
   * <span data-ttu-id="b0b0b-301">カリングはメッシュごとに実行されるため、空間サーフェスは大きくなる可能性があるため、各空間サーフェスメッシュを小さなチャンクに分割すると、より効率的なカリングを実現できます (オフスクリーンの三角形がレンダリングされます)。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-301">Since culling is performed on a per-mesh basis and spatial surfaces can be large, breaking each spatial surface mesh into smaller chunks may result in more efficient culling (in that fewer offscreen triangles are rendered).</span></span> <span data-ttu-id="b0b0b-302">ただし、トレードオフがあります。メッシュ数が多いほど描画呼び出しが多くなるため、CPU コストが増加する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-302">There is a tradeoff, however; the more meshes you have, the more draw calls you must make, which can increase CPU costs.</span></span> <span data-ttu-id="b0b0b-303">極端なケースでは、錐のあるカリングの計算自体が、測定可能な CPU コストを持つことさえあります。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-303">In an extreme case, the frustum culling calculations themselves could even have a measurable CPU cost.</span></span>
* <span data-ttu-id="b0b0b-304">レンダリング順序の調整</span><span class="sxs-lookup"><span data-stu-id="b0b0b-304">Adjust rendering order</span></span>
   * <span data-ttu-id="b0b0b-305">空間サーフェスは、周囲のユーザーの環境全体を表しているため、サイズが大きくなる傾向があります。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-305">Spatial surfaces tend to be large, because they represent the user's entire environment surrounding them.</span></span> <span data-ttu-id="b0b0b-306">これにより、GPU のピクセル処理コストが高くなる可能性があります。これは特に、可視ジオメトリのレイヤーが複数存在する場合 (空間サーフェスとその他のホログラムを含む) の場合に特に当てはまります。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-306">Pixel processing costs on the GPU can thus be high, especially in cases where there is more than one layer of visible geometry (including both spatial surfaces and other holograms).</span></span> <span data-ttu-id="b0b0b-307">この場合、ユーザーに最も近いレイヤーはさらにレイヤーを occluding するため、遠くのレイヤーをレンダリングするのに費やされた GPU 時間は無駄になります。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-307">In this case, the layer nearest to the user will be occluding any layers further away, so any GPU time spent rendering those more distant layers is wasted.</span></span>
   * <span data-ttu-id="b0b0b-308">GPU 上のこの冗長な作業を減らすために、不透明なサーフェスを前方から後方にレンダリングするのに役立ちます (先に近い順にします)。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-308">To reduce this redundant work on the GPU, it helps to render opaque surfaces in front-to-back order (closer ones first, more distant ones last).</span></span> <span data-ttu-id="b0b0b-309">' 不透明 ' では、DepthWriteMask が[深度ステンシルの状態](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx)で1に設定されているサーフェイスを意味します。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-309">By 'opaque' we mean surfaces for which the DepthWriteMask is set to one in your [depth-stencil state](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx).</span></span> <span data-ttu-id="b0b0b-310">最も近いサーフェイスがレンダリングされると、GPU のピクセルプロセッサによって遠く離れたサーフェイスが効率的にスキップされるように、深度バッファーが最適になります。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-310">When the nearest surfaces are rendered, they will prime the depth buffer so that more distant surfaces are efficiently skipped by the pixel processor on the GPU.</span></span>

## <a name="mesh-processing"></a><span data-ttu-id="b0b0b-311">メッシュ処理</span><span class="sxs-lookup"><span data-stu-id="b0b0b-311">Mesh Processing</span></span>

<span data-ttu-id="b0b0b-312">アプリケーションでは、必要に応じて、空間サーフェスメッシュに対して[さまざまな操作](spatial-mapping.md#mesh-processing)を実行することができます。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-312">An application may want to perform [various operations](spatial-mapping.md#mesh-processing) on spatial surface meshes to suit its needs.</span></span> <span data-ttu-id="b0b0b-313">各空間サーフェスメッシュで提供されるインデックスおよび頂点データは、すべての最新のレンダリング Api で三角形メッシュをレンダリングするために使用される[頂点およびインデックスバッファー](https://msdn.microsoft.com/library/windows/desktop/bb147325%28v=vs.85%29.aspx)と同じ使い慣れたレイアウトを使用します。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-313">The index and vertex data provided with each spatial surface mesh uses the same familiar layout as the [vertex and index buffers](https://msdn.microsoft.com/library/windows/desktop/bb147325%28v=vs.85%29.aspx) that are used for rendering triangle meshes in all modern rendering APIs.</span></span> <span data-ttu-id="b0b0b-314">ただし、重要な1つの重要な点は、空間マッピングの三角形には、**反時計回りの回転順序**があるということです。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-314">However, one key fact to be aware of is that spatial mapping triangles have a **front-clockwise winding order**.</span></span> <span data-ttu-id="b0b0b-315">各三角形はメッシュのインデックスバッファー内の3つの頂点インデックスによって表されます。これらのインデックスは、三角形が**正面**から表示されるときに、三角形の頂点を**時計回り**の順序で識別します。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-315">Each triangle is represented by three vertex indices in the mesh's index buffer and these indices will identify the triangle's vertices in a **clockwise** order, when the triangle is viewed from the **front** side.</span></span> <span data-ttu-id="b0b0b-316">空間サーフェスメッシュの前面 (または外側) は、実際のサーフェイスの前面 (表示されている側) に期待されるように対応します。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-316">The front side (or outside) of spatial surface meshes corresponds as you would expect to the front (visible) side of real world surfaces.</span></span>

<span data-ttu-id="b0b0b-317">アプリケーションでは、surface オブザーバーによって提供される coarsest 三角形の密度がまだ粗いことがない場合にのみメッシュの単純化を実行する必要があります。この作業は負荷が高く、ランタイムがさまざまなを生成するために既に実行されています。提供される詳細レベル。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-317">Applications should only perform mesh simplification if the coarsest triangle density provided by the surface observer is still insufficiently coarse - this work is computationally expensive and already being performed by the runtime to generate the various provided levels of detail.</span></span>

<span data-ttu-id="b0b0b-318">各サーフェイスオブザーバーは複数の未接続空間サーフェスを提供できるため、アプリケーションによっては、これらの空間サーフェスメッシュを相互にクリップし、それらをまとめて zipper ことが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-318">Because each surface observer can provide multiple unconnected spatial surfaces, some applications may wish to clip these spatial surface meshes against each other, then zipper them together.</span></span> <span data-ttu-id="b0b0b-319">一般的に、隣接する空間サーフェスメッシュが少し重なっているため、クリッピング手順が必要です。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-319">In general, the clipping step is required, as nearby spatial surface meshes often overlap slightly.</span></span>

## <a name="raycasting-and-collision"></a><span data-ttu-id="b0b0b-320">Raycasting と競合</span><span class="sxs-lookup"><span data-stu-id="b0b0b-320">Raycasting and Collision</span></span>

<span data-ttu-id="b0b0b-321">アプリケーションで空間サーフェスの raycasting および衝突機能を使用できるようにするために、物理 API (の場合は、等[ok](http://www.havok.com/)) では、アプリケーションで物理 api に空間サーフェスメッシュを提供する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-321">In order for a physics API (such as [Havok](http://www.havok.com/)) to provide an application with raycasting and collision functionality for spatial surfaces, the application must provide spatial surface meshes to the physics API.</span></span> <span data-ttu-id="b0b0b-322">物理に使用されるメッシュには、次の特性があります。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-322">Meshes used for physics often have the following properties:</span></span>
* <span data-ttu-id="b0b0b-323">これらには、少数の三角形しか含まれていません。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-323">They contain only small numbers of triangles.</span></span> <span data-ttu-id="b0b0b-324">物理操作は、レンダリング操作よりも計算が多くなります。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-324">Physics operations are more computationally intensive than rendering operations.</span></span>
* <span data-ttu-id="b0b0b-325">このような場合は、"水がきつい" になります。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-325">They are 'water-tight'.</span></span> <span data-ttu-id="b0b0b-326">ソリッドであることを意図したサーフェスは、小さな穴を持つことはできません。表示できない穴が小さすぎる場合でも、問題が発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-326">Surfaces intended to be solid should not have small holes in them; even holes too small to be visible can cause problems.</span></span>
* <span data-ttu-id="b0b0b-327">これらは、凸状 hulls に変換されます。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-327">They are converted into convex hulls.</span></span> <span data-ttu-id="b0b0b-328">凸状の hulls にはいくつかのポリゴンがあり、穴は不要であり、生の三角形メッシュよりも処理がはるかに効率的です。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-328">Convex hulls have few polygons and are free of holes, and they are much more computationally efficient to process than raw triangle meshes.</span></span>

<span data-ttu-id="b0b0b-329">空間サーフェスに対して raycasts を実行するときは、机のように、これらのサーフェスが複雑で、乱雑なものではないことに注意してください。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-329">When performing raycasts against spatial surfaces, bear in mind that these surfaces are often complex, cluttered shapes full of messy little details - just like your desk!</span></span> <span data-ttu-id="b0b0b-330">つまり、1つの raycast では、画面の形状や、その近くにある空の領域の形状に関する十分な情報を得ることができません。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-330">This means that a single raycast is often insufficient to give you enough information about the shape of the surface and the shape of the empty space near it.</span></span> <span data-ttu-id="b0b0b-331">そのため、通常は小さな領域内で多くの raycasts を実行し、集計結果を使用して、より信頼性の高いサーフェイスの理解を得ることをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-331">It is thus usually a good idea to perform many raycasts within a small area and to use the aggregate results to derive a more reliable understanding of the surface.</span></span> <span data-ttu-id="b0b0b-332">たとえば、平均 10 raycasts を使用して、表面にホログラムの配置を行うと、1つの raycast だけを使用して、はるかに滑らかで "ちらつき" の結果が得られます。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-332">For example, using the average of 10 raycasts to guide hologram placement on a surface will yield a far smoother and less 'jittery' result that using just a single raycast.</span></span>

<span data-ttu-id="b0b0b-333">ただし、raycast ごとに計算コストが高くなる可能性があることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-333">However, bear in mind that each raycast can have a high computational cost.</span></span> <span data-ttu-id="b0b0b-334">したがって、使用シナリオによっては、(すべてのフレームで実行された) 追加の raycasts の計算コストと[メッシュ処理](spatial-mapping.md#mesh-processing)の計算コストを比較して、空間サーフェスの穴を滑らかにしたり削除したり (空間で実行) する必要があります。メッシュが更新されます。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-334">Thus depending on your usage scenario you should trade off the computational cost of additional raycasts (performed every frame) against the computational cost of [mesh processing](spatial-mapping.md#mesh-processing) to smooth and remove holes in spatial surfaces (performed when spatial meshes are updated).</span></span>

## <a name="troubleshooting"></a><span data-ttu-id="b0b0b-335">トラブルシューティング</span><span class="sxs-lookup"><span data-stu-id="b0b0b-335">Troubleshooting</span></span>
* <span data-ttu-id="b0b0b-336">サーフェスメッシュを適切に配置するためには、各 SurfaceObeserver オブジェクトをアクティブにしてから、メッシュが構築されるようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-336">In order for the surface meshes to be orientated correctly, each GameObject needs to be active before it is sent to the SurfaceObeserver to have its mesh constructed.</span></span> <span data-ttu-id="b0b0b-337">そうしないと、メッシュはスペースに表示されますが、回転角度は変わってきます。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-337">Otherwise, the meshes will show up in your space but rotated at weird angles.</span></span>
* <span data-ttu-id="b0b0b-338">SurfaceObserver と通信するスクリプトを実行するオブジェクトは、オリジンに設定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-338">The GameObject that runs the script that communicates with the SurfaceObserver needs to be set to the origin.</span></span> <span data-ttu-id="b0b0b-339">そうしないと、メッシュを構築するために作成して SurfaceObserver に送信するすべてのゲームオブジェクトが、親 Game オブジェクトのオフセットと同じオフセットを持つことになります。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-339">Otherwise, all of GameObjects that you create and send to the SurfaceObserver to have their meshes constructed will have an offset equal to the offset of the Parent Game Object.</span></span> <span data-ttu-id="b0b0b-340">これにより、メッシュがいくつかのメーターを表示して、何が起こっているかを簡単にデバッグできるようになります。</span><span class="sxs-lookup"><span data-stu-id="b0b0b-340">This can make your meshes show up several meters away which makes it very hard to debug what is going on.</span></span>

## <a name="see-also"></a><span data-ttu-id="b0b0b-341">関連項目</span><span class="sxs-lookup"><span data-stu-id="b0b0b-341">See also</span></span>
* [<span data-ttu-id="b0b0b-342">座標系</span><span class="sxs-lookup"><span data-stu-id="b0b0b-342">Coordinate systems</span></span>](coordinate-systems.md)
* [<span data-ttu-id="b0b0b-343">DirectX の空間マッピング</span><span class="sxs-lookup"><span data-stu-id="b0b0b-343">Spatial mapping in DirectX</span></span>](spatial-mapping-in-directx.md)
* [<span data-ttu-id="b0b0b-344">Unity の空間マッピング</span><span class="sxs-lookup"><span data-stu-id="b0b0b-344">Spatial mapping in Unity</span></span>](spatial-mapping-in-unity.md)
* [<span data-ttu-id="b0b0b-345">空間マッピングの設計</span><span class="sxs-lookup"><span data-stu-id="b0b0b-345">Spatial mapping design</span></span>](spatial-mapping-design.md)
* [<span data-ttu-id="b0b0b-346">ケース スタディ - Mixed Reality で穴から覗く</span><span class="sxs-lookup"><span data-stu-id="b0b0b-346">Case study - Looking through holes in your reality</span></span>](case-study-looking-through-holes-in-your-reality.md)
