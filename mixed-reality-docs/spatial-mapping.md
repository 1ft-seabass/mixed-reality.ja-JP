---
title: 空間マッピング
description: 空間マッピングは、HoloLens、周りの環境で現実世界のサーフェスの詳細な表現を提供します。
author: mattzmsft
ms.author: mazeller
ms.date: 03/21/2018
ms.topic: article
keywords: 空間マッピング、HoloLens、複合現実、画面の再構築、メッシュ、sr
ms.openlocfilehash: 31abeca624512f1d5e721dbe879ca2243cf41345
ms.sourcegitcommit: 384b0087899cd835a3a965f75c6f6c607c9edd1b
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/12/2019
ms.locfileid: "59605041"
---
# <a name="spatial-mapping"></a>空間マッピング

空間マッピングは、真に迫った複合現実エクスペリエンスを作成でき、HoloLens、周りの環境で現実世界のサーフェスの詳しい表現を提供します。 仮想世界で現実世界をマージすることで、アプリケーションは実際と思われるホログラムを行うことができます。 アプリケーションも揃えることがより自然でユーザーの期待使い慣れた実際の動作と相互作用を提供することで。

<br>

>[!VIDEO https://www.youtube.com/embed/zff2aQ1RaVo]

## <a name="device-support"></a>デバイスのサポート

<table>
<tr>
<th>機能</th><th style="width:150px"> <a href="hololens-hardware-details.md">HoloLens (第 1 世代)</a></th><th style="width:150px">HoloLens 2</th><th style="width:150px"> <a href="immersive-headset-hardware-details.md">イマーシブ ヘッドセット</a></th>
</tr><tr>
<td> 空間マッピング</td><td style="text-align: center;"> ✔️</td><td style="text-align: center;"> ✔️</td><td style="text-align: center;"></td>
</tr>
</table>



## <a name="conceptual-overview"></a>概念の概要

![ルームをカバーするメッシュ サーフェス](images/SurfaceReconstruction.jpg)<br>
*ルームをカバーする空間マッピング メッシュの例*

空間マッピングに使用される 2 つのプライマリ オブジェクトの種類には、' 空間画面のオブザーバー 'および' 空間画面 ' です。

空間マッピング データを受信するアプリケーションが望んでいる領域の領域を定義する 1 つまたは複数の外接するボリュームで空間画面オブザーバーは、アプリケーションに提供します。 これらのボリュームごとに、空間マッピングは一連の空間のサーフェスのアプリケーションを提供します。

これらのボリュームが静止している (現実の世界に対して固定の場所) 内か、HoloLens (、移動しますが、回転しない、HoloLens のように、環境を移動するとき) に接続されている可能性があります。 各空間のサーフェスは、世界ロックにアタッチされている三角形メッシュとして表される領域のサイズの小さいボリューム内の実際のサーフェスを説明します。[空間座標系](coordinate-systems.md)します。

HoloLens、環境に関する新しいデータを収集し、空間のサーフェスが表示されます、環境への変更が発生すると、非表示し、変更します。

## <a name="common-usage-scenarios"></a>一般的な使用シナリオ

![空間マッピングの一般的な使用シナリオの図。配置、オクルー ジョン、物理運動およびナビゲーション](images/sm-concepts-1000px.png)

### <a name="placement"></a>配置

空間マッピングは、ユーザーには相互作用のフォームを自然かつ使い慣れたをもたらすアプリケーションを提供します。ダウン、デスクに電話を配置するよりもより自然などのような可能性がありますか。

ホログラムの配置の制約 (より一般的には、空間的な場所の選択) サーフェス上に存在するには、2 D (画面上のポイント) を 3D (空間内の点) から自然なマッピングを提供します。 します。 これには、ユーザーがアプリケーションに提供する必要があるし、ことができ、ユーザーの操作より速くより簡単より正確な情報の量が削減されます。 これは、機能は、'離れた距離' がないため物理的に他のユーザーまたはコンピューターの通信に提供されることに特に当てはまります。 したのでポイントすると、指定するは、方向が距離ではありません。

アプリケーションの方向からの距離を推論するときに、重要な注意点は (に最も近いを検索するユーザーの視線入力方向の raycast を実行することなどによって空間画面)、このユーザーが確実に予測できる結果を生成する必要があります。 それ以外の場合、ユーザーがコントロールの意味が失われ、これがすぐにイライラします。 1 つだけではなく複数 raycasts を実行することにより、この方法の 1 つです。 集計の結果より滑らかなより予測可能な (小さな穴に渡されるまたは少量のユーザーは認識しないジオメトリのヒット光線によって発生すること) と '外れ値' で一時的な結果に影響を与えるに受けにくくなりますがあります。 時間の経過とともに集計やスムージングを実行することもたとえば、ユーザーからの距離をホログラムはさまざま最大速度を制限できます。 距離の最小値と最大値を単に制限することができます、ので、移動されるホログラムが飛行距離にまたはユーザーの顔に絞めるして突然されません。

アプリケーションは、ガイド ホログラム配置する、図形とサーフェスの方向を使用できますも。 Holographic 椅子は壁を通過する必要がありますいないと、少しでもない場合でも、フロアでフラッシュ配置する必要があります。 このような機能は、ただしのような懸念事項が適用されます、単なる raycasts ではなく、物理運動の衝突の使用時に依存する可能性があります。 配置されているホログラムが突き出した、椅子、足のような多くの小規模な多角形が賢明せず空間サーフェス上のスライドことができるようにも縦と横より滑らかなものにこれらの多角形の物理運動の表現を拡張するにはキャプチャします。

極端な場合、ユーザー入力を簡略化できます離れた完全と完全に自動化ホログラム配置を実行する空間のサーフェスを使用できます。 たとえば、アプリケーションでしたを置いて holographic のライトの切り替えを押すユーザーのウォールにします。 二重ここでは予測可能性についてこの注意事項が適用されます。ユーザーが求めるホログラムの配置を制御、アプリケーションは常に設定されませんホログラム (ライトの切り替えでは、ユーザーに到達できない別の場所が表示されます) 場合が期待される場合は、フラストレーションにこのなります。 ユーザーの修正を必要とする自動配置を実行する悪い場合があります実際には、配置を自体は常に実行するユーザーに必要なだけよりも、時間の一部自動配置が成功したため*予想*負担のような気持ちに手動で修正。

また、配置は、アプリケーションに大きく依存する場合は、空間のサーフェスを使用するアプリケーションの機能[エクスペリエンスをスキャン](spatial-mapping-design.md#the-environment-scanning-experience)します。 サーフェスがスキャンされていない場合は、配置に使用できません。 これをユーザーにクリアようにする新しい画面をスキャンまたは新しい場所の選択がわかるか、アプリケーションの責任です。

ユーザーに視覚的なフィードバックは、配置時に最も重要です。 ユーザーに最も近い画面関連ホログラムが場所がわかっている必要のある[効果の接地](spatial-mapping.md#visualization)します。 (たとえば、衝突と他の画面の近くにある) ため、ホログラムの動きが制約されている理由を理解する必要があります。 場合は、現在の場所、ホログラムを配置することはできません、し、視覚的なフィードバックする必要があります明確になる理由されません。 たとえば、配置しようとして、ユーザー holographic ソファ停止途中、壁に怒っている色で、壁の背後にある、カウチの部分が規則正しく必要がありますし、します。 または、反対に、アプリケーションは、実際の画面を表示できる場所で空間のサーフェスを見つけることができない場合、アプリケーションでは、このクリアします。 この領域の接地効果の明確ながない場合は、この目的を達成可能性があります。

### <a name="occlusion"></a>オクルージョン

空間マッピング サーフェスの主な用途の 1 つは、ホログラムがすることです。 この単純な動作は、ホログラムを本当に、ユーザーと同じ物理領域に存在する本能的な意味を作り出すためのユーザーの体感よりリアルに大きな影響を及ぼします。

オクルー ジョン、ユーザーには情報も提供しますホログラムは、実際の画面によってオクルー ジョンするが表示されたら、この世界では、そのホログラムの所在地に関して追加の視覚的フィードバックを提供します。 逆に、遮蔽ができますも有効*を非表示に*ユーザーからの情報は、直感的な方法でビジュアルをすっきり壁が背後にある他ホログラムします。 ホログラムを表示または非表示に、ユーザーは自分の頭を移動するだけですが。

重なりを使用して使い慣れた物理的な相互作用; に基づいて自然なユーザー インターフェイスに対する期待を準備することもできます。ホログラムがその画面が堅牢ですサーフェスによってオクルー ジョンされた場合、そのため、期待されるホログラムは*衝突*を画面し、だけでなく通過します。

場合によっては、オクルー ジョン ホログラムは望ましくありません。 ホログラムと対話できるように、ユーザーに必要な場合は、実際の画面の内側にある場合でも - 表示できないようにする、必要があります。 このような場合は、通常は理にかなって (たとえばは明るさを減らすこと) で、オクルー ジョンはときに、このようなホログラムを異なる方法でレンダリングします。 これにより、ユーザーは、ホログラムを視覚的に見つけられませんされますが、何かの内側にあることに注意してくださいができます。

### <a name="physics"></a>物理学

物理運動のシミュレーションの使用は、別の方法を補強する空間マッピングを使用できます、*プレゼンス*ホログラムでユーザーの物理的なスペースの。 Holographic ゴム ボールみたいだったよは私の机から現実的にはロールし、フロア間 bounces、ソファでは表示されなくなります、ハードすることが本当に存在しないと思われる場合があります。

物理運動のシミュレーションには、自然かつ使い慣れた物理ベースの相互作用を使用するアプリケーションにとっての機会も提供します。 床の上 holographic 家具の周囲の一部を移動する可能性がありますしやすくなります、ユーザーの家具が慣性による処理の適切な摩擦と床面の間で、スライディングされたかのように応答する場合。

実際の物理的な動作を生成するために必要がありますをいくつか実行[メッシュ処理](spatial-mapping.md#mesh-processing)などの穴を入力するには、削除 hallucinations のフローティング、およびスムージング概要サーフェス。

考慮する必要がありますも方法、アプリケーションの[エクスペリエンスをスキャン](spatial-mapping-design.md#the-environment-scanning-experience)物理運動のシミュレーションに影響を与えます。 まず、サーフェスが不足するいると競合しないものです。ラバー ボール長くて言い、回廊ダウンし、既知の世界の終わりと起こりますか。 次に、時間の経過と共に、環境内の変更に応答する続けますかどうかを決定する必要があります。 場合によっては、; できるだけ早く対応しますユーザーを使用しているドアや家具として移動可能な barricades Roman 受信の矢印のテンペストに対する防策であるとします。 それ以外の場合は、する可能性がある; の新しい更新プログラムを無視します。floor、holographic スポーツ カー レースの周りを促進できない可能性がありますが突然あなたの愛犬がトラックの途中で配置を決定した場合にとても楽しいからです。

### <a name="navigation"></a>ナビゲーション

アプリケーションでは、holographic の文字 (またはエージェント) は実在の人物と同じ方法で現実の世界を移動するのに機能を許可するのに空間のマッピング データを使用できます。 こうと、同じユーザーとその友達の自然でなじみのある動作のセットに制限することによって holographic 文字の存在を強調します。

ナビゲーション機能は、ユーザーにも役立つことがあります。 ナビゲーションのマップが特定の領域にビルドされたら、その場所に新しいユーザーの未知の holographic の方向を提供する共有でした。 このマップは、フローを円滑に '歩行者 'トラフィックを保つために、またはサイトの構築のような危険な場所での事故を回避するために設計する可能性があります。

ナビゲーション機能の実装に関連するキーの技術的課題をウォークのサーフェス (人間は、テーブルのウォークはありません)。! (人間しない順を追ってドアが閉じられた!) 環境での変更を正常な適応の信頼性の高い検出となります。 メッシュには、いくつか必要があります[処理](spatial-mapping.md#mesh-processing)パスの計画と仮想の文字でナビゲーション用に使用する前にします。 メッシュをスムージングおよび hallucinations の削除により、スタックになる文字を避けることができます。 文字のパスの計画およびナビゲーションの計算を高速化するには、メッシュを大幅に簡略化することもできます。 これらの課題がテレビ ゲームのテクノロジの開発に多くの注意を受信し、豊富なこれらのトピックの使用可能な研究文献があります。

空間マッピング サーフェスと Unity の組み込み NavMesh の機能を使用できないことに注意してください。 空間マッピング サーフェスは、アプリケーションまで不明なので、これは事前に資産をソースから生成される NavMesh データ ファイルが必要ですが、起動します。 空間マッピング システムで提供しないことに注意してください[サーフェスを非常に離れたについて](spatial-mapping-design.md#the-environment-scanning-experience)ユーザーの現在の場所から。 アプリケーションする必要があります 'ことを思い出してください' サーフェス自体は非常に大きな領域のマップを作成する場合。

### <a name="visualization"></a>視覚エフェクト

ほとんどの場合、表示する空間のサーフェスに適していますvisual 煩雑さを最小限にし、実際には、世界は、自身の読み上げます。 場合もありますが、実際の対応は既に表示されているにもかかわらず空間マッピングのサーフェスを直接、視覚化すると便利です。

ホログラム (配置 holographic キャビネット、壁になど) を表面に配置する、ユーザーが試みているときになど、画面上に影をキャストすることによって、ホログラムが 'アース' 立つことができます。 これにより、ユーザーはわかりやすく納得ホログラムと、画面間の正確な物理的近接の。 これは、視覚的に 'プレビューの' を変更して、ユーザーがコミットする前より一般的なプラクティスの例でも。

サーフェスを視覚化することで、アプリケーションは、環境の内容を理解、ユーザーと共有できます。 たとえばの holographic ボード ゲームは、ユーザーが対話する必要があります出るを認識できるようになどに、'テーブル' として特定された水平方向のサーフェスを視覚化します。

サーフェスを視覚化すると、近くの非表示にスペースをユーザーに表示する便利な方法を指定できます。 リビング ルーム、キッチン (とすべての包含ホログラムの) にユーザー アクセスを付与する簡単な方法を提供できます。

空間マッピングによって提供される表面メッシュは、特に 'クリーン' できない可能性があります。 そのためそれらを適切に視覚化する重要なは。 従来のライティング計算が、視覚的に見ればよい方法での表面法線のエラーを選択するには、「クリーン」テクスチャが、画面に投影するのにして外観を若干見やすくしています中します。 実行することも[メッシュ処理](spatial-mapping.md#mesh-processing)サーフェスがレンダリングされる前に、メッシュのプロパティを向上させるためにします。

## <a name="using-the-surface-observer"></a>画面のオブザーバーを使用します。

空間マッピングの開始点は、画面のオブザーバーです。 プログラム フローは次のとおりです。
* 画面のオブザーバー オブジェクトを作成します。
   * 空間マッピング データを受信するアプリケーションが望んでいる関心のある領域を定義する、1 つまたは複数の空間ボリュームを提供します。 空間ボリュームとは、球または直方体などの領域の領域を定義する図形だけです。
   * 世界がロックされている空間座標システムで空間ボリュームを使用すると、物理世界の固定領域を識別できます。
   * 空間ボリュームは、更新された各フレームの本文がロックされている空間座標系、領域を移動します (ただし、回転しません) の領域を識別するユーザーとを使用します。
   * これらの空間ボリュームは、後で、アプリケーションまたはユーザーの変更の状態として、いつでも変更できます。
* ポーリングまたは通知を使用して、情報空間のサーフェスを取得するには
   * 可能性があります 'ポーリングを続けた' 空間表面の状態のサーフェスのオブザーバー、いつでもできます。 代わりに、空間サーフェスが変更されたときに、アプリケーションを通知する表面オブザーバーの 'サーフェスが変更された' イベント、登録可能性があります。
   * 視錐台などの動的な空間ボリュームまたは本文ロックされたボリュームは、アプリケーションは、関心のある領域を設定し、空間のサーフェスの現在のセットを取得し、各フレームの変更をポーリングする必要があります。
   * 1 つの部屋をカバーする世界ロックされているキューブなどの静的なボリュームのアプリケーションはそのボリューム内の空間のサーフェスを変更したときに通知する 'サーフェスが変更された' イベント登録可能性があります。
* プロセスのサーフェスの変更
   * 空間表面の指定されたセットを反復処理します。
   * 変更または削除として、追加の空間サーフェスを分類します。
   * 該当する場合は、サーフェイスでの各追加または変更された空間、詳細の必要なレベルで、画面の現在の状態を示す更新されたメッシュを受信する非同期要求を送信します。
* 非同期のメッシュ要求 (次のセクションで詳細) を処理します。

## <a name="mesh-caching"></a>キャッシュをメッシュします。

空間のサーフェスは、高密度の三角形メッシュで表されます。 大量のコンピューティングとストレージ リソースを使用できるは、格納、表示、およびこれらのメッシュを処理します。 そのため、各アプリケーションはキャッシュ スキームをメッシュの処理と保存に使用されるリソースを最小限に抑えるために、ニーズに適切なメッシュを採用する必要があります。 このスキームでは、するメッシュを保持して、破棄するだけでなく各空間のサーフェスのメッシュを更新するタイミングを判断します。

どのように、アプリケーションがキャッシュのメッシュを対応する必要がありますが説明する考慮事項の多くは直接通知します。 環境のユーザーの移動、ために必要なサーフェス、異なるサーフェスが発生する場合、環境の変更をキャプチャするかを検討してください。

画面のオブザーバーによって提供される 'サーフェス変更' のイベントを解釈するときにキャッシュ ロジックの基本的なメッシュのとおりです。
* アプリケーションからは、以前に参照しない空間表面 ID は、新しい空間画面として扱う、この必要があります。
* アプリケーションから新しい更新時刻が既知の ID での空間画面は、更新の空間画面として扱う、この必要があります。
* アプリケーションでは、既知の ID を持つ空間画面が表示されないは、削除空間画面として扱う、この必要があります。

各アプリケーションを次の選択肢を加えることは。
* 新しい空間サーフェスでは、メッシュを要求することですか。
   * 一般にメッシュは、新しい空間サーフェスは、ユーザーに役立つ新しい情報が示されていますすぐに要求する必要があります。
   * ただし、新しい空間のサーフェスとも、ユーザーの近くに優先度を指定する必要があります、そのメッシュを最初に要求する必要があります。
   * 新しいメッシュが必要でない場合、固定されている場合など、アプリケーションが永続的または一時的に' ' 環境のモデル、しにする必要がありますいないに必要です。
* 更新された空間サーフェスでは、メッシュを要求することですか。
   * 更新された空間のサーフェスとも、ユーザーの近くに優先度を指定する必要があり、そのメッシュを最初に要求する必要があります。
   * 特にスキャン操作中に、サーフェスを更新するよりも新しい画面を優先的に適切な場合があります。
   * 処理コストを制限するには、アプリケーションを空間のサーフェスを更新する処理率を調整する必要があります。
   * 空間画面への変更はマイナー番号、たとえば、画面の境界は小さく、その場合、更新できない可能性がありますプロセスに十分な重要なことを推測できる場合があります。
   * ここではありますが、画面のオブザーバーによって使用空間外接するボリュームを変更する方が効率的に現在のユーザーの関心領域の外側の空間のサーフェスの更新プログラムは完全に無視できます。
* 削除された空間サーフェスでは、メッシュを破棄しますか。
   * 一般にメッシュを破棄するすぐに削除された空間サーフェスでは、ホログラム遮蔽が正しいままように。
   * ただし、アプリケーションにすると信じている理由がある場合空間画面は再表示すぐ (おそらくに基づいてユーザー エクスペリエンスの設計)、そのメッシュを破棄および後でもう一度再作成するよりも保持するより効率的な場合があります。
   * 場合は、アプリケーションをビルドして、ユーザーの環境の大規模なモデルは、まったく任意のメッシュを破棄する可能性がありますされません。 リソース使用率を制限、可能性がありますをディスクにスプール メッシュによって空間のサーフェスに表示されなくなると、必要があります。
   * 空間表面の生成中に一部の比較的まれなイベントは、同様の場所が異なる Id の新しい空間サーフェスによって置き換えられる空間のサーフェスを引き起こす可能性のあるに注意してください。 その結果、アプリケーションが削除されたサーフェイスを破棄しないように選択する必要があることに注意終了を複数高オーバー ラップした空間表面メッシュを同じ場所をカバーします。
* その他の任意の空間のサーフェスのメッシュを破棄しますか。
   * 破棄する必要がありますしはユーザーのエクスペリエンスを使用しない場合、空間のサーフェスが存在します中でも。 たとえば場合アプリケーション '置き換えます' 戸口の相手側に空き領域別の仮想空間、ルーム内の空間のサーフェス不要になった関係します。

次に、例メッシュ キャッシュ戦略、空間、および時間的なヒステリシスを使用してを示します。
* ユーザーの視線の先に依存して、少し調べてみるし、歩き回り関心のある視錐台の形の空間ボリュームを使用するアプリケーションを検討してください。
* 空間画面に表示されなく一時的にこのボリュームだけです、画面からを表示またはから出るの手順をさらにしています.振り返るにのみまたは近いもう一度少し後でに移動します。 この場合を破棄し、この画面のメッシュを再作成は、多くの冗長な処理を表します。
* 処理された変更の数を減らすためには、アプリケーションは、2 つ空間表面のオブザーバーを他の内に含まれるいずれかを使用します。 大きなボリュームが球とユーザーを '遅延;' に従いますまた、2.0 メートル ユーザー内でそのセンターがあることを確認するために必要なときにだけ移動します。
* 新規および更新された空間表面メッシュは常より小さな内部 surface、オブザーバーから処理が、メッシュがより大きな外部サーフェス オブザーバーこれらされなくなるまでにキャッシュされます。 これにより、ローカル ユーザーの移動のための多くの冗長な変更の処理を回避するためにアプリケーションができます。
* 空間画面は、損失の追跡のため一時的に消えるもことがあります、ため、アプリケーションも損失の追跡中に破棄の削除された空間サーフェスを延期します。
* 一般に、アプリケーションでは、削減更新処理とその最適なキャッシュ戦略を決定する増加したメモリの使用状況のトレードオフを評価する必要があります。

## <a name="rendering"></a>表示

レンダリングに使用する空間マッピング メッシュ傾向がある 3 つの主な方法はあります。
* 画面の視覚化
   * 空間のサーフェスを直接視覚化すると便利です。 たとえば、サーフェイス ホログラムを配置するときに、キャスト 'shadows' を空間表面にオブジェクトからは便利な視覚的なフィードバックをユーザーに提供できます。
   * 留意すべき 1 つは、空間メッシュが 3D アーティストを作成するメッシュの種類に異なることです。 三角形のトポロジは、人間が作成したトポロジとして 'クリーン' とできないし、メッシュがから低下[さまざまなエラー](spatial-mapping-design.md#what-influences-spatial-mapping-quality)します。
   * 楽しませる visual 美学上を作成するために可能性がありますのでを実行するいくつか[メッシュ処理](spatial-mapping.md#mesh-processing)塗りつぶし穴、または滑らかな表面の法線などにします。 直接メッシュ トポロジおよび normals の視覚化ではなく、メッシュにプロジェクトのアーティストが設計したテクスチャをシェーダーを使用することがあります。
* ホログラム現実世界のサーフェスの背後にある他の
   * 空間のサーフェス レンダリングできる深さ専用パスでのみに影響する、[深度バッファー](https://msdn.microsoft.com/library/windows/desktop/bb219616(v=vs.85).aspx)色のレンダー ターゲットには影響しません。
   * これは、空間のサーフェスの背後にある、その後表示ホログラムが深度バッファーを初期化します。 ホログラムの正確なオクルー ジョン ホログラムが実際には、ユーザーの物理的な空間内に存在するという点が強化されます。
   * 深さ専用のレンダリングを有効にする更新のブレンドの状態を設定する、 [RenderTargetWriteMask](https://msdn.microsoft.com/library/windows/desktop/hh404492(v=vs.85).aspx)レンダー ターゲットですべての色を 0 にします。
* 実際のサーフェスによってオクルー ジョン ホログラムの外観を変更します。
   * 通常どおりにレンダリングされたジオメトリには、これは、オクルー ジョンされる場合は表示されません。 これで、深度関数の設定で実現されます、[深度ステンシルの状態](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx)に「以下」、それが原因でジオメトリを表示するがある場合は**近い**よりも前に表示されるすべてのカメラにジオメトリ。
   * ただし、オクルー ジョンすると場合でも特定のジオメトリを表示したままにし、ユーザーに視覚的なフィードバックを提供する手段としてオクルー ジョンとは、その外観を変更する便利な場合があります。 たとえば、これにより、実際の画面の背後にあるユーザーが明確になりますを行って間オブジェクトの場所を表示するアプリケーションです。
   * これを実現するには、2 回目に必要な '閉塞' 外観を作成するさまざまなシェーダー、ジオメトリをレンダリングします。 2 回目のジオメトリを表示する前に 2 つの変更を行う、[深度ステンシルの状態](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx)します。 まず、深度関数を「より大きいまたは等しい」に設定できるように、ジオメトリ表示がある場合は**さらに**すべて以前にレンダリングされるジオメトリは、カメラから。 0 に、深度バッファーは変更しないように、DepthWriteMask を次に、設定 (ジオメトリの深さを表す、深度バッファーを続行する必要があります**最も近い**カメラに)。

[パフォーマンス](understanding-performance-for-mixed-reality.md)空間マッピングのメッシュをレンダリングするときに、重要な懸念事項は、します。 空間マッピングのメッシュをレンダリングする特定のレンダリング パフォーマンス テクニックを次に示します。
* 三角形の密度を調整します。
   * 要求元の空間画面は、surface、オブザーバーからメッシュ、お客様のニーズにとって有益な三角形メッシュの最も低い密度を要求します。
   * 合理的です、ユーザーからのサーフェスの距離に応じての画面で画面ごとに密度を三角形を変更して、ユーザー エクスペリエンスに関連します。
   * 削減三角形の数は、ピクセル処理コストは変わりませんがメモリ使用量と、GPU で頂点処理コストを削減するは。
* カリングの視錐台を実行します。
   * 視錐台カリング現在ディスプレイの視錐台の外側にあるために表示できません描画オブジェクトをスキップします。 これには、CPU と GPU の両方の処理コストが削減されます。
   * カリングは、メッシュの単位で実行空間のサーフェスが大きくなるので、各空間表面メッシュを小さなチャンクに分割が原因でより効率的なカリング (このな少なくオフスクリーン三角形がレンダリングされる)。 ただし; は、トレードオフがあります。ある複数のメッシュは、複数描画呼び出しおく必要があります、CPU コストを向上させることができます。 極端な場合、自体の計算をカリングの視錐台はコスト測定可能な CPU のもができます。
* レンダリング順序を調整します。
   * 空間のサーフェスは、ユーザーの周囲に環境全体を表すために大きくなる傾向があります。 ピクセル処理は GPU でコストが特に場合に、高できるため (空間サーフェスとその他のホログラムの両方を含む)、表示されている座標の 1 つ以上のレイヤーがあります。 この場合、ユーザーに最も近いレイヤーがする occluding のレイヤーをさらに、ためより離れているレイヤーのレンダリング費やされる GPU 時間を浪費します。
   * GPU 上でこの冗長な作業を減らすためには、前から後ろの順序で不透明な画面を表示するために役立ちます (詳細の最後の 1 つより離れているもの)。 'Opaque' 意味のいずれかに設定されて、DepthWriteMask サーフェス、[深度ステンシルの状態](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx)します。 最も近いサーフェスが表示されると、遠くの表面が GPU でピクセル プロセッサによって効率的にスキップされるように、深度バッファーを準備、されます。

## <a name="mesh-processing"></a>メッシュの処理

アプリケーションが実行する[さまざまな操作](spatial-mapping.md#mesh-processing)そのニーズに合わせて表面メッシュの空間にします。 各空間表面メッシュで提供されるインデックスと頂点のデータと同じ使い慣れたレイアウトを使用して、[頂点バッファーとインデックス バッファー](https://msdn.microsoft.com/library/windows/desktop/bb147325%28v=vs.85%29.aspx)すべて最新レンダリング Api で三角形メッシュをレンダリングするために使用されます。 ただし、1 つ注意すべき重要なことは、三角形の空間マッピングがあること、**前面に時計回りにワインディングの順序**します。 各三角形はメッシュのインデックス バッファー内の 3 つの頂点インデックスによって表され、これらのインデックス内の三角形の頂点を識別、**時計回り**から三角形を表示するときの順序、**前面**側です。 前面側 (または外部) 空間表面メッシュの現実の世界のサーフェスの (表示) の前面に期待どおりに対応します。

アプリケーションには、メッシュの単純化サーフェスのオブザーバーによって提供される最も粗い三角形の密度はまだが不十分な粗い - この作業は計算コストが高い場合と、さまざまなを生成するランタイムによって既に実行されているのみを実行する必要があります。詳細レベルを提供します。

一部のアプリケーションがクリップ空間これらにする場合がありますので、各画面のオブザーバーは、複数の接続されていない空間サーフェスを提供できます、表面メッシュ、他の各しジッパーに対してにまとめています。 一般に、クリッピング ステップは、空間表面メッシュの近くにある多くの場合、少しずつオーバー ラップ処理として必要です。

## <a name="raycasting-and-collision"></a>レイキャストと衝突

物理運動の API の順序で (など[Havok](http://www.havok.com/)) アプリケーション空間のサーフェスをレイキャストと衝突の機能を備えたアプリケーションを提供する空間画面は物理運動の API にメッシュを提供する必要があります。 多くの場合、物理運動のために使用するメッシュの次のプロパティがあります。
* 少数三角形のみにはが含まれます。 物理操作は詳細の表示操作よりも負荷の高い。
* 'Water 密' です。 サーフェスをしっかり学ぶためのものには、; に小規模の穴はありません。偶数の穴を表示するには小さすぎる問題が発生することができます。
* 凸 hulls に変換されます。 凸 hulls 多角形のいくつかあり、穴の自由し、生の三角形メッシュよりも処理するよりずっと計算に効率的です。

少しややこしい - だけの完全な乱雑図形など、デスクの空間のサーフェスに対して実行する raycasts は、これらのサーフェスの多くの場合、複雑さも留意してくださいと。 つまり、単一 raycast が多くの場合、不十分である、画面の近くに空の領域の図形の形状に関する十分な情報を提供します。 これは通常多く raycasts 小さな領域内で実行して、画面の信頼性の高い理解の派生に集計の結果を使用することをお勧めではため。 たとえば、10 raycasts の平均値を使用して、画面でガイド ホログラム配置するが生成されますまでよりスムーズかつちらつく小さい結果 raycast は 1 つだけを使用しています。

ただし、各 raycast 高い計算コストがあることができますも留意してください。 そのため、使用状況シナリオに応じてする必要がありますのバランスを取る追加 raycasts の計算コスト (すべてのフレームが実行されます) の計算コストに対して[メッシュ処理](spatial-mapping.md#mesh-processing)smooth および空間サーフェス (穴を削除するには実行空間メッシュが更新されたときに)。

## <a name="troubleshooting"></a>トラブルシューティング
* 表面メッシュを正しく向きにするためには、各 GameObject をそのメッシュを構築して、SurfaceObeserver に送信される前にアクティブにする必要があります。 それ以外の場合、メッシュは奇妙な角度で回転がスペースに表示されます。
* GameObject、SurfaceObserver と通信するスクリプトを実行するには、配信元に設定する必要があります。 それ以外の場合、オフセット、親ゲーム オブジェクトのオフセットに等しいすべて Gameobject を作成し、SurfaceObserver 構築、メッシュに送信するのになります。 何が起こってをデバッグする非常に困難になりますからいくつかのメーターを表示する、メッシュがあることがあります。

## <a name="see-also"></a>関連項目
* [座標系](coordinate-systems.md)
* [DirectX での空間のマッピング](spatial-mapping-in-directx.md)
* [Unity での空間のマッピング](spatial-mapping-in-unity.md)
* [空間マッピングの設計](spatial-mapping-design.md)
* [導入事例 - 実際には、セキュリティ ホールを見る](case-study-looking-through-holes-in-your-reality.md)
