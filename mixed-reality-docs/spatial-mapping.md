---
title: 空間マッピング
description: 空間マッピングは、HoloLens の周囲の環境における実際のサーフェイスの詳細な表現を提供します。
author: mattzmsft
ms.author: mazeller
ms.date: 03/21/2018
ms.topic: article
keywords: 空間マッピング, HoloLens, mixed reality, surface 再構築, メッシュ, sr
ms.openlocfilehash: 31abeca624512f1d5e721dbe879ca2243cf41345
ms.sourcegitcommit: 915d3cc63a5571ba22ac4608589f3eca8da1bc81
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/24/2019
ms.locfileid: "63550485"
---
# <a name="spatial-mapping"></a>空間マッピング

空間マッピングは、HoloLens の周囲の環境における実際のサーフェイスの詳細な表現を提供し、開発者が説得力のある mixed reality エクスペリエンスを作成できるようにします。 実際の世界を仮想環境にマージすることにより、アプリケーションは、ホログラムを現実に見せることができます。 また、アプリケーションは、実際の動作と相互作用を理解することで、ユーザーの期待に合わせて自然に配置できます。

<br>

>[!VIDEO https://www.youtube.com/embed/zff2aQ1RaVo]

## <a name="device-support"></a>デバイスのサポート

<table>
<tr>
<th>機能</th><th style="width:150px"> <a href="hololens-hardware-details.md">HoloLens (第 1 世代)</a></th><th style="width:150px">HoloLens 2</th><th style="width:150px"> <a href="immersive-headset-hardware-details.md">イマーシブ ヘッドセット</a></th>
</tr><tr>
<td> 空間マッピング</td><td style="text-align: center;"> ✔️</td><td style="text-align: center;"> ✔️</td><td style="text-align: center;"></td>
</tr>
</table>



## <a name="conceptual-overview"></a>概念の概要

![部屋をカバーするメッシュサーフェス](images/SurfaceReconstruction.jpg)<br>
*部屋をカバーする空間マッピングメッシュの例*

空間マッピングに使用される2つの主なオブジェクトの種類は、"空間サーフェスオブザーバー" と "空間サーフェス" です。

アプリケーションは、1つまたは複数の境界ボリュームを持つ空間サーフェスオブザーバーを提供し、アプリケーションが空間マッピングデータを受け取る領域の領域を定義します。 これらの各ボリュームについて、空間マッピングによって、空間サーフェスのセットがアプリケーションに提供されます。

これらのボリュームは、(実際の世界に対して固定された場所で) 静止している場合や、HoloLens にアタッチされている場合があります (これらのボリュームは、環境内を移動するときに HoloLens と一緒に移動されますが、回転しません)。 各空間サーフェスは、ワールドロックされた[空間座標系](coordinate-systems.md)に関連付けられた三角形メッシュとして表される、小さい領域の実際のサーフェイスを表します。

HoloLens が環境に関する新しいデータを収集すると、環境に対する変更が発生すると、空間サーフェスが表示され、非表示になり、変更されます。

## <a name="common-usage-scenarios"></a>一般的な使用シナリオ

![一般的な空間マッピングの使用シナリオの図:配置、遮蔽、物理、およびナビゲーション](images/sm-concepts-1000px.png)

### <a name="placement"></a>配置

空間マッピングを使用すると、アプリケーションは、自然で使い慣れた形でユーザーと対話することができます。電話をデスクに置いた方が、より自然なことがありますか。

サーフェイス上に配置されるホログラム (または、より一般的には、任意の空間位置の選択) の配置を制限すると、3D (空間のポイント) から 2D (サーフェス上の点) への自然なマッピングが実現します。 これにより、ユーザーがアプリケーションに提供する必要がある情報の量が削減されるため、ユーザーの操作をより迅速かつ簡単に、より正確に行うことができます。 これは特に、"距離が離れています" が、他の人間やコンピューターと物理的に通信するために使用されるものではないためです。 指をポイントすると、方向を指定しますが、距離は指定しません。

ここで重要な注意事項として、アプリケーションで方向からの距離が推測される場合 (たとえば、ユーザーの見つめ方向に沿って raycast を実行して最も近い空間サーフェスを検索する場合など)、ユーザーが確実に予測できる結果が得られる必要があります。 そうしないと、ユーザーは制御の意味を失い、すぐにフラストレーションを受ける可能性があります。 これに役立つ1つの方法は、1つだけではなく、複数の raycasts を実行することです。 集計結果は、より滑らかで予測可能であり、一時的な ' 外れ値 ' 結果からの影響を受けにくくなります (光線が小さな穴を通過するか、ユーザーが認識していないジオメトリの小さなビットに達したことによって発生する可能性があります)。 集計またはスムージングは、時間の経過と共に実行することもできます。たとえば、ホログラムがユーザーからの距離で変化する最大速度を制限できます。 最小距離と最大距離の値を制限するだけでも役に立ちます。したがって、移動するホログラムは、突然距離が離れたり、ユーザーの顔に戻ったりすることはありません。

アプリケーションでは、サーフェイスの形状と方向を使用して、ホログラムの配置をガイドすることもできます。 Holographic チェアは壁を通過しないようにする必要があります。また、やや不均一であっても、床との間にフラッシュする必要があります。 この種の機能は、単なる raycasts ではなく、物理的な衝突の使用に依存する可能性がありますが、同様の懸念が適用されます。 配置されているホログラムに、椅子の脚のような小さな多角形が多数含まれている場合は、それらの多角形の物理的な表現をより広い範囲で滑らかに拡張して、空間サーフェスを移動することができます。キャプチャ.

極端には、ユーザー入力を完全に簡略化し、空間サーフェスを使用して完全なホログラム配置を実行できます。 たとえば、アプリケーションでは、ユーザーが押すために壁のどこかに holographic ライトスイッチを配置できます。 予測可能性に関する注意事項は、ここでは二重に適用されます。ユーザーがホログラムの配置を制御する必要があるものの、アプリケーションが必要な場所にホログラムを配置することがない場合 (ライトスイッチがユーザーに届かない場所に表示される場合)、これは面倒なエクスペリエンスになります。 実際には、ユーザーが常に配置を実行する必要があるのではなく、ユーザーによる修正を必要とする自動配置を実行する方が悪くなることがあります。自動配置が正常に行われることが*予想*されるため、手動による修正は負担のように感じられます。

アプリケーションが空間サーフェスを配置に使用できるかどうかは、アプリケーションの[スキャンエクスペリエンス](spatial-mapping-design.md#the-environment-scanning-experience)に大きく左右されることにも注意してください。 サーフェイスがスキャンされていない場合は、配置に使用できません。 新しい画面をスキャンしたり、新しい場所を選択したりできるように、ユーザーに対してこのことを明確にする必要があります。

ユーザーへの視覚的なフィードバックは、配置時に非常に重要です。 ユーザーは、最も近い表面と、[接地効果](spatial-mapping.md#visualization)がある場所を認識している必要があります。 これらのユーザーは、ホログラムの動きが制約されている理由を理解している必要があります (たとえば、近くにある別のサーフェイスとの衝突が原因で)。 現在の場所にホログラムを配置できない場合、視覚的なフィードバックによって、その理由を明確にする必要があります。 たとえば、ユーザーが壁に holographic ソファを置いている場合、壁の背後にあるソファの部分は、怒った色で色を付ける必要があります。 反対に、ユーザーが実際の画面を見ることができる場所に空間サーフェイスが見つからない場合は、アプリケーションでこのことを明確にする必要があります。 この領域での接地効果が明らかでない場合は、この目的を達成することができます。

### <a name="occlusion"></a>オクルージョン

空間マッピングサーフェイスの主な用途の1つは、単にホログラムを occlude することです。 この単純な動作は、ホログラムのリアリティに大きな影響を与えるため、ユーザーと同じ物理空間をモックとする visceral sense を作成するのに役立ちます。

また、オクルージョンは、ユーザーに情報を提供します。occluded が本物の表面であると思われる場合、この方法では、世界中のホログラムの空間位置に関する追加の視覚的フィードバックが提供されます。 逆に、オクルージョンでは、ユーザーからの情報を*非表示*にすることもできます。壁の背後にある occluding ホログラムは、直感的な方法で視覚乱雑を軽減できます。 ホログラムを表示または非表示にするには、ユーザーは単にヘッドを移動する必要があります。

また、遮蔽を使用すると、使い慣れた物理的な対話に基づいて自然なユーザーインターフェイスの期待を達成することもできます。ホログラムがサーフェイスによって occluded されている場合、その表面はソリッドであるため、ユーザーは、ホログラムがその表面と*衝突*し、単に通過することを期待する必要があります。

場合によっては、ホログラムの遮蔽が望ましくないこともあります。 ユーザーがホログラムを操作できる必要がある場合は、実際の画面の背後にいる場合でも、ユーザーはそれを確認できる必要があります。 このような場合、通常は、occluded したときに (たとえば、明るさを下げることによって) このようなホログラムを別にレンダリングするのが理にかなっています。 こうすることで、ユーザーはホログラムを視覚的に見つけることができますが、それでもその背後にあることを認識できます。

### <a name="physics"></a>物理

物理シミュレーションを使用するもう1つの方法として、空間マッピングを使用して、ユーザーの物理空間にホログラムの*存在*を補強することができます。 私の holographic ゴムボールは、机の上から離れたときに、床でバウンスされ、ソファの下に見えなくなったときに、それが本当にないと信じられないかもしれません。

また、物理シミュレーションでは、アプリケーションで自然でわかりやすい物理操作を使用することもできます。 フロア上の holographic 家具を移動すると、家具が適切な慣性と摩擦によってフロア上でスライドしているかのように反応する場合、ユーザーにとってはもっと簡単になります。

現実的な物理的な動作を生成するために、穴の塗りつぶし、浮動 hallucinations の除去、ラフサーフェスのスムージングなど、[メッシュ処理](spatial-mapping.md#mesh-processing)の実行が必要になる可能性があります。

また、アプリケーションの[スキャンエクスペリエンス](spatial-mapping-design.md#the-environment-scanning-experience)が物理シミュレーションに与える影響についても考慮する必要があります。 最初は、不足しているサーフェスは何も競合しません。ゴムボールが corridor と、既知の世界の端から離れたときにどうなるでしょうか。 さらに、時間の経過と共に環境の変化に対応するかどうかを決定する必要があります。 場合によっては、可能な限り迅速に対応する必要があります。たとえば、ユーザーがドアと家具を、barricades の tempest に対する防御の可動として使用しているとします。 ただし、場合によっては、新しい更新プログラムを無視することもできます。犬がトラックの途中に座っていると判断した場合、holographic のスポーツ車をフロア上のレースの周りに置いても、突然楽しいことはありません。

### <a name="navigation"></a>ナビゲーション

アプリケーションでは、空間マッピングデータを使用して、実際の人と同じように、holographic 文字 (またはエージェント) が現実世界に移動できるようにすることができます。 これにより、ユーザーとその友人と同じ自然でなじみのある動作のセットに制限することで、holographic 文字が確実に存在するようになります。

ナビゲーション機能は、ユーザーにも役立ちます。 特定の領域にナビゲーションマップが構築されると、その場所を知らない新しいユーザーのために holographic の方向を提供するために共有することができます。 このマップは、歩行中のトラフィックの流れを円滑に保つため、または構築サイトなどの危険な場所での事故を防ぐために設計されている可能性があります。

ナビゲーション機能の実装に伴う技術的な課題の主な課題は、再生可能なサーフェイス (人間はテーブルをウォークしません) を確実に検出し、環境の変化に適切に適合させることです (人間は閉じたドアをたどることはできません)。 メッシュでは、仮想文字によるパスの計画とナビゲーションに使用できるようになる前に、何らかの[処理](spatial-mapping.md#mesh-processing)が必要になる場合があります。 メッシュをスムージングし、hallucinations を削除すると、文字が動かなくなるのを防ぐことができます。 また、文字のパス計画とナビゲーションの計算を高速化するために、メッシュを大幅に簡略化することもできます。 これらの課題は、videogame テクノロジの開発において非常に注意を払ってきました。これらのトピックには、豊富な研究資料があります。

Unity の組み込みのナビゲーションメッシュ機能は、空間マッピングサーフェイスでは使用できないことに注意してください。 これは、アプリケーションが開始されるまで空間マッピングサーフェイスが知られていないのに対して、ナビゲーションデータファイルは事前にソースアセットから生成する必要があるためです。 また、空間マッピングシステムは、ユーザーの現在の場所から離れた場所にある[サーフェイスに関する情報](spatial-mapping-design.md#the-environment-scanning-experience)を提供しないことにも注意してください。 そのため、非常に大きな領域のマップを作成する場合は、アプリケーションがそのサーフェイス自体を記憶する必要があります。

### <a name="visualization"></a>可視化

ほとんどの場合、空間サーフェスを非表示にするのが適切です。見た目が乱雑にならないようにして、現実世界の声を聞くことができます。 ただし、実際の対応するものが既に表示されているとしても、空間マッピングサーフェイスを直接視覚化すると便利な場合があります。

たとえば、ユーザーが表面にホログラムを配置しようとしたとき (壁に holographic キャビネットを配置する場合など)、表面に影をキャストすることによって、ホログラムを "接地" することが役に立つことがあります。 これにより、ホログラムと surface の物理的な距離を明確に理解できます。 これは、ユーザーがコミットする前に、変更を視覚的に "プレビュー" するより一般的な方法の例でもあります。

サーフェイスを視覚化することで、アプリケーションは環境についての理解をユーザーと共有できます。 たとえば、holographic board ゲームでは、"tables" として識別された水平サーフェスを視覚化することができます。これにより、ユーザーが対話する場所を知ることができます。

画面に表示されないユーザーの近くにあるスペースを表示するには、サーフェイスを視覚化すると便利です。 これにより、ユーザーがリビングルームからキッチン (およびそのすべてに含まれるホログラム) にアクセスできるようにするための簡単な方法が提供されます。

空間マッピングによって提供されるサーフェスメッシュは、特に "クリーン" ではない場合があります。 したがって、それらを適切に視覚化することが重要です。 従来の照明計算では、視覚的には見えない形で表面法線のエラーが強調表示される場合がありますが、画面上に投影された "クリーン" テクスチャは、外観を整えるのに役立ちます。 また、[メッシュ処理](spatial-mapping.md#mesh-processing)を実行して、サーフェイスがレンダリングされる前にメッシュのプロパティを向上させることもできます。

## <a name="using-the-surface-observer"></a>Surface オブザーバーの使用

空間マッピングの開始点は、surface オブザーバーです。 プログラムフローは次のとおりです。
* Surface オブザーバーオブジェクトを作成する
   * 1つまたは複数の空間ボリュームを指定して、アプリケーションが空間マッピングデータを受け取る対象領域を定義します。 空間ボリュームは、球体や箱などの領域の領域を定義する図形です。
   * ワールドロックの空間座標系で空間ボリュームを使用して、物理的な世界の固定領域を特定します。
   * 空間ボリュームを使用して、ボディロックされた空間座標系で各フレームを更新し、ユーザーとの間で移動する (ただし、回転しない) 領域を特定します。
   * これらの空間ボリュームは、アプリケーションまたはユーザーの状態が変化したときに、いつでも変更できます。
* ポーリングまたは通知を使用して空間サーフェスに関する情報を取得する
   * 空間サーフェスの状態については、いつでも surface オブザーバーを "ポーリング" できます。 また、surface オブザーバーの ' surface changed ' イベントに登録することもできます。これにより、空間サーフェスが変化したときにアプリケーションに通知されます。
   * ビューが錐である、または本文でロックされているボリュームのような動的な空間ボリュームの場合、アプリケーションは、必要な領域を設定し、現在の空間サーフェスのセットを取得することによって、各フレームの変更に対してポーリングを行う必要があります。
   * 1つのルームをカバーするワールドロックキューブなどの静的ボリュームの場合、アプリケーションは、そのボリューム内の空間サーフェスが変更された場合に通知されるように "サーフェイス changed" イベントに登録できます。
* サーフェイスの変化を処理する
   * 指定された空間サーフェイスのセットを反復処理します。
   * 空間サーフェスを追加、変更、または削除済みとして分類します。
   * 追加または変更された空間サーフェイスごとに、必要に応じて、必要な詳細レベルでサーフェイスの現在の状態を表す更新されたメッシュを受け取る非同期要求を送信します。
* 非同期メッシュ要求を処理します (以降のセクションで詳しく説明します)。

## <a name="mesh-caching"></a>メッシュキャッシュ

空間サーフェスは、高密度三角形メッシュによって表されます。 これらのメッシュを格納、表示、および処理すると、コンピューティングリソースとストレージリソースが大幅に消費される可能性があります。 そのため、各アプリケーションは、メッシュの処理とストレージに使用されるリソースを最小限に抑えるために、ニーズに適したメッシュキャッシュ方式を採用する必要があります。 このスキームでは、どのメッシュを保持するか、破棄するか、および各空間サーフェイスのメッシュをいつ更新するかを決定する必要があります。

ここで説明する考慮事項の多くは、アプリケーションがメッシュキャッシュにどのように対処する必要があるかを直接通知します。 ユーザーが環境内をどのように移動するか、どのサーフェイスが必要であるか、および環境内の変更をいつキャプチャするかを考慮する必要があります。

Surface オブザーバーによって提供される "変化したサーフェイス" イベントを解釈する場合、基本的なメッシュキャッシュのロジックは次のようになります。
* 前に見られていない空間サーフェス ID がアプリケーションに表示される場合、これを新しい空間サーフェスとして扱います。
* アプリケーションが既知の ID を持つ空間サーフェスを認識し、新しい更新時間がある場合は、これを更新された空間サーフェスとして扱う必要があります。
* 既知の ID を持つ空間サーフェスがアプリケーションに表示されなくなった場合は、これを削除された空間サーフェスとして扱います。

次に、各アプリケーションに対して次の選択を行います。
* 新しい空間サーフェスの場合、メッシュを要求する必要がありますか。
   * 通常メッシュは、新しい空間サーフェスに対してすぐに要求する必要があります。これにより、ユーザーに有用な新しい情報が提供される可能性があります。
   * ただし、ユーザーの前と前にある新しい空間サーフェスに優先順位を付け、そのメッシュを最初に要求する必要があります。
   * 新しいメッシュが必要ない場合、たとえば、アプリケーションが環境のモデルを永続的または一時的に "フリーズ" している場合は、そのモデルを要求しないようにする必要があります。
* 更新された空間サーフェスの場合、メッシュを要求する必要がありますか。
   * ユーザーの前と手前にある更新された空間サーフェスに優先順位を付け、そのメッシュを最初に要求する必要があります。
   * また、特にスキャンエクスペリエンス中に、更新されたサーフェイスよりも新しいサーフェイスに優先順位を付けることが適切な場合もあります。
   * 処理コストを制限するために、アプリケーションでは、空間サーフェスへの更新を処理する速度を調整することが必要になる場合があります。
   * たとえば、サーフェイスの境界が小さい場合など、空間サーフェスに対する変更は軽微であると推測できます。この場合、更新は処理するのに十分ではない可能性があります。
   * 現在のユーザーの関心領域外の空間サーフェスに対する更新は完全に無視される場合がありますが、この場合は、surface オブザーバーによって使用されている空間境界ボリュームを変更する方が効率的な場合があります。
* 削除された空間サーフェスの場合、メッシュを破棄する必要がありますか。
   * 通常メッシュは、削除された空間サーフェスに対して直ちに破棄され、ホログラムの閉鎖が適切な状態のままになります。
   * ただし、アプリケーションが (ユーザーエクスペリエンスの設計に基づいて) 後すぐに空間サーフェスを再表示するという理由がある場合は、メッシュを破棄して後で再作成するよりも、それを保持する方が効率的な場合があります。
   * アプリケーションがユーザーの環境の大規模なモデルを構築している場合、メッシュを破棄したくない場合があります。 ただし、空間サーフェスが表示されなくなったときにメッシュをディスクにスプールすることによって、リソースの使用量を制限する必要があります。
   * 空間サーフェスの生成中に比較的まれなイベントが発生すると、空間サーフェスが、同じ場所の新しい空間サーフェスに置き換えられることがありますが、Id が異なることに注意してください。 そのため、削除されたサーフェイスを破棄しないことを選択したアプリケーションは、同じ場所をカバーする複数の高重複空間サーフェスメッシュによって終了しないように注意する必要があります。
* 他の空間サーフェイスではメッシュを破棄する必要がありますか。
   * 空間サーフェイスが存在していても、ユーザーのエクスペリエンスには不要になった場合は、破棄する必要があります。 たとえば、アプリケーションが入室のもう一方の側の部屋を代替仮想空間と置き換える場合、そのルームの空間サーフェスは不要になります。

次に、空間とテンポラルヒステリシスを使用したメッシュキャッシュ方法の例を示します。
* アプリケーションでは、ユーザーの宝石に沿って視される、視錐のある空間ボリュームを使用することを検討してください。
* 空間サーフェスがこのボリュームから一時的に消える可能性があるのは、ユーザーがその画面から離れた場所から離れているためです。後でもう一度参照するか、さらに近い位置に移動します。 この場合、このサーフェイスのメッシュを破棄して再作成すると、大量の冗長処理が発生します。
* 処理される変更の数を減らすために、アプリケーションは2つの空間サーフェスオブザーバーを使用します。1つは他方に含まれています。 大きいボリュームは球面で、ユーザーの ' 遅延 ' に従います。必要な場合にのみ移動し、そのセンターがユーザーの 2.0 metres 内にあることを確認します。
* 新規および更新された空間サーフェスメッシュは、常に小さい内部サーフェスオブザーバーから処理されますが、メッシュは大きな外部サーフェスオブザーバーから見えなくなるまでキャッシュされます。 これにより、アプリケーションは、ローカルユーザーの移動によって多くの冗長な変更を処理することを回避できます。
* 空間サーフェスは、追跡が失われることによって一時的に消去される場合もあるため、アプリケーションは、追跡の損失中に削除された空間サーフェスの破棄を延期します。
* 一般に、アプリケーションでは、更新処理の減少とメモリ使用量の増加のトレードオフを評価して、最適なキャッシュ戦略を決定する必要があります。

## <a name="rendering"></a>表示

空間マッピングメッシュがレンダリングに使用される傾向がある主な方法には、次の3つがあります。
* Surface の視覚化の場合
   * 多くの場合、空間サーフェスを直接視覚化すると便利です。 たとえば、オブジェクトから空間サーフェスに ' shadows ' をキャストすると、サーフェイスにホログラムを配置するときに、視覚的なフィードバックをユーザーに提供できます。
   * 空間メッシュは、3D アーティストによって作成されるメッシュの種類とは異なる点に注意してください。 トライアングルトポロジは人間が作成したトポロジとして "クリーン" ではなく、メッシュが[さまざまなエラー](spatial-mapping-design.md#what-influences-spatial-mapping-quality)によって影響を受けます。
   * 見栄えの良いビジュアルを作成するには、穴や smooth surface の法線を塗りつぶすなど、[メッシュ処理](spatial-mapping.md#mesh-processing)を実行することが必要になる場合があります。 また、メッシュトポロジや法線を直接視覚化するのではなく、シェーダーを使用して、アーティストによって設計されたテクスチャをメッシュに射影することもできます。
* 実際のサーフェイスの背後にある occluding ホログラムの場合
   * 空間サーフェスは、[深度バッファー](https://msdn.microsoft.com/library/windows/desktop/bb219616(v=vs.85).aspx)にのみ影響を与え、カラーレンダーターゲットには影響しない、深度のみのパスでレンダリングできます。
   * これにより、空間サーフェスの背後でレンダリングされるホログラムを occlude するための深度バッファーが primes されます。 ホログラムを正確に遮蔽することで、ユーザーの物理的な領域内にホログラムが本当に存在するという意味が高まります。
   * 深度のみのレンダリングを有効にするには、blend の状態を更新して、すべてのカラーレンダーターゲットで[RenderTargetWriteMask](https://msdn.microsoft.com/library/windows/desktop/hh404492(v=vs.85).aspx)を0に設定します。
* 実際のサーフェイスによるホログラム occluded の外観を変更するには
   * 通常表示されるジオメトリは、occluded すると非表示になります。 これを実現するには、深度ステンシルの[状態](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx)の depth 関数を "次の値以下" に設定します。これにより、以前にレンダリングされたすべてのジオメトリよりもカメラに**近い**場所にのみジオメトリが表示されるようになります。
   * ただし、特定のジオメトリが occluded されていても表示されないようにしたり、視覚的なフィードバックをユーザーに提供する手段として occluded したときの外観を変更したりすると便利な場合があります。 たとえば、これにより、アプリケーションは、実際の画面の背後にあることを明確にしながら、オブジェクトの場所をユーザーに表示できます。
   * これを実現するには、必要な ' occluded ' 外観を作成する別のシェーダーを使用して、ジオメトリをもう一度描画します。 2回目のジオメトリをレンダリングする前に、[深度ステンシルの状態](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx)に2つの変更を加えます。 最初に、深度関数を "以上" に設定します。これにより、ジオメトリは、**以前にレンダリング**されたすべてのジオメトリよりもカメラから見た場合にのみ表示されるようになります。 次に、DepthWriteMask を0に設定して、深度バッファーが変更されないようにします (深度バッファーは、カメラに**最も近い**ジオメトリの深さを継続して表す必要があります)。

空間マッピングメッシュをレンダリングする場合、[パフォーマンス](understanding-performance-for-mixed-reality.md)は重要な問題です。 空間マッピングメッシュのレンダリングに固有のレンダリングパフォーマンス手法を次に示します。
* 三角形の密度を調整する
   * Surface オブザーバーから空間サーフェスメッシュを要求するときは、必要に応じて十分な三角形メッシュの最低密度を要求します。
   * 画面上の三角形の密度は、ユーザーからの距離とユーザーエクスペリエンスに対する関係に応じて、サーフェス単位で変化させることができます。
   * トライアングル数を減らすと、GPU のメモリ使用量と頂点処理コストが削減されますが、ピクセル処理のコストには影響しません。
* 錐のあるカリングを実行する
   * 視錐台のカリングは、表示できない描画オブジェクトをスキップします。これは、現在のディスプレイが視錐であるためです。 これにより、CPU と GPU の両方の処理コストが削減されます。
   * カリングはメッシュごとに実行されるため、空間サーフェスは大きくなる可能性があるため、各空間サーフェスメッシュを小さなチャンクに分割すると、より効率的なカリングを実現できます (オフスクリーンの三角形がレンダリングされます)。 ただし、トレードオフがあります。メッシュ数が多いほど描画呼び出しが多くなるため、CPU コストが増加する可能性があります。 極端なケースでは、錐のあるカリングの計算自体が、測定可能な CPU コストを持つことさえあります。
* レンダリング順序の調整
   * 空間サーフェスは、周囲のユーザーの環境全体を表しているため、サイズが大きくなる傾向があります。 これにより、GPU のピクセル処理コストが高くなる可能性があります。これは特に、可視ジオメトリのレイヤーが複数存在する場合 (空間サーフェスとその他のホログラムを含む) の場合に特に当てはまります。 この場合、ユーザーに最も近いレイヤーはさらにレイヤーを occluding するため、遠くのレイヤーをレンダリングするのに費やされた GPU 時間は無駄になります。
   * GPU 上のこの冗長な作業を減らすために、不透明なサーフェスを前方から後方にレンダリングするのに役立ちます (先に近い順にします)。 ' 不透明 ' では、DepthWriteMask が[深度ステンシルの状態](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx)で1に設定されているサーフェイスを意味します。 最も近いサーフェイスがレンダリングされると、GPU のピクセルプロセッサによって遠く離れたサーフェイスが効率的にスキップされるように、深度バッファーが最適になります。

## <a name="mesh-processing"></a>メッシュ処理

アプリケーションでは、必要に応じて、空間サーフェスメッシュに対して[さまざまな操作](spatial-mapping.md#mesh-processing)を実行することができます。 各空間サーフェスメッシュで提供されるインデックスおよび頂点データは、すべての最新のレンダリング Api で三角形メッシュをレンダリングするために使用される[頂点およびインデックスバッファー](https://msdn.microsoft.com/library/windows/desktop/bb147325%28v=vs.85%29.aspx)と同じ使い慣れたレイアウトを使用します。 ただし、重要な1つの重要な点は、空間マッピングの三角形には、**反時計回りの回転順序**があるということです。 各三角形はメッシュのインデックスバッファー内の3つの頂点インデックスによって表されます。これらのインデックスは、三角形が**正面**から表示されるときに、三角形の頂点を**時計回り**の順序で識別します。 空間サーフェスメッシュの前面 (または外側) は、実際のサーフェイスの前面 (表示されている側) に期待されるように対応します。

アプリケーションでは、surface オブザーバーによって提供される coarsest 三角形の密度がまだ粗いことがない場合にのみメッシュの単純化を実行する必要があります。この作業は負荷が高く、ランタイムがさまざまなを生成するために既に実行されています。提供される詳細レベル。

各サーフェイスオブザーバーは複数の未接続空間サーフェスを提供できるため、アプリケーションによっては、これらの空間サーフェスメッシュを相互にクリップし、それらをまとめて zipper ことが必要になる場合があります。 一般的に、隣接する空間サーフェスメッシュが少し重なっているため、クリッピング手順が必要です。

## <a name="raycasting-and-collision"></a>Raycasting と競合

アプリケーションで空間サーフェスの raycasting および衝突機能を使用できるようにするために、物理 API (の場合は、等[ok](http://www.havok.com/)) では、アプリケーションで物理 api に空間サーフェスメッシュを提供する必要があります。 物理に使用されるメッシュには、次の特性があります。
* これらには、少数の三角形しか含まれていません。 物理操作は、レンダリング操作よりも計算が多くなります。
* このような場合は、"水がきつい" になります。 ソリッドであることを意図したサーフェスは、小さな穴を持つことはできません。表示できない穴が小さすぎる場合でも、問題が発生する可能性があります。
* これらは、凸状 hulls に変換されます。 凸状の hulls にはいくつかのポリゴンがあり、穴は不要であり、生の三角形メッシュよりも処理がはるかに効率的です。

空間サーフェスに対して raycasts を実行するときは、机のように、これらのサーフェスが複雑で、乱雑なものではないことに注意してください。 つまり、1つの raycast では、画面の形状や、その近くにある空の領域の形状に関する十分な情報を得ることができません。 そのため、通常は小さな領域内で多くの raycasts を実行し、集計結果を使用して、より信頼性の高いサーフェイスの理解を得ることをお勧めします。 たとえば、平均 10 raycasts を使用して、表面にホログラムの配置を行うと、1つの raycast だけを使用して、はるかに滑らかで "ちらつき" の結果が得られます。

ただし、raycast ごとに計算コストが高くなる可能性があることに注意してください。 したがって、使用シナリオによっては、(すべてのフレームで実行された) 追加の raycasts の計算コストと[メッシュ処理](spatial-mapping.md#mesh-processing)の計算コストを比較して、空間サーフェスの穴を滑らかにしたり削除したり (空間で実行) する必要があります。メッシュが更新されます。

## <a name="troubleshooting"></a>トラブルシューティング
* サーフェスメッシュを適切に配置するためには、各 SurfaceObeserver オブジェクトをアクティブにしてから、メッシュが構築されるようにする必要があります。 そうしないと、メッシュはスペースに表示されますが、回転角度は変わってきます。
* SurfaceObserver と通信するスクリプトを実行するオブジェクトは、オリジンに設定する必要があります。 そうしないと、メッシュを構築するために作成して SurfaceObserver に送信するすべてのゲームオブジェクトが、親 Game オブジェクトのオフセットと同じオフセットを持つことになります。 これにより、メッシュがいくつかのメーターを表示して、何が起こっているかを簡単にデバッグできるようになります。

## <a name="see-also"></a>関連項目
* [座標系](coordinate-systems.md)
* [DirectX の空間マッピング](spatial-mapping-in-directx.md)
* [Unity の空間マッピング](spatial-mapping-in-unity.md)
* [空間マッピングの設計](spatial-mapping-design.md)
* [ケース スタディ - Mixed Reality で穴から覗く](case-study-looking-through-holes-in-your-reality.md)
