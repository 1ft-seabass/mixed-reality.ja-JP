---
title: MR 250 - HoloLens とイマーシブ ヘッドセットの共有
description: このコーディング ホログラム複合現実デバイス間の共有の詳細については、Unity、Visual Studio、HoloLens、および Windows Mixed Reality ヘッドセットを使用してチュートリアルに従います。
author: keveleigh
ms.author: kurtie
ms.date: 03/21/2018
ms.topic: article
keywords: holotoolkit、mixedrealitytoolkit、mixedrealitytoolkit-unity のイマーシブなアニメーション コント ローラー、共有、xbox コント ローラー、ネットワーク、クロス デバイス
ms.openlocfilehash: 9e1cb0d168b8bf830b4477190516cd19caef7972
ms.sourcegitcommit: 384b0087899cd835a3a965f75c6f6c607c9edd1b
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/12/2019
ms.locfileid: "59598044"
---
>[!NOTE]
><span data-ttu-id="afe41-104">Mixed Reality Academy チュートリアルでは、HoloLens として設計された (第 1 世代) と混在の現実イマーシブ ヘッドセットに注意してください。</span><span class="sxs-lookup"><span data-stu-id="afe41-104">The Mixed Reality Academy tutorials were designed with HoloLens (1st gen) and Mixed Reality Immersive Headsets in mind.</span></span>  <span data-ttu-id="afe41-105">そのため、これらのデバイス向けの開発にガイダンスがまだ必要な開発者のための場所でこれらのチュートリアルのままにすることが重要と思われます。</span><span class="sxs-lookup"><span data-stu-id="afe41-105">As such, we feel it is important to leave these tutorials in place for developers who are still looking for guidance in developing for those devices.</span></span>  <span data-ttu-id="afe41-106">これらのチュートリアルは **_いない_** 最新のツールセットや相互作用が使用されている HoloLens 2 で更新されます。</span><span class="sxs-lookup"><span data-stu-id="afe41-106">These tutorials will **_not_** be updated with the latest toolsets or interactions being used for HoloLens 2.</span></span>  <span data-ttu-id="afe41-107">サポートされているデバイスで作業を続行するが保持されます。</span><span class="sxs-lookup"><span data-stu-id="afe41-107">They will be maintained to continue working on the supported devices.</span></span> <span data-ttu-id="afe41-108">一連の新しい HoloLens 2 を開発する方法を示すチュートリアルは、今後投稿があります。</span><span class="sxs-lookup"><span data-stu-id="afe41-108">There will be a new series of tutorials that will be posted in the future that will demonstrate how to develop for HoloLens 2.</span></span>  <span data-ttu-id="afe41-109">この通知が投稿されるときにこれらのチュートリアルへのリンクが更新されます。</span><span class="sxs-lookup"><span data-stu-id="afe41-109">This notice will be updated with a link to those tutorials when they are posted.</span></span>

<br>

# <a name="mr-sharing-250-hololens-and-immersive-headsets"></a><span data-ttu-id="afe41-110">MR が 250 の共有:HoloLens とイマーシブ ヘッドセット</span><span class="sxs-lookup"><span data-stu-id="afe41-110">MR Sharing 250: HoloLens and immersive headsets</span></span>

<span data-ttu-id="afe41-111">柔軟性のユニバーサル Windows プラットフォーム (UWP) により、複数のデバイスにまたがるアプリケーションを作成する簡単です。</span><span class="sxs-lookup"><span data-stu-id="afe41-111">With the flexibility of Universal Windows Platform (UWP), it is easy to create an application that spans multiple devices.</span></span> <span data-ttu-id="afe41-112">この柔軟性により、各デバイスの長所を活用するエクスペリエンスを生み出すことができます。</span><span class="sxs-lookup"><span data-stu-id="afe41-112">With this flexibility, we can create experiences that leverage the strengths of each device.</span></span> <span data-ttu-id="afe41-113">このチュートリアルでは、イマーシブ ヘッドセットを HoloLens と Windows Mixed Reality の両方で実行されている基本の共有エクスペリエンスを説明します。</span><span class="sxs-lookup"><span data-stu-id="afe41-113">This tutorial will cover a basic shared experience that runs on both HoloLens and Windows Mixed Reality immersive headsets.</span></span> <span data-ttu-id="afe41-114">このコンテンツは、Microsoft Build 2017 カンファレンス、ワシントン州シアトルで配信元でした。</span><span class="sxs-lookup"><span data-stu-id="afe41-114">This content was originally delivered at the Microsoft Build 2017 conference in Seattle, WA.</span></span>

<span data-ttu-id="afe41-115">**このチュートリアルでご紹介します。**</span><span class="sxs-lookup"><span data-stu-id="afe41-115">**In this tutorial, we will:**</span></span>

* <span data-ttu-id="afe41-116">UNET を使用してネットワークをセットアップします。</span><span class="sxs-lookup"><span data-stu-id="afe41-116">Setup a network using UNET.</span></span>
* <span data-ttu-id="afe41-117">複合現実デバイス間でホログラムを共有します。</span><span class="sxs-lookup"><span data-stu-id="afe41-117">Share holograms across mixed reality devices.</span></span>
* <span data-ttu-id="afe41-118">複合現実デバイスが使用されているに応じてアプリケーションの別のビューを確立します。</span><span class="sxs-lookup"><span data-stu-id="afe41-118">Establish a different view of the application depending on which mixed reality device is being used.</span></span>
* <span data-ttu-id="afe41-119">HoloLens のユーザーがいくつかの簡単なパズルを使用してイマーシブ ヘッドセット ユーザーをガイドする共有エクスペリエンスを作成します。</span><span class="sxs-lookup"><span data-stu-id="afe41-119">Create a shared experience where HoloLens users guide immersive headsets users through some simple puzzles.</span></span>

## <a name="device-support"></a><span data-ttu-id="afe41-120">デバイスのサポート</span><span class="sxs-lookup"><span data-stu-id="afe41-120">Device support</span></span>

<table>
<tr>
<th><span data-ttu-id="afe41-121">コース</span><span class="sxs-lookup"><span data-stu-id="afe41-121">Course</span></span></th><th style="width:150px"> <span data-ttu-id="afe41-122"><a href="hololens-hardware-details.md">HoloLens</a></span><span class="sxs-lookup"><span data-stu-id="afe41-122"><a href="hololens-hardware-details.md">HoloLens</a></span></span></th><th style="width:150px"> <span data-ttu-id="afe41-123"><a href="immersive-headset-hardware-details.md">イマーシブ ヘッドセット</a></span><span class="sxs-lookup"><span data-stu-id="afe41-123"><a href="immersive-headset-hardware-details.md">Immersive headsets</a></span></span></th>
</tr><tr>
<td><span data-ttu-id="afe41-124">MR が 250 の共有:HoloLens とイマーシブ ヘッドセット</span><span class="sxs-lookup"><span data-stu-id="afe41-124">MR Sharing 250: HoloLens and immersive headsets</span></span></td><td style="text-align: center;"> <span data-ttu-id="afe41-125">✔️</span><span class="sxs-lookup"><span data-stu-id="afe41-125">✔️</span></span></td><td style="text-align: center;"> <span data-ttu-id="afe41-126">✔️</span><span class="sxs-lookup"><span data-stu-id="afe41-126">✔️</span></span></td>
</tr>
</table>

## <a name="before-you-start"></a><span data-ttu-id="afe41-127">開始前の作業</span><span class="sxs-lookup"><span data-stu-id="afe41-127">Before you start</span></span>

### <a name="prerequisites"></a><span data-ttu-id="afe41-128">前提条件</span><span class="sxs-lookup"><span data-stu-id="afe41-128">Prerequisites</span></span>

* <span data-ttu-id="afe41-129">Windows 10 PC で、[ために必要な開発ツール](install-the-tools.md)と[Windows Mixed Reality イマーシブ ヘッドセットをサポートするように構成](https://docs.microsoft.com/windows/mixed-reality/enthusiast-guide/windows-mixed-reality-minimum-pc-hardware-compatibility-guidelines)します。</span><span class="sxs-lookup"><span data-stu-id="afe41-129">A Windows 10 PC with the [necessary development tools](install-the-tools.md) and [configured to support a Windows Mixed Reality immersive headset](https://docs.microsoft.com/windows/mixed-reality/enthusiast-guide/windows-mixed-reality-minimum-pc-hardware-compatibility-guidelines).</span></span>
* <span data-ttu-id="afe41-130">お使いの PC で動作する Xbox コント ローラー。</span><span class="sxs-lookup"><span data-stu-id="afe41-130">An Xbox controller that works with your PC.</span></span>
* <span data-ttu-id="afe41-131">少なくとも 1 つの HoloLens デバイスは、1 つのイマーシブ ヘッドセット。</span><span class="sxs-lookup"><span data-stu-id="afe41-131">At least one HoloLens device and one immersive headset.</span></span>
* <span data-ttu-id="afe41-132">探索の UDP ブロードキャストを許可するネットワーク。</span><span class="sxs-lookup"><span data-stu-id="afe41-132">A network which allows UDP Broadcast for discovery.</span></span>

### <a name="project-files"></a><span data-ttu-id="afe41-133">プロジェクト ファイル</span><span class="sxs-lookup"><span data-stu-id="afe41-133">Project files</span></span>

* <span data-ttu-id="afe41-134">ダウンロード、[ファイル](https://github.com/Microsoft/MixedReality250/archive/master.zip)プロジェクトに必要です。</span><span class="sxs-lookup"><span data-stu-id="afe41-134">Download the [files](https://github.com/Microsoft/MixedReality250/archive/master.zip) required by the project.</span></span> <span data-ttu-id="afe41-135">覚えやすい場所にファイルを抽出します。</span><span class="sxs-lookup"><span data-stu-id="afe41-135">Extract the files to an easy to remember location.</span></span>
* <span data-ttu-id="afe41-136">このプロジェクトで必要な[Windows Mixed Reality サポートで推奨されるバージョンの Unity](install-the-tools.md)します。</span><span class="sxs-lookup"><span data-stu-id="afe41-136">This project requires the [a recommended version of Unity with Windows Mixed Reality support](install-the-tools.md).</span></span>

>[!NOTE]
><span data-ttu-id="afe41-137">をダウンロードする前に、ソース コードを検索する場合がある[GitHub で入手できます](https://github.com/Microsoft/MixedReality250)します。</span><span class="sxs-lookup"><span data-stu-id="afe41-137">If you want to look through the source code before downloading, it's [available on GitHub](https://github.com/Microsoft/MixedReality250).</span></span>

## <a name="chapter-1---holo-world"></a><span data-ttu-id="afe41-138">第 1 章 - Holo 世界</span><span class="sxs-lookup"><span data-stu-id="afe41-138">Chapter 1 - Holo World</span></span>

>[!VIDEO https://www.youtube.com/embed/IC0rp6rLiEc]

### <a name="objectives"></a><span data-ttu-id="afe41-139">目標</span><span class="sxs-lookup"><span data-stu-id="afe41-139">Objectives</span></span>

<span data-ttu-id="afe41-140">開発環境が単純なプロジェクトに対応することを確認します。</span><span class="sxs-lookup"><span data-stu-id="afe41-140">Make sure the development environment is ready to go with a simple project.</span></span>

### <a name="what-we-will-build"></a><span data-ttu-id="afe41-141">構築します。</span><span class="sxs-lookup"><span data-stu-id="afe41-141">What we will build</span></span>

<span data-ttu-id="afe41-142">HoloLens と Windows Mixed Reality ヘッドセット没入型のいずれかでホログラムを表示するアプリケーション。</span><span class="sxs-lookup"><span data-stu-id="afe41-142">An application that shows a hologram on either HoloLens or a Windows Mixed Reality immersive headset.</span></span>

### <a name="steps"></a><span data-ttu-id="afe41-143">手順</span><span class="sxs-lookup"><span data-stu-id="afe41-143">Steps</span></span>
* <span data-ttu-id="afe41-144">Unity を開きます。</span><span class="sxs-lookup"><span data-stu-id="afe41-144">Open Unity.</span></span>
    * <span data-ttu-id="afe41-145">**[開く]** を選択します。</span><span class="sxs-lookup"><span data-stu-id="afe41-145">Select **Open**.</span></span>
    * <span data-ttu-id="afe41-146">プロジェクト ファイルを抽出した場所に移動します。</span><span class="sxs-lookup"><span data-stu-id="afe41-146">Navigate to where you extracted the project files.</span></span>
    * <span data-ttu-id="afe41-147">**[フォルダーの選択]** をクリックします。</span><span class="sxs-lookup"><span data-stu-id="afe41-147">Click **Select Folder**.</span></span>
    * <span data-ttu-id="afe41-148">*少し、初めてのプロジェクトを処理する Unity の中にかかります。*</span><span class="sxs-lookup"><span data-stu-id="afe41-148">*It will take a little while for Unity to process the project the first time.*</span></span>
* <span data-ttu-id="afe41-149">Unity で Mixed Reality が有効になっていることを確認します。</span><span class="sxs-lookup"><span data-stu-id="afe41-149">Check that Mixed Reality is enabled in Unity.</span></span>
    * <span data-ttu-id="afe41-150">ビルドの設定 ダイアログを開きます (**コントロール + Shift + B**または**ファイル > Build Settings...**).</span><span class="sxs-lookup"><span data-stu-id="afe41-150">Open the build settings dialog (**Control+Shift+B** or **File > Build Settings...**).</span></span>
    * <span data-ttu-id="afe41-151">選択**ユニバーサル Windows プラットフォーム**クリックして**スイッチ プラットフォーム**します。</span><span class="sxs-lookup"><span data-stu-id="afe41-151">Select **Universal Windows Platform** then click **Switch Platform**.</span></span>
    * <span data-ttu-id="afe41-152">選択**編集 > プレーヤー設定**します。</span><span class="sxs-lookup"><span data-stu-id="afe41-152">Select **Edit>Player Settings**.</span></span>
    * <span data-ttu-id="afe41-153">**インスペクター** 、右側にパネルで、展開**XR 設定**します。</span><span class="sxs-lookup"><span data-stu-id="afe41-153">In the **Inspector** panel on the right hand side, expand **XR Settings**.</span></span>
    * <span data-ttu-id="afe41-154">チェック、**仮想現実サポート**ボックス。</span><span class="sxs-lookup"><span data-stu-id="afe41-154">Check the **Virtual Reality Supported** box.</span></span>
    * <span data-ttu-id="afe41-155">*Windows Mixed Reality 仮想現実 SDK があります。*</span><span class="sxs-lookup"><span data-stu-id="afe41-155">*Windows Mixed Reality should be the Virtual Reality SDK.*</span></span>
* <span data-ttu-id="afe41-156">シーンを作成します。</span><span class="sxs-lookup"><span data-stu-id="afe41-156">Create a scene.</span></span>
    * <span data-ttu-id="afe41-157">**階層**を右クリックして**Main Camera**選択**削除**します。</span><span class="sxs-lookup"><span data-stu-id="afe41-157">In the **Hierarchy** right click **Main Camera** select **Delete**.</span></span>
    * <span data-ttu-id="afe41-158">**HoloToolkit > の入力 > プレハブ**ドラッグ**MixedRealityCameraParent**を**階層**します。</span><span class="sxs-lookup"><span data-stu-id="afe41-158">From **HoloToolkit > Input > Prefabs** drag **MixedRealityCameraParent** to the **Hierarchy**.</span></span>
* <span data-ttu-id="afe41-159">ホログラムをシーンに追加します。</span><span class="sxs-lookup"><span data-stu-id="afe41-159">Add Holograms to the scene</span></span>
    * <span data-ttu-id="afe41-160">**AppPrefabs**ドラッグ**スカイ ボックス**を**シーン ビュー**します。</span><span class="sxs-lookup"><span data-stu-id="afe41-160">From **AppPrefabs** drag **Skybox** to the **Scene View**.</span></span>
    * <span data-ttu-id="afe41-161">**AppPrefabs**ドラッグ**マネージャー**を**階層**します。</span><span class="sxs-lookup"><span data-stu-id="afe41-161">From **AppPrefabs** drag **Managers** to the **Hierarchy**.</span></span>
    * <span data-ttu-id="afe41-162">**AppPrefabs**ドラッグ**島**を**階層**します。</span><span class="sxs-lookup"><span data-stu-id="afe41-162">From **AppPrefabs** drag **Island** to the **Hierarchy**.</span></span>
* <span data-ttu-id="afe41-163">保存し、ビルド</span><span class="sxs-lookup"><span data-stu-id="afe41-163">Save And build</span></span>
    * <span data-ttu-id="afe41-164">保存 (か**コントロール + S**または**ファイル > シーンを保存**)</span><span class="sxs-lookup"><span data-stu-id="afe41-164">Save (either **Control+S** or **File > Save Scene**)</span></span>
    * <span data-ttu-id="afe41-165">これは、新しいシーンであるために名前を付ける必要があります。</span><span class="sxs-lookup"><span data-stu-id="afe41-165">Since this is a new scene, you'll need to name it.</span></span> <span data-ttu-id="afe41-166">名前は関係ありませんが、SharedMixedReality を使用します。</span><span class="sxs-lookup"><span data-stu-id="afe41-166">Name doesn't matter, but we use SharedMixedReality.</span></span>
* <span data-ttu-id="afe41-167">Visual Studio へのエクスポートします。</span><span class="sxs-lookup"><span data-stu-id="afe41-167">Export To Visual Studio</span></span>
    * <span data-ttu-id="afe41-168">[ビルド] メニューを開きます (**コントロール + Shift + B**または**ファイル > Build Settings**)</span><span class="sxs-lookup"><span data-stu-id="afe41-168">Open the build menu (**Control+Shift+B** or **File > Build Settings**)</span></span>
    * <span data-ttu-id="afe41-169">クリックして**開くシーンを追加します。**</span><span class="sxs-lookup"><span data-stu-id="afe41-169">Click **Add Open Scenes.**</span></span>
    * <span data-ttu-id="afe41-170">確認**UnityC#プロジェクト**</span><span class="sxs-lookup"><span data-stu-id="afe41-170">Check **Unity C# Projects**</span></span>
    * <span data-ttu-id="afe41-171">**[Build]** をクリックします。</span><span class="sxs-lookup"><span data-stu-id="afe41-171">Click **Build**.</span></span>
    * <span data-ttu-id="afe41-172">ファイル エクスプ ローラー ウィンドウが表示されますでという名前の新しいフォルダーを作成**アプリ**します。</span><span class="sxs-lookup"><span data-stu-id="afe41-172">In the file explorer window that appears, create a New Folder named **App**.</span></span>
    * <span data-ttu-id="afe41-173">1 回のクリック、**アプリ**フォルダー。</span><span class="sxs-lookup"><span data-stu-id="afe41-173">Single click the **App** folder.</span></span>
    * <span data-ttu-id="afe41-174">キーを押して**フォルダーを選択します。**</span><span class="sxs-lookup"><span data-stu-id="afe41-174">Press **Select Folder.**</span></span>
    * <span data-ttu-id="afe41-175">**ビルドが完了するまで待ちます**</span><span class="sxs-lookup"><span data-stu-id="afe41-175">**Wait for the build to complete**</span></span>
    * <span data-ttu-id="afe41-176">ファイル エクスプ ローラー ウィンドウが表示されますに移動します、**アプリ**フォルダー。</span><span class="sxs-lookup"><span data-stu-id="afe41-176">In the file explorer window that appears, navigate into the **App** folder.</span></span>
    * <span data-ttu-id="afe41-177">ダブルクリック**SharedMixedReality.sln** Visual Studio を起動するには</span><span class="sxs-lookup"><span data-stu-id="afe41-177">Double-click **SharedMixedReality.sln** to launch Visual Studio</span></span>
* <span data-ttu-id="afe41-178">Visual Studio からビルドします。</span><span class="sxs-lookup"><span data-stu-id="afe41-178">Build From Visual Studio</span></span>
    * <span data-ttu-id="afe41-179">ターゲットを上部のツールバーを使用して変更**リリース**と**x86**します。</span><span class="sxs-lookup"><span data-stu-id="afe41-179">Using the top toolbar change target to **Release** and **x86**.</span></span>
    * <span data-ttu-id="afe41-180">矢印をクリックして**ローカル マシン**選択と**デバイス**HoloLens にデプロイするには</span><span class="sxs-lookup"><span data-stu-id="afe41-180">Click the arrow next to **Local Machine** and select **Device** to deploy to HoloLens</span></span>
    * <span data-ttu-id="afe41-181">矢印をクリックして**デバイス**選択**ローカル マシン**mixed reality ヘッドセットをデプロイします。</span><span class="sxs-lookup"><span data-stu-id="afe41-181">Click the arrow next to **Device** and select **Local Machine** to deploy for the mixed reality headset.</span></span>
    * <span data-ttu-id="afe41-182">クリックして**デバッグ]、[デバッグなしで開始**または**コントロール + f5 キーを押して**アプリケーションを起動します。</span><span class="sxs-lookup"><span data-stu-id="afe41-182">Click **Debug->Start Without Debugging** or **Control+F5** to start the application.</span></span>

### <a name="digging-into-the-code"></a><span data-ttu-id="afe41-183">コードをについてください。</span><span class="sxs-lookup"><span data-stu-id="afe41-183">Digging into the code</span></span>

<span data-ttu-id="afe41-184">[プロジェクト] パネルに移動します**Assets\HoloToolkit\Input\Scripts\Utilities**をダブルクリックして**MixedRealityCameraManager.cs**を開きます。</span><span class="sxs-lookup"><span data-stu-id="afe41-184">In the project panel, navigate to **Assets\HoloToolkit\Input\Scripts\Utilities** and double click **MixedRealityCameraManager.cs** to open it.</span></span>

<span data-ttu-id="afe41-185">**概要:** MixedRealityCameraManager.cs は、デバイスに基づいて、品質のレベルとバック グラウンドの設定を調整する単純なスクリプトです。</span><span class="sxs-lookup"><span data-stu-id="afe41-185">**Overview:** MixedRealityCameraManager.cs is a simple script that adjusts quality level and background settings based on the device.</span></span> <span data-ttu-id="afe41-186">キー HolographicSettings.IsDisplayOpaque、これにより、デバイスが、HoloLens を検出するスクリプトを次に示します (IsDisplayOpaque false を返す) または (IsDisplayOpaque true を返す)、イマーシブ ヘッドセット。</span><span class="sxs-lookup"><span data-stu-id="afe41-186">Key here is HolographicSettings.IsDisplayOpaque, which allows a script to detect if the device is a HoloLens (IsDisplayOpaque returns false) or an immersive headset (IsDisplayOpaque returns true).</span></span>

### <a name="enjoy-your-progress"></a><span data-ttu-id="afe41-187">進行状況をお楽しみください。</span><span class="sxs-lookup"><span data-stu-id="afe41-187">Enjoy your progress</span></span>

<span data-ttu-id="afe41-188">この時点で、アプリケーションはホログラムだけを表示します。</span><span class="sxs-lookup"><span data-stu-id="afe41-188">At this point the application will just render a hologram.</span></span> <span data-ttu-id="afe41-189">後で、ホログラムに相互作用を追加します。</span><span class="sxs-lookup"><span data-stu-id="afe41-189">We will add interaction to the hologram later.</span></span> <span data-ttu-id="afe41-190">両方のデバイスは、レンダリング、ホログラム同じ。</span><span class="sxs-lookup"><span data-stu-id="afe41-190">Both devices will render the hologram the same.</span></span> <span data-ttu-id="afe41-191">イマーシブ ヘッドセットは青色空とクラウドのバック グラウンドにも表示します。</span><span class="sxs-lookup"><span data-stu-id="afe41-191">The immersive headset will also render a blue sky and clouds background.</span></span>

## <a name="chapter-2---interaction"></a><span data-ttu-id="afe41-192">第 2 章 – 相互作用</span><span class="sxs-lookup"><span data-stu-id="afe41-192">Chapter 2 - Interaction</span></span>

>[!VIDEO https://www.youtube.com/embed/Lrb1y4sQRvI]

### <a name="objectives"></a><span data-ttu-id="afe41-193">目標</span><span class="sxs-lookup"><span data-stu-id="afe41-193">Objectives</span></span>

<span data-ttu-id="afe41-194">Windows Mixed Reality アプリケーションの入力を処理する方法を示します。</span><span class="sxs-lookup"><span data-stu-id="afe41-194">Show how to handle input for a Windows Mixed Reality application.</span></span>

### <a name="what-we-will-build"></a><span data-ttu-id="afe41-195">構築します。</span><span class="sxs-lookup"><span data-stu-id="afe41-195">What we will build</span></span>

<span data-ttu-id="afe41-196">第 1 章からアプリケーションを構築して、ユーザーが、ホログラムを選択し、HoloLens で現実世界の画面で、または、イマーシブ ヘッドセットの仮想テーブルに配置できるようにする機能を追加します。</span><span class="sxs-lookup"><span data-stu-id="afe41-196">Building on the application from chapter 1, we will add functionality to allow the user to pick up the hologram and place it on a real world surface in HoloLens or on a virtual table in an immersive headset.</span></span>

<span data-ttu-id="afe41-197">**入力リフレッシャーは:** HoloLens 選択ジェスチャは、**エア タップ**します。</span><span class="sxs-lookup"><span data-stu-id="afe41-197">**Input Refresher:** On HoloLens the select gesture is the **air tap**.</span></span> <span data-ttu-id="afe41-198">イマーシブ ヘッドセットでの使用、 **A** Xbox コント ローラー上のボタンをクリックします。</span><span class="sxs-lookup"><span data-stu-id="afe41-198">On immersive headsets, we will use the **A** button on the Xbox controller.</span></span> <span data-ttu-id="afe41-199">入力の詳細については[ここから始めて](gestures.md)します。</span><span class="sxs-lookup"><span data-stu-id="afe41-199">For more information on input [start here](gestures.md).</span></span>

### <a name="steps"></a><span data-ttu-id="afe41-200">手順</span><span class="sxs-lookup"><span data-stu-id="afe41-200">Steps</span></span>
* <span data-ttu-id="afe41-201">入力マネージャーを追加します。</span><span class="sxs-lookup"><span data-stu-id="afe41-201">Add Input manager</span></span>
    * <span data-ttu-id="afe41-202">**HoloToolkit > の入力 > プレハブ**ドラッグ**InputManager**に**階層**の子として**マネージャー**します。</span><span class="sxs-lookup"><span data-stu-id="afe41-202">From **HoloToolkit > Input > Prefabs** drag **InputManager** to **Hierarchy** as a child of **Managers**.</span></span>
    * <span data-ttu-id="afe41-203">**HoloToolkit > の入力 > プレハブ > カーソル**ドラッグ**カーソル**に**階層**します。</span><span class="sxs-lookup"><span data-stu-id="afe41-203">From **HoloToolkit > Input > Prefabs > Cursor** drag **Cursor** to **Hierarchy**.</span></span>
* <span data-ttu-id="afe41-204">空間マッピングを追加します。</span><span class="sxs-lookup"><span data-stu-id="afe41-204">Add Spatial Mapping</span></span>
    * <span data-ttu-id="afe41-205">**HoloToolkit > SpatialMapping > プレハブ**ドラッグ**SpatialMapping**に**階層**します。</span><span class="sxs-lookup"><span data-stu-id="afe41-205">From **HoloToolkit > SpatialMapping > Prefabs** drag **SpatialMapping** to **Hierarchy**.</span></span>
* <span data-ttu-id="afe41-206">仮想 Playspace を追加します。</span><span class="sxs-lookup"><span data-stu-id="afe41-206">Add Virtual Playspace</span></span>
    * <span data-ttu-id="afe41-207">**階層**展開**MixedRealityCameraParent**選択**境界**</span><span class="sxs-lookup"><span data-stu-id="afe41-207">In **Hierarchy** expand **MixedRealityCameraParent** select **Boundary**</span></span>
    * <span data-ttu-id="afe41-208">**インスペクター**パネルのチェック ボックスを有効にするを**境界**</span><span class="sxs-lookup"><span data-stu-id="afe41-208">In **Inspector** panel check the box to enable **Boundary**</span></span>
    * <span data-ttu-id="afe41-209">**AppPrefabs**ドラッグ**VRRoom**に**階層**します。</span><span class="sxs-lookup"><span data-stu-id="afe41-209">From **AppPrefabs** drag **VRRoom** to **Hierarchy**.</span></span>
* <span data-ttu-id="afe41-210">WorldAnchorManager を追加します。</span><span class="sxs-lookup"><span data-stu-id="afe41-210">Add WorldAnchorManager</span></span>
    * <span data-ttu-id="afe41-211">**階層**、**マネージャー**します。</span><span class="sxs-lookup"><span data-stu-id="afe41-211">In **Hierarchy**, Select **Managers**.</span></span>
    * <span data-ttu-id="afe41-212">**インスペクター**、 をクリックして**コンポーネントの追加**します。</span><span class="sxs-lookup"><span data-stu-id="afe41-212">In **Inspector**, click **Add Component**.</span></span>
    * <span data-ttu-id="afe41-213">型**World アンカー Manager**します。</span><span class="sxs-lookup"><span data-stu-id="afe41-213">Type **World Anchor Manager**.</span></span>
    * <span data-ttu-id="afe41-214">選択**World アンカー Manager**に追加します。</span><span class="sxs-lookup"><span data-stu-id="afe41-214">Select **World Anchor Manager** to add it.</span></span>
* <span data-ttu-id="afe41-215">TapToPlace を島に追加します。</span><span class="sxs-lookup"><span data-stu-id="afe41-215">Add TapToPlace to the Island</span></span>
    * <span data-ttu-id="afe41-216">**階層**、展開**島**します。</span><span class="sxs-lookup"><span data-stu-id="afe41-216">In **Hierarchy**, expand **Island**.</span></span>
    * <span data-ttu-id="afe41-217">選択**MixedRealityLand**します。</span><span class="sxs-lookup"><span data-stu-id="afe41-217">Select **MixedRealityLand**.</span></span>
    * <span data-ttu-id="afe41-218">**インスペクター**、 をクリックして**コンポーネントの追加**します。</span><span class="sxs-lookup"><span data-stu-id="afe41-218">In **Inspector**, click **Add Component**.</span></span>
    * <span data-ttu-id="afe41-219">型**の場所をタップして**して選択します。</span><span class="sxs-lookup"><span data-stu-id="afe41-219">Type **Tap To Place** and select it.</span></span>
    * <span data-ttu-id="afe41-220">確認**Tap に親を配置**します。</span><span class="sxs-lookup"><span data-stu-id="afe41-220">Check **Place Parent On Tap**.</span></span>
    * <span data-ttu-id="afe41-221">設定**配置オフセット**に **(0, 0.1, 0)** します。</span><span class="sxs-lookup"><span data-stu-id="afe41-221">Set **Placement Offset** to **(0, 0.1, 0)**.</span></span>
* <span data-ttu-id="afe41-222">保存し、以前とビルド</span><span class="sxs-lookup"><span data-stu-id="afe41-222">Save and Build as before</span></span>

### <a name="digging-into-the-code"></a><span data-ttu-id="afe41-223">コードをについてください。</span><span class="sxs-lookup"><span data-stu-id="afe41-223">Digging into the code</span></span>

<span data-ttu-id="afe41-224">**スクリプト 1 - GamepadInput.cs**</span><span class="sxs-lookup"><span data-stu-id="afe41-224">**Script 1 - GamepadInput.cs**</span></span>

<span data-ttu-id="afe41-225">[プロジェクト] パネルに移動します**Assets\HoloToolkit\Input\Scripts\InputSources**をダブルクリックして**GamepadInput.cs**を開きます。</span><span class="sxs-lookup"><span data-stu-id="afe41-225">In the project panel navigate to **Assets\HoloToolkit\Input\Scripts\InputSources** and double click **GamepadInput.cs** to open it.</span></span> <span data-ttu-id="afe41-226">[プロジェクト] パネルで同じパスにもダブルクリック**InteractionSourceInputSource.cs**します。</span><span class="sxs-lookup"><span data-stu-id="afe41-226">From the same path in the project panel, also double click **InteractionSourceInputSource.cs**.</span></span>

<span data-ttu-id="afe41-227">両方のスクリプトが共通の基本クラス BaseInputSource を持つことに注意してください。</span><span class="sxs-lookup"><span data-stu-id="afe41-227">Note that both scripts have a common base class, BaseInputSource.</span></span>

<span data-ttu-id="afe41-228">BaseInputSource、InputManager では、により、スクリプトでイベントをトリガーへの参照を保持します。</span><span class="sxs-lookup"><span data-stu-id="afe41-228">BaseInputSource keeps a reference to an InputManager, which allows a script to trigger events.</span></span> <span data-ttu-id="afe41-229">この場合、InputClicked イベントが関連します。</span><span class="sxs-lookup"><span data-stu-id="afe41-229">In this case, the InputClicked event is relevant.</span></span> <span data-ttu-id="afe41-230">これは、スクリプト 2、TapToPlace を取得する際に重要になります。</span><span class="sxs-lookup"><span data-stu-id="afe41-230">This will be important to remember when we get to script 2, TapToPlace.</span></span> <span data-ttu-id="afe41-231">GamePadInput の場合は、A ボタンを押す、コント ローラーでのポーリングし、InputClicked イベントが発生しました。</span><span class="sxs-lookup"><span data-stu-id="afe41-231">In the case of GamePadInput, we poll for the A button on the controller to be pressed, then we raise the InputClicked event.</span></span> <span data-ttu-id="afe41-232">InteractionSourceInputSource の場合は、TappedEvent への応答で InputClicked イベントを発生します。</span><span class="sxs-lookup"><span data-stu-id="afe41-232">In the case of InteractionSourceInputSource, we raise the InputClicked event in response to the TappedEvent.</span></span>

<span data-ttu-id="afe41-233">**2 - TapToPlace.cs スクリプト**</span><span class="sxs-lookup"><span data-stu-id="afe41-233">**Script 2 - TapToPlace.cs**</span></span>

<span data-ttu-id="afe41-234">[プロジェクト] パネルに移動します**Assets\HoloToolkit\SpatialMapping\Scripts**をダブルクリックして**TapToPlace.cs**を開きます。</span><span class="sxs-lookup"><span data-stu-id="afe41-234">In the project panel navigate to **Assets\HoloToolkit\SpatialMapping\Scripts** and double click **TapToPlace.cs** to open it.</span></span>

<span data-ttu-id="afe41-235">まず、多くの開発者が Holographic アプリケーションを作成するときに実装するには、ジェスチャ入力ホログラムは移動です。</span><span class="sxs-lookup"><span data-stu-id="afe41-235">The first thing many developers want to implement when creating a Holographic application is moving Holograms with gesture input.</span></span> <span data-ttu-id="afe41-236">そのため、このスクリプトを十分にコメントするよう努めていますしました。</span><span class="sxs-lookup"><span data-stu-id="afe41-236">As such, we've endeavored to thoroughly comment this script.</span></span> <span data-ttu-id="afe41-237">いくつかの点では、このチュートリアルでは注目すべきです。</span><span class="sxs-lookup"><span data-stu-id="afe41-237">A few things are worth highlighting for this tutorial.</span></span>

<span data-ttu-id="afe41-238">まず、TapToPlace IInputClickHandler を実装することに注意してください。</span><span class="sxs-lookup"><span data-stu-id="afe41-238">First, note that TapToPlace implements IInputClickHandler.</span></span> <span data-ttu-id="afe41-239">IInputClickHandler は、GamePadInput.cs または InteractionSourceInputSource.cs によって発生する InputClicked イベントを処理する関数を公開します。</span><span class="sxs-lookup"><span data-stu-id="afe41-239">IInputClickHandler exposes the functions that handle the InputClicked event raised by GamePadInput.cs or InteractionSourceInputSource.cs.</span></span> <span data-ttu-id="afe41-240">BaseInputSource TapToPlace のオブジェクトにフォーカスが中に、クリックを検出する OnInputClicked が呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="afe41-240">OnInputClicked is called when a BaseInputSource detects a click while the object with TapToPlace is in focus.</span></span> <span data-ttu-id="afe41-241">HoloLens で airtapping または Xbox コント ローラーで、[A] ボタンを押してのいずれかは、イベントをトリガーします。</span><span class="sxs-lookup"><span data-stu-id="afe41-241">Either airtapping on HoloLens or pressing the A button on the Xbox controller will trigger the event.</span></span>

<span data-ttu-id="afe41-242">2 つ目は、参照テーブルのように、サーフェイス ゲーム オブジェクトを配置できるように、サーフェスがで参照されるかどうかの更新で、コードを実行します。</span><span class="sxs-lookup"><span data-stu-id="afe41-242">Second is the code be executed in update to see if a surface is being looked at so we can place the game object on a surface, like a table.</span></span> <span data-ttu-id="afe41-243">イマーシブ ヘッドセットは実際のサーフェスの概念をこれがないテーブルの一番上を表すオブジェクト (Vroom > TableThingy > キューブ) 更新プログラムでキャスト射線は仮想テーブルの上部と競合するので、SpatialMapping 物理層がマークされています。</span><span class="sxs-lookup"><span data-stu-id="afe41-243">The immersive headset doesn't have a concept of real surfaces, so the object that represents the table top (Vroom > TableThingy > Cube) has been marked with the SpatialMapping physics layer, so the ray cast in Update will collide with the virtual table top.</span></span>

### <a name="enjoy-your-progress"></a><span data-ttu-id="afe41-244">進行状況をお楽しみください。</span><span class="sxs-lookup"><span data-stu-id="afe41-244">Enjoy your progress</span></span>

<span data-ttu-id="afe41-245">この時間に移動島を選択できます。</span><span class="sxs-lookup"><span data-stu-id="afe41-245">This time you can select the island to move it.</span></span> <span data-ttu-id="afe41-246">HoloLens の島を実際の画面に移動できます。</span><span class="sxs-lookup"><span data-stu-id="afe41-246">On HoloLens you can move the island to a real surface.</span></span> <span data-ttu-id="afe41-247">イマーシブ ヘッドセットには、仮想テーブルを追加しましたに島を移動できます。</span><span class="sxs-lookup"><span data-stu-id="afe41-247">In the immersive headset you can move the island to the virtual table we added.</span></span>

## <a name="chapter-3---sharing"></a><span data-ttu-id="afe41-248">第 3 章 - 共有</span><span class="sxs-lookup"><span data-stu-id="afe41-248">Chapter 3 - Sharing</span></span>

>[!VIDEO https://www.youtube.com/embed/1diycJvxfDc]

### <a name="objectives"></a><span data-ttu-id="afe41-249">目標</span><span class="sxs-lookup"><span data-stu-id="afe41-249">Objectives</span></span>

<span data-ttu-id="afe41-250">ネットワークが正しく構成されていることを確認し、詳細空間アンカーは、デバイス間で共有される方法です。</span><span class="sxs-lookup"><span data-stu-id="afe41-250">Ensure that the network is correctly configured and detail how spatial anchors are shared between devices.</span></span>

### <a name="what-we-will-build"></a><span data-ttu-id="afe41-251">構築します。</span><span class="sxs-lookup"><span data-stu-id="afe41-251">What we will build</span></span>

<span data-ttu-id="afe41-252">このプロジェクトはマルチプレイヤー プロジェクトに変換します。</span><span class="sxs-lookup"><span data-stu-id="afe41-252">We will convert our project to a multiplayer project.</span></span> <span data-ttu-id="afe41-253">ホストまたは結合のセッションに UI とロジックを追加します。</span><span class="sxs-lookup"><span data-stu-id="afe41-253">We will add UI and logic to host or join sessions.</span></span> <span data-ttu-id="afe41-254">HoloLens のユーザーが互いを見るとクラウドのセッションで、頭の上、イマーシブ ヘッドセット ユーザーがクラウド アンカーが近くにあります。</span><span class="sxs-lookup"><span data-stu-id="afe41-254">HoloLens users will see each other in the session with clouds over their heads, and immersive headset users have clouds near to where the anchor is.</span></span> <span data-ttu-id="afe41-255">イマーシブ ヘッドセット内のユーザーは、シーンの原点 HoloLens のユーザーに表示されます。</span><span class="sxs-lookup"><span data-stu-id="afe41-255">Users in the immersive headsets will see the HoloLens users relative to the origin of the scene.</span></span> <span data-ttu-id="afe41-256">HoloLens のユーザーの同じ場所に島ホログラムがすべて参照してください。</span><span class="sxs-lookup"><span data-stu-id="afe41-256">HoloLens users will all see the hologram of the island in the same place.</span></span> <span data-ttu-id="afe41-257">キー、イマーシブ ヘッドセット内のユーザーがこの章では、中に、島にされませんが、アイランドの鳥アイ ビューで、HoloLens を非常によく似た動作をすることをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="afe41-257">It is key to note that the users in the immersive headsets will not be on the island during this chapter, but will behave very similarly to HoloLens, with a birds eye view of the island.</span></span>

### <a name="steps"></a><span data-ttu-id="afe41-258">手順</span><span class="sxs-lookup"><span data-stu-id="afe41-258">Steps</span></span>
* <span data-ttu-id="afe41-259">削除島と VRRoom</span><span class="sxs-lookup"><span data-stu-id="afe41-259">Remove Island and VRRoom</span></span>
    * <span data-ttu-id="afe41-260">**階層**右**島**選択**削除**</span><span class="sxs-lookup"><span data-stu-id="afe41-260">In **Hierarchy** right-click **Island** select **Delete**</span></span>
    * <span data-ttu-id="afe41-261">**階層**右**VRRoom**選択**削除**</span><span class="sxs-lookup"><span data-stu-id="afe41-261">In **Hierarchy** right-click **VRRoom** select **Delete**</span></span>
* <span data-ttu-id="afe41-262">Usland を追加します。</span><span class="sxs-lookup"><span data-stu-id="afe41-262">Add Usland</span></span>
    * <span data-ttu-id="afe41-263">**AppPrefabs**ドラッグ**Usland**に**階層**します。</span><span class="sxs-lookup"><span data-stu-id="afe41-263">From **AppPrefabs** drag **Usland** to **Hierarchy**.</span></span>
* <span data-ttu-id="afe41-264">**AppPrefabs**ドラッグするには、次の各**階層**:</span><span class="sxs-lookup"><span data-stu-id="afe41-264">From **AppPrefabs** drag each of the following to **Hierarchy**:</span></span>
    * <span data-ttu-id="afe41-265">**UNETSharingStage**</span><span class="sxs-lookup"><span data-stu-id="afe41-265">**UNETSharingStage**</span></span>
    * <span data-ttu-id="afe41-266">**UNetAnchorRoot**</span><span class="sxs-lookup"><span data-stu-id="afe41-266">**UNetAnchorRoot**</span></span>
    * <span data-ttu-id="afe41-267">**UIContainer**</span><span class="sxs-lookup"><span data-stu-id="afe41-267">**UIContainer**</span></span>
    * <span data-ttu-id="afe41-268">**DebugPanelButton**</span><span class="sxs-lookup"><span data-stu-id="afe41-268">**DebugPanelButton**</span></span>
* <span data-ttu-id="afe41-269">保存し、以前とビルド</span><span class="sxs-lookup"><span data-stu-id="afe41-269">Save and Build as before</span></span>

### <a name="digging-into-the-code"></a><span data-ttu-id="afe41-270">コードをについてください。</span><span class="sxs-lookup"><span data-stu-id="afe41-270">Digging into the code</span></span>

<span data-ttu-id="afe41-271">[プロジェクト] パネルに移動します**Assets\AppPrefabs\Support\SharingWithUnet\Scripts**ダブルクリックして**UnetAnchorManager.cs**します。</span><span class="sxs-lookup"><span data-stu-id="afe41-271">In the project panel, navigate to **Assets\AppPrefabs\Support\SharingWithUnet\Scripts** and double-click on **UnetAnchorManager.cs**.</span></span> <span data-ttu-id="afe41-272">デバイスの両方で同じスペースを共有できるように、別の HoloLens と追跡情報を共有する 1 つの HoloLens の機能は、魔法の近くです。</span><span class="sxs-lookup"><span data-stu-id="afe41-272">The ability for one HoloLens to share tracking information with another HoloLens such that both devices can share the same space is near magical.</span></span> <span data-ttu-id="afe41-273">複合現実の電源がアライブの場合は、2 つ、またはより多くの人が同じデジタル データを使用して共同作業できます。</span><span class="sxs-lookup"><span data-stu-id="afe41-273">The power of mixed reality comes alive when two or more people can collaborate using the same digital data.</span></span>

<span data-ttu-id="afe41-274">このスクリプトで指摘していくつかの点。</span><span class="sxs-lookup"><span data-stu-id="afe41-274">A few things to point out in this script:</span></span>

<span data-ttu-id="afe41-275">Start 関数のチェックに注意してください。 **IsDisplayOpaque**します。</span><span class="sxs-lookup"><span data-stu-id="afe41-275">In the start function, notice the check for **IsDisplayOpaque**.</span></span> <span data-ttu-id="afe41-276">この場合、アンカーが確立されている見かけ上します。</span><span class="sxs-lookup"><span data-stu-id="afe41-276">In this case, we pretend that the Anchor is established.</span></span> <span data-ttu-id="afe41-277">これは、イマーシブ ヘッドセットはインポートまたはアンカーをエクスポートする方法を公開しないためにです。</span><span class="sxs-lookup"><span data-stu-id="afe41-277">This is because the immersive headsets do not expose a way to import or export anchors.</span></span> <span data-ttu-id="afe41-278">私たちは、HoloLens で実行している場合、ただし、このスクリプトはデバイス間で共有のアンカーを実装します。</span><span class="sxs-lookup"><span data-stu-id="afe41-278">If we are running on a HoloLens, however, this script implements sharing anchors between the devices.</span></span> <span data-ttu-id="afe41-279">セッションを開始するデバイスでは、エクスポートするためのアンカーを作成します。</span><span class="sxs-lookup"><span data-stu-id="afe41-279">The device that starts the session will create an anchor for exporting.</span></span> <span data-ttu-id="afe41-280">セッションを開始したデバイスからは、セッションに参加するデバイスは、アンカーを要求します。</span><span class="sxs-lookup"><span data-stu-id="afe41-280">The device that joins a session will request the anchor from the device that started the session.</span></span>

<span data-ttu-id="afe41-281">**エクスポートするには。**</span><span class="sxs-lookup"><span data-stu-id="afe41-281">**Exporting:**</span></span>

<span data-ttu-id="afe41-282">ユーザーは、セッションを作成するときに、NetworkDiscoveryWithAnchors は UNETAnchorManagers CreateAnchor 関数を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="afe41-282">When a user creates a session, NetworkDiscoveryWithAnchors will call UNETAnchorManagers CreateAnchor function.</span></span> <span data-ttu-id="afe41-283">CreateAnchor フローを追いかけてみましょう。</span><span class="sxs-lookup"><span data-stu-id="afe41-283">Let's follow CreateAnchor flow.</span></span>

<span data-ttu-id="afe41-284">まず、前の基準の収集された可能性がありますがデータを消去する、いくつかのハウスキーピングを実行します。</span><span class="sxs-lookup"><span data-stu-id="afe41-284">We start by doing some housekeeping, clearing out any data we may have collected for previous anchors.</span></span> <span data-ttu-id="afe41-285">キャッシュのアンカーを読み込むかどうかは確認します。</span><span class="sxs-lookup"><span data-stu-id="afe41-285">Then we check if there is a cached anchor to load.</span></span> <span data-ttu-id="afe41-286">アンカーのデータは、キャッシュされた表現のアンカーを再利用で、ネットワーク経由で転送する必要。 データの量に保存できるようにの 5 ~ 20 mb にする傾向があります。</span><span class="sxs-lookup"><span data-stu-id="afe41-286">The anchor data tends to be between 5 and 20 MB, so reusing cached anchors can save on the amount of data we need to transfer over the network.</span></span> <span data-ttu-id="afe41-287">後で少し動作が表示されます。</span><span class="sxs-lookup"><span data-stu-id="afe41-287">We'll see how this works a bit later.</span></span> <span data-ttu-id="afe41-288">アンカーを再利用しますが、場合でも、新しいクライアントを結合する場合にデータの準備がないアンカーのアンカーを取得する必要があります。</span><span class="sxs-lookup"><span data-stu-id="afe41-288">Even if we are reusing the anchor, we need to get the anchor data ready in case a new client joins that doesn't have the anchor.</span></span>

<span data-ttu-id="afe41-289">アンカーのデータの準備と言えば、WorldAnchorTransferBatch クラスは、アンカーのデータをインポートするには、別のデバイスまたはアプリケーションと機能に送信するためのアンカーのデータを準備するための機能を公開します。</span><span class="sxs-lookup"><span data-stu-id="afe41-289">Speaking of getting the anchor data ready, the WorldAnchorTransferBatch class exposes the functionality to prepare anchor data for sending to another device or application and the functionality to import the anchor data.</span></span> <span data-ttu-id="afe41-290">エクスポート パスに対するだから私たち、WorldAnchorTransferBatch に、アンカーを追加し、ExportAsync 関数を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="afe41-290">Since we're on the export path, we will add our anchor to the WorldAnchorTransferBatch and call the ExportAsync function.</span></span> <span data-ttu-id="afe41-291">エクスポートのデータを生成し、ExportAsync は WriteBuffer コールバックを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="afe41-291">ExportAsync will then call the WriteBuffer callback as it generates data for export.</span></span> <span data-ttu-id="afe41-292">すべてのデータがエクスポートされると ExportComplete が呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="afe41-292">When all of the data has been exported ExportComplete will be called.</span></span> <span data-ttu-id="afe41-293">WriteBuffer では、エクスポートはあと保存リストにデータのチャンクを追加します。</span><span class="sxs-lookup"><span data-stu-id="afe41-293">In WriteBuffer we add the chunk of data to a list we keep for exporting.</span></span> <span data-ttu-id="afe41-294">ExportComplete で、配列にリストを変換します。</span><span class="sxs-lookup"><span data-stu-id="afe41-294">In ExportComplete we convert the list to an array.</span></span> <span data-ttu-id="afe41-295">AnchorName 変数も設定されます、その他のデバイスを起動することがあるない場合、アンカーを要求します。</span><span class="sxs-lookup"><span data-stu-id="afe41-295">The AnchorName variable is also set, which will trigger other devices to request the anchor if they don't have it.</span></span>

<span data-ttu-id="afe41-296">いくつかの場合、アンカーをエクスポートしませんまたはデータが少量は作成私たちはもう一度やり直してください。</span><span class="sxs-lookup"><span data-stu-id="afe41-296">In some cases the anchor won't export or will create so little data that we will try again.</span></span> <span data-ttu-id="afe41-297">ここでだけ呼び出して CreateAnchor もう一度です。</span><span class="sxs-lookup"><span data-stu-id="afe41-297">Here we just call CreateAnchor again.</span></span>

<span data-ttu-id="afe41-298">エクスポート パスに最終的な関数では、AnchorFoundRemotely です。</span><span class="sxs-lookup"><span data-stu-id="afe41-298">A final function in the export path is AnchorFoundRemotely.</span></span> <span data-ttu-id="afe41-299">別のデバイスには、アンカーが検出されると、そのデバイスをホストに通知され、ホスト アンカーが「良いアンカー」シグナルとしてを使用してキャッシュできます。</span><span class="sxs-lookup"><span data-stu-id="afe41-299">When another device finds the anchor, that device will tell the host, and the host will use that as a signal that the anchor is a "good anchor" and can be cached.</span></span>

<span data-ttu-id="afe41-300">**インポート。**</span><span class="sxs-lookup"><span data-stu-id="afe41-300">**Importing:**</span></span>

<span data-ttu-id="afe41-301">HoloLens は、セッションに参加する場合は、アンカーのインポートが必要です。</span><span class="sxs-lookup"><span data-stu-id="afe41-301">When a HoloLens joins a session, it needs to import an anchor.</span></span> <span data-ttu-id="afe41-302">UNETAnchorManager の更新プログラムの関数で、AnchorName にポーリングされます。</span><span class="sxs-lookup"><span data-stu-id="afe41-302">In UNETAnchorManager's Update function, the AnchorName is polled.</span></span> <span data-ttu-id="afe41-303">アンカーの名前が変更されたときに、インポート プロセスを開始します。</span><span class="sxs-lookup"><span data-stu-id="afe41-303">When the anchor name changes, the import process begins.</span></span> <span data-ttu-id="afe41-304">まず、アンカーのローカル ストアから、指定した名前のアンカーを読み込むとします。</span><span class="sxs-lookup"><span data-stu-id="afe41-304">First, we try to load the anchor with the specified name from the local anchor store.</span></span> <span data-ttu-id="afe41-305">既にがある場合に、そのデータをもう一度ダウンロードしなくても使用できます。</span><span class="sxs-lookup"><span data-stu-id="afe41-305">If we already have it, we can use it without downloading the data again.</span></span> <span data-ttu-id="afe41-306">これがなければ、ダウンロードを開始する WaitForAnchor を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="afe41-306">If we don't have it, then we call WaitForAnchor which will initiate the download.</span></span>

<span data-ttu-id="afe41-307">ダウンロードが完了したら、NetworkTransmitter_dataReadyEvent が呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="afe41-307">When the download is completed, NetworkTransmitter_dataReadyEvent is called.</span></span> <span data-ttu-id="afe41-308">これは、ダウンロードされたデータで ImportAsync を呼び出すための更新ループでは通知します。</span><span class="sxs-lookup"><span data-stu-id="afe41-308">This will signal the Update loop to call ImportAsync with the downloaded data.</span></span> <span data-ttu-id="afe41-309">インポート処理が完了すると、ImportAsync は ImportComplete を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="afe41-309">ImportAsync will call ImportComplete when the import process is complete.</span></span> <span data-ttu-id="afe41-310">インポートが成功した場合は、アンカーは、プレーヤーのローカル ストアに保存されます。</span><span class="sxs-lookup"><span data-stu-id="afe41-310">If the import is successful, the anchor will be saved in the local player store.</span></span> <span data-ttu-id="afe41-311">により、PlayerController.cs は、実際には、ホストに適切なアンカーが確立されたことを認識させる AnchorFoundRemotely に呼び出しを行います。</span><span class="sxs-lookup"><span data-stu-id="afe41-311">PlayerController.cs actually makes the call to AnchorFoundRemotely to let the host know that a good anchor has been established.</span></span>

### <a name="enjoy-your-progress"></a><span data-ttu-id="afe41-312">進行状況をお楽しみください。</span><span class="sxs-lookup"><span data-stu-id="afe41-312">Enjoy your progress</span></span>

<span data-ttu-id="afe41-313">今回、HoloLens を持つユーザーをホストするセッションを使用して、**セッションを開始**UI のボタンをクリックします。</span><span class="sxs-lookup"><span data-stu-id="afe41-313">This time a user with a HoloLens will host a session using the **start session** button in the UI.</span></span> <span data-ttu-id="afe41-314">他のユーザー両方 HoloLens や、イマーシブ ヘッドセットは、セッションを選択し、選択、**セッションに参加する**UI のボタンをクリックします。</span><span class="sxs-lookup"><span data-stu-id="afe41-314">Other users, both on HoloLens or an immersive headset, will select the session and then select the **join session** button in the UI.</span></span> <span data-ttu-id="afe41-315">HoloLens デバイスで複数の人がある場合は、頭に赤のクラウドがあります。</span><span class="sxs-lookup"><span data-stu-id="afe41-315">If you have multiple people with HoloLens devices, they will have red clouds over their heads.</span></span> <span data-ttu-id="afe41-316">ありますの各イマーシブ ヘッドセット、青色の雲が青色の雲とは、ヘッドセット上、ヘッドセットは HoloLens デバイスとして同じワールド座標空間を検索していないようです。</span><span class="sxs-lookup"><span data-stu-id="afe41-316">There will also be a blue cloud for each immersive headset, but the blue clouds will not be above the headsets, as the headsets are not trying to find the same world coordinate space as the HoloLens devices.</span></span>

<span data-ttu-id="afe41-317">プロジェクトのこのポイントが含まれている共有アプリケーションです。非常にほとんど意味がありませんし、ベースラインとして機能する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="afe41-317">This point in the project is a contained sharing application; it doesn't do very much, and could act as a baseline.</span></span> <span data-ttu-id="afe41-318">[次へ] の章では、まず、ご利用いただくにユーザー エクスペリエンスを構築します。</span><span class="sxs-lookup"><span data-stu-id="afe41-318">In the next chapters, we will start building an experience for people to enjoy.</span></span> <span data-ttu-id="afe41-319">共有のエクスペリエンスの設計に関するガイダンスを入手さらに、移動します。</span><span class="sxs-lookup"><span data-stu-id="afe41-319">To get further guidance on shared experience design, go here.</span></span>

## <a name="chapter-4---immersion-and-teleporting"></a><span data-ttu-id="afe41-320">第 4 章 - Immersion と teleporting</span><span class="sxs-lookup"><span data-stu-id="afe41-320">Chapter 4 - Immersion and teleporting</span></span>

>[!VIDEO https://www.youtube.com/embed/kUHZ5tCOfvY]

### <a name="objectives"></a><span data-ttu-id="afe41-321">目標</span><span class="sxs-lookup"><span data-stu-id="afe41-321">Objectives</span></span>

<span data-ttu-id="afe41-322">複合現実デバイスの種類ごとにエクスペリエンスを提供します。</span><span class="sxs-lookup"><span data-stu-id="afe41-322">Cater the experience to each type of mixed reality device.</span></span>

### <a name="what-we-will-build"></a><span data-ttu-id="afe41-323">構築します。</span><span class="sxs-lookup"><span data-stu-id="afe41-323">What we will build</span></span>

<span data-ttu-id="afe41-324">没入型の表示、南の島でイマーシブ ヘッドセット ユーザーを配置するアプリケーションを更新します。</span><span class="sxs-lookup"><span data-stu-id="afe41-324">We will update the application to put immersive headset users on the island with an immersive view.</span></span> <span data-ttu-id="afe41-325">HoloLens のユーザーには、アイランドのバード アイ ビューがあります。</span><span class="sxs-lookup"><span data-stu-id="afe41-325">HoloLens users will still have the bird's eye view of the island.</span></span> <span data-ttu-id="afe41-326">各デバイスの種類のユーザーは、世界中に表示される他のユーザーを確認できます。</span><span class="sxs-lookup"><span data-stu-id="afe41-326">Users of each device type can see other users as they appear in the world.</span></span> <span data-ttu-id="afe41-327">たとえば、HoloLens ユーザー島上の巨大なクラウドとして表示し、イマーシブ ヘッドセット ユーザーでは、島、上の他のパスに他のアバターがわかります。</span><span class="sxs-lookup"><span data-stu-id="afe41-327">For instance, immersive headset users can see the other avatars on other paths on the island, and they see the HoloLens users as giant clouds above the island.</span></span> <span data-ttu-id="afe41-328">イマーシブ ヘッドセット ユーザーは、HoloLens のユーザーが、島で探している場合にも、HoloLens のユーザーの視線の先光線のカーソルに表示されます。</span><span class="sxs-lookup"><span data-stu-id="afe41-328">Immersive headset users will also see the cursor of the HoloLens user's gaze ray if the HoloLens user is looking at the island.</span></span> <span data-ttu-id="afe41-329">HoloLens のユーザーは、各イマーシブ ヘッドセット ユーザーを表す島にアバターが表示されます。</span><span class="sxs-lookup"><span data-stu-id="afe41-329">HoloLens users will see an avatar on the island to represent each immersive headset user.</span></span>

<span data-ttu-id="afe41-330">**没入型のデバイスの更新の入力:**</span><span class="sxs-lookup"><span data-stu-id="afe41-330">**Updated Input for the Immersive device:**</span></span>
* <span data-ttu-id="afe41-331">Xbox コント ローラーの左側のエンジンとエンジンの右ボタンが、プレーヤーを回転させる</span><span class="sxs-lookup"><span data-stu-id="afe41-331">The left bumper and right bumper buttons on the Xbox controller rotate the player</span></span>
* <span data-ttu-id="afe41-332">Xbox コント ローラーで、[Y] ボタンを保持しているが有効になります、[テレポート](navigating-the-windows-mixed-reality-home.md#getting-around-your-home)カーソル。</span><span class="sxs-lookup"><span data-stu-id="afe41-332">Holding the Y button on the Xbox controller will enable a [teleport](navigating-the-windows-mixed-reality-home.md#getting-around-your-home) cursor.</span></span> <span data-ttu-id="afe41-333">カーソルが矢印インジケーターが回転 Y ボタンを離したときに、カーソルの場所に波及ができます。</span><span class="sxs-lookup"><span data-stu-id="afe41-333">If the cursor has a spinning arrow indicator when you release the Y button, you will be teleported to the cursor's location.</span></span>

### <a name="steps"></a><span data-ttu-id="afe41-334">手順</span><span class="sxs-lookup"><span data-stu-id="afe41-334">Steps</span></span>
* <span data-ttu-id="afe41-335">MixedRealityCameraParent MixedRealityTeleport に追加します。</span><span class="sxs-lookup"><span data-stu-id="afe41-335">Add MixedRealityTeleport to MixedRealityCameraParent</span></span>
    * <span data-ttu-id="afe41-336">**階層**、 **Usland**します。</span><span class="sxs-lookup"><span data-stu-id="afe41-336">In **Hierarchy**, select **Usland**.</span></span>
    * <span data-ttu-id="afe41-337">**インスペクター**、有効にする**レベルの制御**します。</span><span class="sxs-lookup"><span data-stu-id="afe41-337">In **Inspector**, enable **Level Control**.</span></span>
    * <span data-ttu-id="afe41-338">**階層**、 **MixedRealityCameraParent**します。</span><span class="sxs-lookup"><span data-stu-id="afe41-338">In **Hierarchy**, select **MixedRealityCameraParent**.</span></span>
    * <span data-ttu-id="afe41-339">**インスペクター**、 をクリックして**コンポーネントの追加**します。</span><span class="sxs-lookup"><span data-stu-id="afe41-339">In **Inspector**, click **Add Component**.</span></span>
    * <span data-ttu-id="afe41-340">型**Mixed Reality テレポート**して選択します。</span><span class="sxs-lookup"><span data-stu-id="afe41-340">Type **Mixed Reality Teleport** and select it.</span></span>

### <a name="digging-into-the-code"></a><span data-ttu-id="afe41-341">コードをについてください。</span><span class="sxs-lookup"><span data-stu-id="afe41-341">Digging into the code</span></span>

<span data-ttu-id="afe41-342">イマーシブ ヘッドセット ユーザーは、ケーブルで自分の Pc にテザリングされたされますが、アイランドは、ケーブルが長よりも大きい。</span><span class="sxs-lookup"><span data-stu-id="afe41-342">Immersive headset users will be tethered to their PCs with a cable, but our island is larger than the cable is long.</span></span> <span data-ttu-id="afe41-343">補正するために、ユーザーの動きとは無関係にカメラを移動できる必要があります。</span><span class="sxs-lookup"><span data-stu-id="afe41-343">To compensate, we need the ability to move the camera independently of the user's motion.</span></span> <span data-ttu-id="afe41-344">参照してください、[元気の出るページ](comfort.md)複合現実のアプリケーションの (特に自己モーション センサーと locomotion) 設計の詳細についてはします。</span><span class="sxs-lookup"><span data-stu-id="afe41-344">Please see the [comfort page](comfort.md) for more information about designing your mixed reality application (in particular self motion and locomotion).</span></span>

<span data-ttu-id="afe41-345">このプロセスを説明するために 2 つの用語を定義すると便利ですがあります。</span><span class="sxs-lookup"><span data-stu-id="afe41-345">In order to describe this process it will be useful to define two terms.</span></span> <span data-ttu-id="afe41-346">まず、**けん引**ユーザーからしないカメラを個別に移動するオブジェクトになります。</span><span class="sxs-lookup"><span data-stu-id="afe41-346">First, **dolly** will be the object that moves the camera independently from the user.</span></span> <span data-ttu-id="afe41-347">子ゲーム オブジェクト、**けん引**なります、**メイン カメラ**します。</span><span class="sxs-lookup"><span data-stu-id="afe41-347">A child game object of the **dolly** will be the **main camera**.</span></span> <span data-ttu-id="afe41-348">メイン カメラは、ユーザーの頭にアタッチされます。</span><span class="sxs-lookup"><span data-stu-id="afe41-348">The main camera is attached to the user's head.</span></span>

<span data-ttu-id="afe41-349">[プロジェクト] パネルに移動します**Assets\AppPrefabs\Support\Scripts\GameLogic**ダブルクリックして**MixedRealityTeleport.cs**します。</span><span class="sxs-lookup"><span data-stu-id="afe41-349">In the project panel, navigate to **Assets\AppPrefabs\Support\Scripts\GameLogic** and double-click on **MixedRealityTeleport.cs**.</span></span>

<span data-ttu-id="afe41-350">MixedRealityTeleport には、2 つのジョブがあります。</span><span class="sxs-lookup"><span data-stu-id="afe41-350">MixedRealityTeleport has two jobs.</span></span> <span data-ttu-id="afe41-351">最初に、エンジンを使用して回転を処理します。</span><span class="sxs-lookup"><span data-stu-id="afe41-351">First, it handles rotation using the bumpers.</span></span> <span data-ttu-id="afe41-352">Update 関数で 'ButtonUp' LeftBumper と RightBumper のポーリングします。</span><span class="sxs-lookup"><span data-stu-id="afe41-352">In the update function we poll for 'ButtonUp' on LeftBumper and RightBumper.</span></span> <span data-ttu-id="afe41-353">GetButtonUp のみ true を返すボタンがアップ ダウンになった後は、最初のフレームでします。</span><span class="sxs-lookup"><span data-stu-id="afe41-353">GetButtonUp only returns true on the first frame a button is up after having been down.</span></span> <span data-ttu-id="afe41-354">わかった場合は、いずれかのボタンが発生し、ユーザーは、回転する必要があります。</span><span class="sxs-lookup"><span data-stu-id="afe41-354">If either button had been raised, then we know the user needs to rotate.</span></span>

<span data-ttu-id="afe41-355">私たちを回転フェードの操作を行います、フェード 'フェード コントロール' という名前の単純なスクリプトを使用しています。</span><span class="sxs-lookup"><span data-stu-id="afe41-355">When we rotate we do a fade out and fade in using a simple script called 'fade control'.</span></span> <span data-ttu-id="afe41-356">これをユーザーが不安を招く可能性がある不自然の移動を確認するを防ぐために行います。</span><span class="sxs-lookup"><span data-stu-id="afe41-356">We do this to prevent the user from seeing an unnatural movement which could lead to discomfort.</span></span> <span data-ttu-id="afe41-357">フェードとフェードアウト効果は非常に単純です。</span><span class="sxs-lookup"><span data-stu-id="afe41-357">The fade in and out effect is fairly simple.</span></span> <span data-ttu-id="afe41-358">ある分岐の前でブラック クアッド、**メイン カメラ**します。</span><span class="sxs-lookup"><span data-stu-id="afe41-358">We have a black quad hanging in front of the **main camera**.</span></span> <span data-ttu-id="afe41-359">フェードアウトとアルファ値は 0 から 1 に移行します。</span><span class="sxs-lookup"><span data-stu-id="afe41-359">When fading out we transition the alpha value from 0 to 1.</span></span> <span data-ttu-id="afe41-360">これは、黒のピクセルをレンダリングし、それらの背後にある何かがわかりにくくなる 4 つの段階的にによりします。</span><span class="sxs-lookup"><span data-stu-id="afe41-360">This gradually causes the black pixels of the quad to render and obscure anything behind them.</span></span> <span data-ttu-id="afe41-361">フェードに戻るときに、アルファ値を 0 に移行します。</span><span class="sxs-lookup"><span data-stu-id="afe41-361">When fading back in we transition the alpha value back to zero.</span></span>

<span data-ttu-id="afe41-362">回転角度を計算します 回転していることに注意してください、**けん引**周りの回転角度を計算するが、**メイン カメラ**します。</span><span class="sxs-lookup"><span data-stu-id="afe41-362">When we calculate the rotation, note that we are rotating our **dolly** but calculating the rotation around the **main camera**.</span></span> <span data-ttu-id="afe41-363">これは、遠いとして重要、**メイン カメラ**0,0,0 から正確な少なく、けん引周りの回転角度になるユーザーの観点からは、します。</span><span class="sxs-lookup"><span data-stu-id="afe41-363">This is important as the farther the **main camera** is away from 0,0,0, the less accurate a rotation around the dolly would become from the point of view of the user.</span></span> <span data-ttu-id="afe41-364">実際には、カメラの位置を回転しない場合、ユーザーは、円弧の周囲に移動は、**けん引**回転ではなく。</span><span class="sxs-lookup"><span data-stu-id="afe41-364">In fact, if you do not rotate around the camera position, the user will move on an arc around the **dolly** rather than rotating.</span></span>

<span data-ttu-id="afe41-365">MixedRealityTeleport の 2 つ目のジョブは移動を処理するためには、**けん引**します。</span><span class="sxs-lookup"><span data-stu-id="afe41-365">The second job for MixedRealityTeleport is to handle moving the **dolly**.</span></span> <span data-ttu-id="afe41-366">これは、SetWorldPosition で行われます。</span><span class="sxs-lookup"><span data-stu-id="afe41-366">This is done in SetWorldPosition.</span></span> <span data-ttu-id="afe41-367">SetWorldPosition は必要なワールド位置を占めます。 したがって、percieve にユーザーが必要がある位置を受け取ります。</span><span class="sxs-lookup"><span data-stu-id="afe41-367">SetWorldPosition takes the desired world position, the position where the user wants to percieve that they inhabit.</span></span> <span data-ttu-id="afe41-368">配置する必要があります、**けん引**マイナスのローカルの位置には、その位置にある、**メイン カメラ**、フレームごとに、そのオフセットが追加されます。</span><span class="sxs-lookup"><span data-stu-id="afe41-368">We need to put our **dolly** at that position minus the local position of the **main camera**, as that offset will be added each frame.</span></span>

<span data-ttu-id="afe41-369">2 番目のスクリプトでは、SetWorldPosition を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="afe41-369">A second script calls SetWorldPosition.</span></span> <span data-ttu-id="afe41-370">そのスクリプトを見てみましょう。</span><span class="sxs-lookup"><span data-stu-id="afe41-370">Let's look at that script.</span></span> <span data-ttu-id="afe41-371">[プロジェクト] パネルに移動します**Assets\AppPrefabs\Support\Scripts\GameLogic**ダブルクリックして**TeleportScript.cs**します。</span><span class="sxs-lookup"><span data-stu-id="afe41-371">In the project panel, navigate to **Assets\AppPrefabs\Support\Scripts\GameLogic** and double-click on **TeleportScript.cs**.</span></span>

<span data-ttu-id="afe41-372">このスクリプトは MixedRealityTeleport よりも少し複雑です。</span><span class="sxs-lookup"><span data-stu-id="afe41-372">This script is a little more involved than MixedRealityTeleport.</span></span> <span data-ttu-id="afe41-373">スクリプトは、Y のボタン保持する Xbox コント ローラーを確認しています。</span><span class="sxs-lookup"><span data-stu-id="afe41-373">The script is checking for the Y Button on the Xbox controller to be held down.</span></span> <span data-ttu-id="afe41-374">ボタンが保持されている間は、カーソルが表示されます、テレポート ダウンし、スクリプトが視線の先のユーザーの位置から伸びる射線をキャストします。</span><span class="sxs-lookup"><span data-stu-id="afe41-374">While the button is held down a teleport cursor is rendered and the script casts a ray from the user's gaze position.</span></span> <span data-ttu-id="afe41-375">その光線が多いか少ないは画面と競合している場合は、上向き、画面は、テレポートに適切な画面に検討され、テレポート カーソル上でアニメーションが有効になります。</span><span class="sxs-lookup"><span data-stu-id="afe41-375">If that ray collides with a surface that is more or less pointing up, the surface will be considered a good surface to teleport to, and the animation on the teleport cursor will be enabled.</span></span> <span data-ttu-id="afe41-376">射線が多いか少ない上向きサーフェイスと衝突しない場合、カーソル上でアニメーションを無効化されます。</span><span class="sxs-lookup"><span data-stu-id="afe41-376">If the ray does not collide with a surface more or less pointing up, then the animation on the cursor will be disabled.</span></span> <span data-ttu-id="afe41-377">Y ボタンが解放され、光線の計算されるポイントは有効な位置をスクリプトは、射線が交差する位置を SetWorldPosition を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="afe41-377">When the Y button is released and the calculated point of the ray is a valid position, the script calls SetWorldPosition with the position the ray intersected.</span></span>

### <a name="enjoy-your-progress"></a><span data-ttu-id="afe41-378">進行状況をお楽しみください。</span><span class="sxs-lookup"><span data-stu-id="afe41-378">Enjoy your progress</span></span>

<span data-ttu-id="afe41-379">この時間を友人を検索する必要があります。</span><span class="sxs-lookup"><span data-stu-id="afe41-379">This time you'll need to find a friend.</span></span>

<span data-ttu-id="afe41-380">もう一度、HoloLens を持つユーザーは、セッションをホストします。</span><span class="sxs-lookup"><span data-stu-id="afe41-380">Once again, a user with the HoloLens will host a session.</span></span> <span data-ttu-id="afe41-381">他のユーザーはセッションに参加します。</span><span class="sxs-lookup"><span data-stu-id="afe41-381">Other users will join the session.</span></span> <span data-ttu-id="afe41-382">アプリケーションには、最初の 3 つのユーザーに、島に 3 つのパスのいずれかで没入型のヘッドセットから参加が配置されます。</span><span class="sxs-lookup"><span data-stu-id="afe41-382">The application will place the first three users to join from an immersive headset on one of the three paths on the island.</span></span> <span data-ttu-id="afe41-383">このセクションの島を探索してもかまいません。</span><span class="sxs-lookup"><span data-stu-id="afe41-383">Feel free to explore the island in this section.</span></span>

<span data-ttu-id="afe41-384">詳細に注意してください:</span><span class="sxs-lookup"><span data-stu-id="afe41-384">Details to notice:</span></span>
1. <span data-ttu-id="afe41-385">HoloLens のユーザーを検索する方向を参照してください。 immersed のユーザーに役立ちますクラウド内の顔を確認できます。</span><span class="sxs-lookup"><span data-stu-id="afe41-385">You can see faces in the clouds, which helps an immersed user see which direction a HoloLens user is looking.</span></span>
2. <span data-ttu-id="afe41-386">島アバターは、回転突き止めるがあります。</span><span class="sxs-lookup"><span data-stu-id="afe41-386">The avatars on the island have necks that rotate.</span></span> <span data-ttu-id="afe41-387">ユーザーが何に従うことはありません (その情報はありません) 実際には実際は、優れたエクスペリエンスのためです。</span><span class="sxs-lookup"><span data-stu-id="afe41-387">They won't follow what the user is doing is real reality (we don't have that information) but it makes for a nice experience.</span></span>
3. <span data-ttu-id="afe41-388">HoloLens のユーザーは、島を見て、immersed ユーザーにカーソルが表示されます。</span><span class="sxs-lookup"><span data-stu-id="afe41-388">If the HoloLens user is looking at the Island, the immersed users can see their cursor.</span></span>
4. <span data-ttu-id="afe41-389">HoloLens のユーザーを表すクラウドは、シャドウをキャストします。</span><span class="sxs-lookup"><span data-stu-id="afe41-389">The clouds that represent the HoloLens users cast shadows.</span></span>

## <a name="chapter-5---finale"></a><span data-ttu-id="afe41-390">第 5 章「お</span><span class="sxs-lookup"><span data-stu-id="afe41-390">Chapter 5 - Finale</span></span>

>[!VIDEO https://www.youtube.com/embed/n_HDWJbfpNg]

### <a name="objectives"></a><span data-ttu-id="afe41-391">目標</span><span class="sxs-lookup"><span data-stu-id="afe41-391">Objectives</span></span>

<span data-ttu-id="afe41-392">2 つのデバイスの種類間のコラボレーション対話型環境を作成します。</span><span class="sxs-lookup"><span data-stu-id="afe41-392">Create a collaborative interactive experience between the two device types.</span></span>

### <a name="what-we-will-build"></a><span data-ttu-id="afe41-393">構築します。</span><span class="sxs-lookup"><span data-stu-id="afe41-393">What we will build</span></span>

<span data-ttu-id="afe41-394">第 4 章に基づき島、パズルの近く、イマーシブ ヘッドセットを持つユーザーを取得すると、HoloLens ユーザーでは、パズルへの手掛かりのツールヒントが表示されます。</span><span class="sxs-lookup"><span data-stu-id="afe41-394">Building on chapter 4, when a user with an immersive headset gets near a puzzle on the island, the HoloLens users will get a tool tip with a clue to the puzzle.</span></span> <span data-ttu-id="afe41-395">ロケット部屋にそのパズル過去と"準備完了"パッド上を取得のすべてのイマーシブ ヘッドセット ユーザー、ロケットが起動されます。</span><span class="sxs-lookup"><span data-stu-id="afe41-395">Once all of the immersive headset users get past their puzzles and onto the "ready pad" in the rocket room, the rocket will launch.</span></span>

### <a name="steps"></a><span data-ttu-id="afe41-396">手順</span><span class="sxs-lookup"><span data-stu-id="afe41-396">Steps</span></span>
* <span data-ttu-id="afe41-397">**階層**、 **Usland**します。</span><span class="sxs-lookup"><span data-stu-id="afe41-397">In **Hierarchy**, select **Usland**.</span></span>
* <span data-ttu-id="afe41-398">**インスペクター**で、**レベルの制御**、確認**を有効にするコラボレーション**します。</span><span class="sxs-lookup"><span data-stu-id="afe41-398">In **Inspector**, in **Level Control**, check **Enable Collaboration**.</span></span>

### <a name="digging-into-the-code"></a><span data-ttu-id="afe41-399">コードをについてください。</span><span class="sxs-lookup"><span data-stu-id="afe41-399">Digging into the code</span></span>

<span data-ttu-id="afe41-400">ここで見て LevelControl.cs します。</span><span class="sxs-lookup"><span data-stu-id="afe41-400">Now let us look at LevelControl.cs.</span></span> <span data-ttu-id="afe41-401">このスクリプトでは、ゲーム ロジックの中核となるはし、ゲームの状態を保持します。</span><span class="sxs-lookup"><span data-stu-id="afe41-401">This script is the core of the game logic and maintains the game state.</span></span> <span data-ttu-id="afe41-402">これは UNET を使用して、マルチ プレーヤー ゲームからデータの流れも、少なくともこのチュートリアルを変更するかを理解する必要があります。</span><span class="sxs-lookup"><span data-stu-id="afe41-402">Since this is a multiplayer game using UNET we need to understand how data flows, at least well enough to modify this tutorial.</span></span> <span data-ttu-id="afe41-403">UNET のより詳細な概要については、Unity のドキュメントを参照してください。</span><span class="sxs-lookup"><span data-stu-id="afe41-403">For a more complete overview of UNET, please refer to Unity's documentation.</span></span>

<span data-ttu-id="afe41-404">[プロジェクト] パネルに移動します**Assets\AppPrefabs\Support\Scripts\GameLogic**ダブルクリックして**LevelControl.cs**します。</span><span class="sxs-lookup"><span data-stu-id="afe41-404">In the project panel, navigate to **Assets\AppPrefabs\Support\Scripts\GameLogic** and double-click on **LevelControl.cs**.</span></span>

<span data-ttu-id="afe41-405">イマーシブ ヘッドセットが、ロケットの準備ができていることを示す方法を説明しましょう。</span><span class="sxs-lookup"><span data-stu-id="afe41-405">Let us understand how an immersive headset indicates that they are ready for the rocket launch.</span></span> <span data-ttu-id="afe41-406">ロケット起動の準備は、島に 3 つのパスに対応するブールの一覧で次の 3 つのブールのいずれかを設定して伝達されます。</span><span class="sxs-lookup"><span data-stu-id="afe41-406">Rocket Launch readiness is communicated by setting one of three bools in a list of bools that correspond to the three paths on the island.</span></span> <span data-ttu-id="afe41-407">ロケット ルーム茶色パッド上に、パスに割り当てられたユーザーの場合は、パスのブール値が設定されます。</span><span class="sxs-lookup"><span data-stu-id="afe41-407">A path's bool will be set when the user assigned to the path is on top of the brown pad inside the rocket room.</span></span> <span data-ttu-id="afe41-408">では、詳細にようになりました。</span><span class="sxs-lookup"><span data-stu-id="afe41-408">Okay, now to the details.</span></span>

<span data-ttu-id="afe41-409">私たちは、Update() 関数で開始されます。</span><span class="sxs-lookup"><span data-stu-id="afe41-409">We will start in the Update() function.</span></span> <span data-ttu-id="afe41-410">'チート' 関数があることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="afe41-410">You will note that there is a 'cheat' function.</span></span> <span data-ttu-id="afe41-411">使用してこの開発で、ロケットをテストし、シーケンスをリセットしました。</span><span class="sxs-lookup"><span data-stu-id="afe41-411">We used this in development to test the rocket launch and reset sequence.</span></span> <span data-ttu-id="afe41-412">マルチ ユーザーのエクスペリエンスでは機能しません。</span><span class="sxs-lookup"><span data-stu-id="afe41-412">It won't work in the multi user experience.</span></span> <span data-ttu-id="afe41-413">できれば次の情報が内在化時間で行うことができます動作します。</span><span class="sxs-lookup"><span data-stu-id="afe41-413">Hopefully by the time you internalize the following infromation you can make it work.</span></span> <span data-ttu-id="afe41-414">かどうか、ローカルのプレーヤーが専念した状態を確認します後ずるをかどうかを確認します。</span><span class="sxs-lookup"><span data-stu-id="afe41-414">After we check to see if we should cheat, we check to see if the local player is immersed.</span></span> <span data-ttu-id="afe41-415">目標にしていることを探す方法に注目します。</span><span class="sxs-lookup"><span data-stu-id="afe41-415">We want to focus on how we find that we're at the goal.</span></span> <span data-ttu-id="afe41-416">場合は、内部で (専念した状態) を確認する CheckGoal の背後にある非表示の呼び出しは、 **EnableCollaboration** bool。</span><span class="sxs-lookup"><span data-stu-id="afe41-416">Inside of the if (Immersed) check, there is a call to CheckGoal hiding behind the **EnableCollaboration** bool.</span></span> <span data-ttu-id="afe41-417">これは、この章の手順を実行中にオンにしたチェック ボックスをオンに対応します。</span><span class="sxs-lookup"><span data-stu-id="afe41-417">This corresponds to the checkbox you checked while completing the steps for this chapter.</span></span> <span data-ttu-id="afe41-418">内部 EnableCollaboration CheckGoal() への呼び出しがわかります。</span><span class="sxs-lookup"><span data-stu-id="afe41-418">Inside of EnableCollaboration we see a call to CheckGoal().</span></span>

<span data-ttu-id="afe41-419">CheckGoal は、いくつかの数学、パッドを越えますが多いか少ないかどうかを参照してください。</span><span class="sxs-lookup"><span data-stu-id="afe41-419">CheckGoal does some math to see if we are more or less standing on the pad.</span></span> <span data-ttu-id="afe41-420">ときに Debug.Log「目標に着荷済」し、そこで 'SendAtGoalMessage()' を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="afe41-420">When we are, we Debug.Log "Arrived at goal" and then we call 'SendAtGoalMessage()'.</span></span> <span data-ttu-id="afe41-421">SendAtGoalMessage で playerController.SendAtGoal と呼んでいます。</span><span class="sxs-lookup"><span data-stu-id="afe41-421">In SendAtGoalMessage we call playerController.SendAtGoal.</span></span> <span data-ttu-id="afe41-422">いくつかの時間を節約するには、次のコードに示します。</span><span class="sxs-lookup"><span data-stu-id="afe41-422">To save you some time, here's the code:</span></span>

```cs
private void CmdSendAtGoal(int GoalIndex)
       {
           levelState.SetGoalIndex(GoalIndex);
       }
```

```cs
public void SendAtGoal(int GoalIndex)
       {
           if (isLocalPlayer)
           {
               Debug.Log("sending at goal " + GoalIndex);
               CmdSendAtGoal(GoalIndex);
           }
       }
```

<span data-ttu-id="afe41-423">SendAtGoalMessage CmdSendAtGoal、どの呼び出し levelState.SetGoalIndex、LevelControl.cs に戻ります。 これを呼び出すことに注意してください。</span><span class="sxs-lookup"><span data-stu-id="afe41-423">Note that SendAtGoalMessage calls CmdSendAtGoal, which calls levelState.SetGoalIndex, which is back in LevelControl.cs.</span></span> <span data-ttu-id="afe41-424">これは一見奇妙な見えます。</span><span class="sxs-lookup"><span data-stu-id="afe41-424">At first glance this seems strange.</span></span> <span data-ttu-id="afe41-425">なぜ呼び出せばこれではなく SetGoalIndex player コント ローラーを介してルーティング奇妙なでしょうか。</span><span class="sxs-lookup"><span data-stu-id="afe41-425">Why not just call SetGoalIndex rather than this strange routing through the player controller?</span></span> <span data-ttu-id="afe41-426">理由は、私たちが UNET はデータの同期を保つを使用してデータ モデルに一致します。ずるをしてスラッシングを防ぐには、UNET は、各オブジェクトに同期された変数を変更する権限を持つユーザーが含まれている必要があります。</span><span class="sxs-lookup"><span data-stu-id="afe41-426">The reason is that we are conforming to the data model UNET uses to keep data in sync. To prevent cheating and thrashing, UNET requires that each object has a user who has authority to change the synchronized variables.</span></span> <span data-ttu-id="afe41-427">さらに、(セッションを開始したユーザー) のホストだけでは、データを直接変更することができます。</span><span class="sxs-lookup"><span data-stu-id="afe41-427">Further, only the host (the user that started the session) can change data directly.</span></span> <span data-ttu-id="afe41-428">ホストではありませんが、権限を持つユーザーは、変数を変更するホストに 'command' を送信する必要があります。</span><span class="sxs-lookup"><span data-stu-id="afe41-428">Users who are not the host, but have authority, need to send a 'command' to the host which will change the variable.</span></span> <span data-ttu-id="afe41-429">既定では、ホストは、ユーザーを表す生成されたオブジェクトを除く、すべてのオブジェクトに対して権限を持ちます。</span><span class="sxs-lookup"><span data-stu-id="afe41-429">By default the host has authority over all objects, except for the object spawned to represent the user.</span></span> <span data-ttu-id="afe41-430">ここでは、このオブジェクトには、playercontroller スクリプトがあります。</span><span class="sxs-lookup"><span data-stu-id="afe41-430">In our case this object has the playercontroller script.</span></span> <span data-ttu-id="afe41-431">オブジェクトの権限を要求し、変更する方法がありますが、player コント ローラーは、player コント ローラーを介して自己の機関とルート コマンドであるという事実を利用してを選択します。</span><span class="sxs-lookup"><span data-stu-id="afe41-431">There is a way to request authority for an object and then make changes, but we choose to leverage the fact that the player controller has self authority and route commands through the player controller.</span></span>

<span data-ttu-id="afe41-432">目標で自分たちが見つかった場合は、プレーヤーは、ホストに通知する必要がありますホストには、その他のユーザー通知は、別の方法と言われます。</span><span class="sxs-lookup"><span data-stu-id="afe41-432">Said another way, when we've found ourselves at our goal, the player needs to tell the host, and the host will tell everyone else.</span></span>

<span data-ttu-id="afe41-433">LevelControl.cs SetGoalIndex 見てに戻る</span><span class="sxs-lookup"><span data-stu-id="afe41-433">Back in LevelControl.cs look at SetGoalIndex.</span></span> <span data-ttu-id="afe41-434">ここで synclist (AtGoal) に値の値を設定します。</span><span class="sxs-lookup"><span data-stu-id="afe41-434">Here we are setting the value of a value in a synclist (AtGoal).</span></span> <span data-ttu-id="afe41-435">このような処理中に、ホストのコンテキストでは注意してください。</span><span class="sxs-lookup"><span data-stu-id="afe41-435">Remember that we are in the context of the host while we do this.</span></span> <span data-ttu-id="afe41-436">コマンドと同様に、RPC は、ホストを発行できますが、いくつかのコードを実行するすべてのクライアントです。</span><span class="sxs-lookup"><span data-stu-id="afe41-436">Similar to a command, an RPC is something the host can issue that will cause all clients to run some code.</span></span> <span data-ttu-id="afe41-437">ここで 'RpcCheckAllGoals' を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="afe41-437">Here we call 'RpcCheckAllGoals'.</span></span> <span data-ttu-id="afe41-438">各クライアントは個別にかどうかは、すべての 3 つ AtGoals が設定されているかを確認してくださいと、そうである場合は、ロケットを起動します。</span><span class="sxs-lookup"><span data-stu-id="afe41-438">Each client will individually check to see if all three AtGoals are set, and if so, launch the rocket.</span></span>

### <a name="enjoy-your-progress"></a><span data-ttu-id="afe41-439">進行状況をお楽しみください。</span><span class="sxs-lookup"><span data-stu-id="afe41-439">Enjoy your progress</span></span>

<span data-ttu-id="afe41-440">前のチャプターに基づき、私たちの前としてセッションが開始されます。</span><span class="sxs-lookup"><span data-stu-id="afe41-440">Building on the previous chapter, we will start the session as before.</span></span> <span data-ttu-id="afe41-441">この時間を自分のパスで、「ドア」をイマーシブ ヘッドセット get 内のユーザーとして HoloLens ユーザーのみが認識できることツールヒントが表示されます。</span><span class="sxs-lookup"><span data-stu-id="afe41-441">This time as the users in the immersive headset get to the "door" on their path, a tooltip will appear that only the HoloLens users can see.</span></span> <span data-ttu-id="afe41-442">HoloLens のユーザーは、イマーシブ ヘッドセットのユーザーにこの手掛かりの通信を担当します。</span><span class="sxs-lookup"><span data-stu-id="afe41-442">The HoloLens users are responsible for communicating this clue to the users in the immersive headset.</span></span> <span data-ttu-id="afe41-443">火山内の対応する茶色パッドに各アバターがステップ インしたら、ロケットが領域を起動します。</span><span class="sxs-lookup"><span data-stu-id="afe41-443">The rocket will launch to space once each avatar has stepped on its corresponding brown pad inside the volcano.</span></span> <span data-ttu-id="afe41-444">もう一度行うことができますので、60 秒後に、シーンがリセットされます。</span><span class="sxs-lookup"><span data-stu-id="afe41-444">The scene will reset after 60 seconds so you can do it again.</span></span>

## <a name="see-also"></a><span data-ttu-id="afe41-445">関連項目</span><span class="sxs-lookup"><span data-stu-id="afe41-445">See also</span></span>
* [<span data-ttu-id="afe41-446">MR 入力 213:アニメーション コント ローラー</span><span class="sxs-lookup"><span data-stu-id="afe41-446">MR Input 213: Motion controllers</span></span>](mixed-reality-213.md)
